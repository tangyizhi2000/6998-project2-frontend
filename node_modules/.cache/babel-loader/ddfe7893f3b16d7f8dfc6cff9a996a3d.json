{"ast":null,"code":"/**\n * Handles character removal\n *\n * @param initialValue Current value of input\n * @param format MaskFormat object\n * @param selectionStart Starting index value of selection cursor\n * @param selectionEnd Ending Index value of selection cursor\n */\nexport const backspaceHandler = (initialValue, format, selectionStart, selectionEnd) => {\n  const multiCharDelete = selectionStart !== selectionEnd;\n  if (multiCharDelete) {\n    const isCursorAtEnd = selectionEnd === initialValue.length;\n    if (!isCursorAtEnd) {\n      return format.replaceDigitsWithZeroes(initialValue, selectionStart, selectionEnd);\n    }\n    return {\n      value: initialValue.slice(0, selectionStart),\n      position: selectionStart\n    };\n  }\n  const isSeparator = format.isSegmentStart(selectionStart);\n  const atEnd = selectionStart === initialValue.length;\n  if (!atEnd) {\n    if (isSeparator) {\n      return format.deleteSeparator(initialValue, selectionStart);\n    } else {\n      return format.deleteDigit(initialValue, selectionStart);\n    }\n  }\n  if (isSeparator) {\n    return {\n      value: initialValue.slice(0, selectionStart - 2),\n      position: selectionStart - 2\n    };\n  }\n  return {\n    value: initialValue.slice(0, selectionStart - 1),\n    position: selectionStart - 1\n  };\n};\n/**\n * Handle key down events\n *\n * @param initialValue Current value of input\n * @param key Key that was pressed\n * @param format MaskFormat object\n * @param selectionStart Starting index value of selection cursor\n * @param selectionEnd Ending Index value of selection cursor\n */\nexport const keyHandler = (initialValue, key, format, selectionStart, selectionEnd) => {\n  let value = initialValue;\n  const position = selectionStart;\n  // return if no more digits can be added at the end\n  if (selectionStart === value.length && value.length === format.getMaxLength()) {\n    return {\n      value,\n      position\n    };\n  }\n  // if range is selected to the end, remove all of that selection first\n  if (selectionStart !== value.length && selectionEnd === value.length) {\n    const sliceEnd = format.isCursorAtSeparator(selectionStart) ? selectionStart + 1 : selectionStart;\n    value = initialValue.slice(0, sliceEnd);\n  }\n  if (format.isCursorAtSeparator(position)) {\n    return {\n      value,\n      position: position + 1\n    };\n  }\n  return format.processKey(value, key, position);\n};\nexport const enterHandler = (value, format) => {\n  // Do not autocomplete if input is empty\n  if (!value) {\n    return {\n      value: '',\n      position: 0\n    };\n  }\n  const autoCompletedValue = format.autoComplete(value);\n  const position = autoCompletedValue.length;\n  return {\n    value: autoCompletedValue,\n    position\n  };\n};","map":{"version":3,"mappings":"AASA;;;;;;;;AAQA,OAAO,MAAMA,gBAAgB,GAAG,CAC9BC,YAAoB,EACpBC,MAAkB,EAClBC,cAAsB,EACtBC,YAAoB,KACH;EACjB,MAAMC,eAAe,GAAGF,cAAc,KAAKC,YAAY;EACvD,IAAIC,eAAe,EAAE;IACnB,MAAMC,aAAa,GAAGF,YAAY,KAAKH,YAAY,CAACM,MAAM;IAC1D,IAAI,CAACD,aAAa,EAAE;MAClB,OAAOJ,MAAM,CAACM,uBAAuB,CAACP,YAAY,EAAEE,cAAc,EAAEC,YAAY,CAAC;;IAGnF,OAAO;MACLK,KAAK,EAAER,YAAY,CAACS,KAAK,CAAC,CAAC,EAAEP,cAAc,CAAC;MAC5CQ,QAAQ,EAAER;KACX;;EAGH,MAAMS,WAAW,GAAGV,MAAM,CAACW,cAAc,CAACV,cAAc,CAAC;EACzD,MAAMW,KAAK,GAAGX,cAAc,KAAKF,YAAY,CAACM,MAAM;EAEpD,IAAI,CAACO,KAAK,EAAE;IACV,IAAIF,WAAW,EAAE;MACf,OAAOV,MAAM,CAACa,eAAe,CAACd,YAAY,EAAEE,cAAc,CAAC;KAC5D,MAAM;MACL,OAAOD,MAAM,CAACc,WAAW,CAACf,YAAY,EAAEE,cAAc,CAAC;;;EAI3D,IAAIS,WAAW,EAAE;IACf,OAAO;MACLH,KAAK,EAAER,YAAY,CAACS,KAAK,CAAC,CAAC,EAAEP,cAAc,GAAG,CAAC,CAAC;MAChDQ,QAAQ,EAAER,cAAc,GAAG;KAC5B;;EAGH,OAAO;IACLM,KAAK,EAAER,YAAY,CAACS,KAAK,CAAC,CAAC,EAAEP,cAAc,GAAG,CAAC,CAAC;IAChDQ,QAAQ,EAAER,cAAc,GAAG;GAC5B;AACH,CAAC;AAED;;;;;;;;;AASA,OAAO,MAAMc,UAAU,GAAG,CACxBhB,YAAoB,EACpBiB,GAAW,EACXhB,MAAkB,EAClBC,cAAsB,EACtBC,YAAoB,KACH;EACjB,IAAIK,KAAK,GAAGR,YAAY;EACxB,MAAMU,QAAQ,GAAGR,cAAc;EAE/B;EACA,IAAIA,cAAc,KAAKM,KAAK,CAACF,MAAM,IAAIE,KAAK,CAACF,MAAM,KAAKL,MAAM,CAACiB,YAAY,EAAE,EAAE;IAC7E,OAAO;MAAEV,KAAK;MAAEE;IAAQ,CAAE;;EAG5B;EACA,IAAIR,cAAc,KAAKM,KAAK,CAACF,MAAM,IAAIH,YAAY,KAAKK,KAAK,CAACF,MAAM,EAAE;IACpE,MAAMa,QAAQ,GAAGlB,MAAM,CAACmB,mBAAmB,CAAClB,cAAc,CAAC,GAAGA,cAAc,GAAG,CAAC,GAAGA,cAAc;IACjGM,KAAK,GAAGR,YAAY,CAACS,KAAK,CAAC,CAAC,EAAEU,QAAQ,CAAC;;EAGzC,IAAIlB,MAAM,CAACmB,mBAAmB,CAACV,QAAQ,CAAC,EAAE;IACxC,OAAO;MAAEF,KAAK;MAAEE,QAAQ,EAAEA,QAAQ,GAAG;IAAC,CAAE;;EAG1C,OAAOT,MAAM,CAACoB,UAAU,CAACb,KAAK,EAAES,GAAG,EAAEP,QAAQ,CAAC;AAChD,CAAC;AAED,OAAO,MAAMY,YAAY,GAAG,CAACd,KAAa,EAAEP,MAAkB,KAAmB;EAC/E;EACA,IAAI,CAACO,KAAK,EAAE;IACV,OAAO;MAAEA,KAAK,EAAE,EAAE;MAAEE,QAAQ,EAAE;IAAC,CAAE;;EAEnC,MAAMa,kBAAkB,GAAGtB,MAAM,CAACuB,YAAY,CAAChB,KAAK,CAAC;EACrD,MAAME,QAAQ,GAAGa,kBAAkB,CAACjB,MAAM;EAC1C,OAAO;IAAEE,KAAK,EAAEe,kBAAkB;IAAEb;EAAQ,CAAE;AAChD,CAAC","names":["backspaceHandler","initialValue","format","selectionStart","selectionEnd","multiCharDelete","isCursorAtEnd","length","replaceDigitsWithZeroes","value","slice","position","isSeparator","isSegmentStart","atEnd","deleteSeparator","deleteDigit","keyHandler","key","getMaxLength","sliceEnd","isCursorAtSeparator","processKey","enterHandler","autoCompletedValue","autoComplete"],"sources":["/Users/tangyizhi/Desktop/Assignment 2/frontend/node_modules/@cloudscape-design/components/internal/components/masked-input/lib/default/internal/components/masked-input/keyboard-handler.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport MaskFormat from './utils/mask-format';\n\nexport interface HandlerResult {\n  position: number;\n  value: string;\n}\n\n/**\n * Handles character removal\n *\n * @param initialValue Current value of input\n * @param format MaskFormat object\n * @param selectionStart Starting index value of selection cursor\n * @param selectionEnd Ending Index value of selection cursor\n */\nexport const backspaceHandler = (\n  initialValue: string,\n  format: MaskFormat,\n  selectionStart: number,\n  selectionEnd: number\n): HandlerResult => {\n  const multiCharDelete = selectionStart !== selectionEnd;\n  if (multiCharDelete) {\n    const isCursorAtEnd = selectionEnd === initialValue.length;\n    if (!isCursorAtEnd) {\n      return format.replaceDigitsWithZeroes(initialValue, selectionStart, selectionEnd);\n    }\n\n    return {\n      value: initialValue.slice(0, selectionStart),\n      position: selectionStart,\n    };\n  }\n\n  const isSeparator = format.isSegmentStart(selectionStart);\n  const atEnd = selectionStart === initialValue.length;\n\n  if (!atEnd) {\n    if (isSeparator) {\n      return format.deleteSeparator(initialValue, selectionStart);\n    } else {\n      return format.deleteDigit(initialValue, selectionStart);\n    }\n  }\n\n  if (isSeparator) {\n    return {\n      value: initialValue.slice(0, selectionStart - 2),\n      position: selectionStart - 2,\n    };\n  }\n\n  return {\n    value: initialValue.slice(0, selectionStart - 1),\n    position: selectionStart - 1,\n  };\n};\n\n/**\n * Handle key down events\n *\n * @param initialValue Current value of input\n * @param key Key that was pressed\n * @param format MaskFormat object\n * @param selectionStart Starting index value of selection cursor\n * @param selectionEnd Ending Index value of selection cursor\n */\nexport const keyHandler = (\n  initialValue: string,\n  key: string,\n  format: MaskFormat,\n  selectionStart: number,\n  selectionEnd: number\n): HandlerResult => {\n  let value = initialValue;\n  const position = selectionStart;\n\n  // return if no more digits can be added at the end\n  if (selectionStart === value.length && value.length === format.getMaxLength()) {\n    return { value, position };\n  }\n\n  // if range is selected to the end, remove all of that selection first\n  if (selectionStart !== value.length && selectionEnd === value.length) {\n    const sliceEnd = format.isCursorAtSeparator(selectionStart) ? selectionStart + 1 : selectionStart;\n    value = initialValue.slice(0, sliceEnd);\n  }\n\n  if (format.isCursorAtSeparator(position)) {\n    return { value, position: position + 1 };\n  }\n\n  return format.processKey(value, key, position);\n};\n\nexport const enterHandler = (value: string, format: MaskFormat): HandlerResult => {\n  // Do not autocomplete if input is empty\n  if (!value) {\n    return { value: '', position: 0 };\n  }\n  const autoCompletedValue = format.autoComplete(value);\n  const position = autoCompletedValue.length;\n  return { value: autoCompletedValue, position };\n};\n"]},"metadata":{},"sourceType":"module"}