{"ast":null,"code":"import _toConsumableArray from \"/Users/tangyizhi/Desktop/Assignment2/frontend/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _slicedToArray from \"/Users/tangyizhi/Desktop/Assignment2/frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { useCallback, useEffect, useState } from 'react';\nvar isBrowser = typeof window !== 'undefined';\n/**\n * Hook to implement scroll-spy functionality.\n *\n * @param hrefs An array of href strings that correspond to the IDs of the target elements on the page.\n * The hrefs should be sorted in the order they appear on the page for accurate scroll-spy behavior.\n * @param scrollSpyOffset The number of pixels to offset from the top of the document when activating anchors.\n * Useful for accommodating fixed or sticky headers.\n * @param activeHref The currently active href. If provided, the hook will operate in a controlled manner,\n * and the scroll-spy logic will be disabled.\n *\n * @returns {string | undefined} - The href of the currently active element as per scroll position, or undefined if none is active.\n */\nexport default function useScrollSpy(_ref) {\n  var hrefs = _ref.hrefs,\n    scrollSpyOffset = _ref.scrollSpyOffset,\n    activeHref = _ref.activeHref;\n  var _useState = useState(activeHref),\n    _useState2 = _slicedToArray(_useState, 2),\n    currentHref = _useState2[0],\n    setCurrentHref = _useState2[1];\n  var _useState3 = useState(false),\n    _useState4 = _slicedToArray(_useState3, 2),\n    lastAnchorExists = _useState4[0],\n    setLastAnchorExists = _useState4[1];\n  useEffect(function () {\n    setCurrentHref(activeHref);\n  }, [activeHref]);\n  useEffect(function () {\n    var _a;\n    setLastAnchorExists(isBrowser && !!document.getElementById((_a = hrefs[hrefs.length - 1]) === null || _a === void 0 ? void 0 : _a.slice(1)));\n  }, [hrefs]);\n  // Get the bounding rectangle of an element by href\n  var getRectByHref = useCallback(function (href) {\n    var _a;\n    return (_a = document.getElementById(href.slice(1))) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect();\n  }, []);\n  // Check if we're scrolled to the bottom of the page\n  var isPageBottom = useCallback(function () {\n    return lastAnchorExists && Math.ceil(window.scrollY) >= Math.floor(document.body.scrollHeight - window.innerHeight);\n  }, [lastAnchorExists]);\n  // Find the first href for which the element is within the viewport\n  var findHrefInView = useCallback(function () {\n    return hrefs.find(function (href) {\n      var rect = getRectByHref(href);\n      return rect && rect.bottom <= window.innerHeight && rect.top >= scrollSpyOffset;\n    });\n  }, [getRectByHref, scrollSpyOffset, hrefs]);\n  // Find the last href where its element is above or within the viewport\n  var findLastHrefInView = useCallback(function () {\n    return _toConsumableArray(hrefs).reverse().find(function (href) {\n      var rect = getRectByHref(href);\n      return rect && rect.bottom <= window.innerHeight;\n    });\n  }, [getRectByHref, hrefs]);\n  // Scroll event handler\n  var handleScroll = useCallback(function () {\n    if (activeHref || !isBrowser) {\n      return;\n    }\n    var _window = window,\n      scrollY = _window.scrollY;\n    if (document.body.scrollHeight > window.innerHeight && isPageBottom()) {\n      setCurrentHref(hrefs[hrefs.length - 1]);\n    } else {\n      setCurrentHref(findHrefInView() || (scrollY > 0 ? findLastHrefInView() : undefined));\n    }\n  }, [activeHref, isPageBottom, findHrefInView, findLastHrefInView, hrefs]);\n  useEffect(function () {\n    if (isBrowser) {\n      handleScroll();\n      window.addEventListener('scroll', handleScroll, {\n        passive: true\n      });\n      return function () {\n        window.removeEventListener('scroll', handleScroll);\n      };\n    }\n  }, [handleScroll]);\n  return currentHref;\n}","map":{"version":3,"mappings":"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","names":["useCallback","useEffect","useState","isBrowser","window","useScrollSpy","hrefs","scrollSpyOffset","activeHref","currentHref","setCurrentHref","lastAnchorExists","setLastAnchorExists","document","getElementById","length","slice","getRectByHref","href","getBoundingClientRect","isPageBottom","Math","ceil","scrollY","floor","body","scrollHeight","innerHeight","findHrefInView","find","rect","bottom","top","findLastHrefInView","reverse","handleScroll","undefined","addEventListener","passive","removeEventListener"],"sources":["/Users/tangyizhi/Desktop/Assignment2/frontend/node_modules/@cloudscape-design/components/anchor-navigation/lib/default/anchor-navigation/use-scroll-spy.tsx"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { useCallback, useEffect, useState } from 'react';\n\nconst isBrowser = typeof window !== 'undefined';\n\n/**\n * Hook to implement scroll-spy functionality.\n *\n * @param hrefs An array of href strings that correspond to the IDs of the target elements on the page.\n * The hrefs should be sorted in the order they appear on the page for accurate scroll-spy behavior.\n * @param scrollSpyOffset The number of pixels to offset from the top of the document when activating anchors.\n * Useful for accommodating fixed or sticky headers.\n * @param activeHref The currently active href. If provided, the hook will operate in a controlled manner,\n * and the scroll-spy logic will be disabled.\n *\n * @returns {string | undefined} - The href of the currently active element as per scroll position, or undefined if none is active.\n */\nexport default function useScrollSpy({\n  hrefs,\n  scrollSpyOffset,\n  activeHref,\n}: {\n  hrefs: string[];\n  scrollSpyOffset: number;\n  activeHref?: string;\n}): string | undefined {\n  const [currentHref, setCurrentHref] = useState<string | undefined>(activeHref);\n  const [lastAnchorExists, setLastAnchorExists] = useState(false);\n\n  useEffect(() => {\n    setCurrentHref(activeHref);\n  }, [activeHref]);\n\n  useEffect(() => {\n    setLastAnchorExists(isBrowser && !!document.getElementById(hrefs[hrefs.length - 1]?.slice(1)));\n  }, [hrefs]);\n\n  // Get the bounding rectangle of an element by href\n  const getRectByHref = useCallback(href => {\n    return document.getElementById(href.slice(1))?.getBoundingClientRect();\n  }, []);\n\n  // Check if we're scrolled to the bottom of the page\n  const isPageBottom = useCallback(() => {\n    return lastAnchorExists && Math.ceil(window.scrollY) >= Math.floor(document.body.scrollHeight - window.innerHeight);\n  }, [lastAnchorExists]);\n\n  // Find the first href for which the element is within the viewport\n  const findHrefInView = useCallback(() => {\n    return hrefs.find(href => {\n      const rect = getRectByHref(href);\n      return rect && rect.bottom <= window.innerHeight && rect.top >= scrollSpyOffset;\n    });\n  }, [getRectByHref, scrollSpyOffset, hrefs]);\n\n  // Find the last href where its element is above or within the viewport\n  const findLastHrefInView = useCallback(() => {\n    return [...hrefs].reverse().find(href => {\n      const rect = getRectByHref(href);\n      return rect && rect.bottom <= window.innerHeight;\n    });\n  }, [getRectByHref, hrefs]);\n\n  // Scroll event handler\n  const handleScroll = useCallback(() => {\n    if (activeHref || !isBrowser) {\n      return;\n    }\n\n    const { scrollY } = window;\n\n    if (document.body.scrollHeight > window.innerHeight && isPageBottom()) {\n      setCurrentHref(hrefs[hrefs.length - 1]);\n    } else {\n      setCurrentHref(findHrefInView() || (scrollY > 0 ? findLastHrefInView() : undefined));\n    }\n  }, [activeHref, isPageBottom, findHrefInView, findLastHrefInView, hrefs]);\n\n  useEffect(() => {\n    if (isBrowser) {\n      handleScroll();\n      window.addEventListener('scroll', handleScroll, { passive: true });\n      return () => {\n        window.removeEventListener('scroll', handleScroll);\n      };\n    }\n  }, [handleScroll]);\n\n  return currentHref;\n}\n"]},"metadata":{},"sourceType":"module"}