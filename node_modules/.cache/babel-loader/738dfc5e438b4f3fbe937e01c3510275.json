{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/tangyizhi/Desktop/Assignment2/frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { canUseDOM, subtract as getCoordinatesDelta } from '@dnd-kit/utilities';\nimport { KeyboardCode } from '@dnd-kit/core';\nfunction isDocumentScrollingElement(element) {\n  if (!canUseDOM || !element) {\n    return false;\n  }\n  return element === document.scrollingElement;\n}\nexport function getScrollPosition(scrollingContainer) {\n  var minScroll = {\n    x: 0,\n    y: 0\n  };\n  var dimensions = isDocumentScrollingElement(scrollingContainer) ? {\n    height: window.innerHeight,\n    width: window.innerWidth\n  } : {\n    height: scrollingContainer.clientHeight,\n    width: scrollingContainer.clientWidth\n  };\n  var maxScroll = {\n    x: scrollingContainer.scrollWidth - dimensions.width,\n    y: scrollingContainer.scrollHeight - dimensions.height\n  };\n  var isTop = scrollingContainer.scrollTop <= minScroll.y;\n  var isLeft = scrollingContainer.scrollLeft <= minScroll.x;\n  var isBottom = scrollingContainer.scrollTop >= maxScroll.y;\n  var isRight = scrollingContainer.scrollLeft >= maxScroll.x;\n  return {\n    isTop: isTop,\n    isLeft: isLeft,\n    isBottom: isBottom,\n    isRight: isRight,\n    maxScroll: maxScroll,\n    minScroll: minScroll\n  };\n}\nexport function getScrollElementRect(element) {\n  if (element === document.scrollingElement) {\n    var _window = window,\n      innerWidth = _window.innerWidth,\n      innerHeight = _window.innerHeight;\n    return {\n      top: 0,\n      left: 0,\n      right: innerWidth,\n      bottom: innerHeight,\n      width: innerWidth,\n      height: innerHeight\n    };\n  }\n  var _element$getBoundingC = element.getBoundingClientRect(),\n    top = _element$getBoundingC.top,\n    left = _element$getBoundingC.left,\n    right = _element$getBoundingC.right,\n    bottom = _element$getBoundingC.bottom;\n  return {\n    top: top,\n    left: left,\n    right: right,\n    bottom: bottom,\n    width: element.clientWidth,\n    height: element.clientHeight\n  };\n}\nexport function applyScroll(_ref) {\n  var currentCoordinates = _ref.currentCoordinates,\n    direction = _ref.direction,\n    newCoordinates = _ref.newCoordinates,\n    scrollableAncestors = _ref.scrollableAncestors;\n  var _iterator = _createForOfIteratorHelper(scrollableAncestors),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var scrollContainer = _step.value;\n      var coordinatesDelta = getCoordinatesDelta(newCoordinates, currentCoordinates);\n      var _getScrollPosition = getScrollPosition(scrollContainer),\n        isTop = _getScrollPosition.isTop,\n        isBottom = _getScrollPosition.isBottom,\n        maxScroll = _getScrollPosition.maxScroll,\n        minScroll = _getScrollPosition.minScroll;\n      var scrollElementRect = getScrollElementRect(scrollContainer);\n      var clampedCoordinates = {\n        y: Math.min(direction === KeyboardCode.Down ? scrollElementRect.bottom - scrollElementRect.height / 2 : scrollElementRect.bottom, Math.max(direction === KeyboardCode.Down ? scrollElementRect.top : scrollElementRect.top + scrollElementRect.height / 2, newCoordinates.y))\n      };\n      var canScrollY = direction === KeyboardCode.Down && !isBottom || direction === KeyboardCode.Up && !isTop;\n      if (canScrollY && clampedCoordinates.y !== newCoordinates.y) {\n        var newScrollCoordinates = scrollContainer.scrollTop + coordinatesDelta.y;\n        var canScrollToNewCoordinates = direction === KeyboardCode.Down && newScrollCoordinates <= maxScroll.y || direction === KeyboardCode.Up && newScrollCoordinates >= minScroll.y;\n        if (canScrollToNewCoordinates) {\n          // We don't need to update coordinates, the scroll adjustment alone will trigger\n          // logic to auto-detect the new container we are over\n          scrollContainer.scrollTo({\n            top: newScrollCoordinates,\n            behavior: 'smooth'\n          });\n          return true;\n        }\n        break;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return false;\n}","map":{"version":3,"mappings":"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","names":["canUseDOM","subtract","getCoordinatesDelta","KeyboardCode","isDocumentScrollingElement","element","document","scrollingElement","getScrollPosition","scrollingContainer","minScroll","x","y","dimensions","height","window","innerHeight","width","innerWidth","clientHeight","clientWidth","maxScroll","scrollWidth","scrollHeight","isTop","scrollTop","isLeft","scrollLeft","isBottom","isRight","getScrollElementRect","top","left","right","bottom","getBoundingClientRect","applyScroll","currentCoordinates","direction","newCoordinates","scrollableAncestors","scrollContainer","coordinatesDelta","scrollElementRect","clampedCoordinates","Math","min","Down","max","canScrollY","Up","newScrollCoordinates","canScrollToNewCoordinates","scrollTo","behavior"],"sources":["/Users/tangyizhi/Desktop/Assignment2/frontend/node_modules/@cloudscape-design/components/collection-preferences/content-display/keyboard-sensor/utilities/lib/default/collection-preferences/content-display/keyboard-sensor/utilities/scroll.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { canUseDOM, Coordinates, subtract as getCoordinatesDelta } from '@dnd-kit/utilities';\nimport { KeyboardCode } from '@dnd-kit/core';\n\nfunction isDocumentScrollingElement(element: Element | null) {\n  if (!canUseDOM || !element) {\n    return false;\n  }\n\n  return element === document.scrollingElement;\n}\n\nexport function getScrollPosition(scrollingContainer: Element) {\n  const minScroll = {\n    x: 0,\n    y: 0,\n  };\n  const dimensions = isDocumentScrollingElement(scrollingContainer)\n    ? {\n        height: window.innerHeight,\n        width: window.innerWidth,\n      }\n    : {\n        height: scrollingContainer.clientHeight,\n        width: scrollingContainer.clientWidth,\n      };\n  const maxScroll = {\n    x: scrollingContainer.scrollWidth - dimensions.width,\n    y: scrollingContainer.scrollHeight - dimensions.height,\n  };\n\n  const isTop = scrollingContainer.scrollTop <= minScroll.y;\n  const isLeft = scrollingContainer.scrollLeft <= minScroll.x;\n  const isBottom = scrollingContainer.scrollTop >= maxScroll.y;\n  const isRight = scrollingContainer.scrollLeft >= maxScroll.x;\n\n  return {\n    isTop,\n    isLeft,\n    isBottom,\n    isRight,\n    maxScroll,\n    minScroll,\n  };\n}\n\nexport function getScrollElementRect(element: Element) {\n  if (element === document.scrollingElement) {\n    const { innerWidth, innerHeight } = window;\n\n    return {\n      top: 0,\n      left: 0,\n      right: innerWidth,\n      bottom: innerHeight,\n      width: innerWidth,\n      height: innerHeight,\n    };\n  }\n\n  const { top, left, right, bottom } = element.getBoundingClientRect();\n\n  return {\n    top,\n    left,\n    right,\n    bottom,\n    width: element.clientWidth,\n    height: element.clientHeight,\n  };\n}\n\nexport function applyScroll({\n  currentCoordinates,\n  direction,\n  newCoordinates,\n  scrollableAncestors,\n}: {\n  currentCoordinates: Coordinates;\n  direction: string;\n  newCoordinates: Coordinates;\n  scrollableAncestors: Element[];\n}) {\n  for (const scrollContainer of scrollableAncestors) {\n    const coordinatesDelta = getCoordinatesDelta(newCoordinates, currentCoordinates);\n    const { isTop, isBottom, maxScroll, minScroll } = getScrollPosition(scrollContainer);\n    const scrollElementRect = getScrollElementRect(scrollContainer);\n\n    const clampedCoordinates = {\n      y: Math.min(\n        direction === KeyboardCode.Down\n          ? scrollElementRect.bottom - scrollElementRect.height / 2\n          : scrollElementRect.bottom,\n        Math.max(\n          direction === KeyboardCode.Down\n            ? scrollElementRect.top\n            : scrollElementRect.top + scrollElementRect.height / 2,\n          newCoordinates.y\n        )\n      ),\n    };\n\n    const canScrollY = (direction === KeyboardCode.Down && !isBottom) || (direction === KeyboardCode.Up && !isTop);\n\n    if (canScrollY && clampedCoordinates.y !== newCoordinates.y) {\n      const newScrollCoordinates = scrollContainer.scrollTop + coordinatesDelta.y;\n      const canScrollToNewCoordinates =\n        (direction === KeyboardCode.Down && newScrollCoordinates <= maxScroll.y) ||\n        (direction === KeyboardCode.Up && newScrollCoordinates >= minScroll.y);\n\n      if (canScrollToNewCoordinates) {\n        // We don't need to update coordinates, the scroll adjustment alone will trigger\n        // logic to auto-detect the new container we are over\n        scrollContainer.scrollTo({\n          top: newScrollCoordinates,\n          behavior: 'smooth',\n        });\n        return true;\n      }\n\n      break;\n    }\n  }\n  return false;\n}\n"]},"metadata":{},"sourceType":"module"}