{"ast":null,"code":"import { __rest } from \"tslib\";\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport React, { useCallback, useImperativeHandle, useLayoutEffect, useMemo, useRef } from 'react';\nimport clsx from 'clsx';\nimport { getBaseProps } from '../internal/base-component';\nimport { fireNonCancelableEvent } from '../internal/events';\nimport InternalAttributeEditor from '../attribute-editor/internal';\nimport InternalStatusIndicator from '../status-indicator/internal';\nimport InternalBox from '../box/internal';\nimport { FormFieldError } from '../form-field/internal';\nimport { TagControl, UndoButton } from './internal';\nimport { validate } from './validation';\nimport { findIndex, useMemoizedArray } from './utils';\nimport styles from './styles.css.js';\nimport { applyDisplayName } from '../internal/utils/apply-display-name';\nimport useBaseComponent from '../internal/hooks/use-base-component';\nimport LiveRegion from '../internal/components/live-region';\nimport { useInternalI18n } from '../i18n/context';\nimport { useStableCallback } from '@cloudscape-design/component-toolkit/internal';\nconst isItemRemovable = _ref => {\n  let {\n    tag\n  } = _ref;\n  return !tag.markedForRemoval;\n};\nconst TagEditor = React.forwardRef((_a, ref) => {\n  var _b, _c, _d, _e, _f, _g;\n  var {\n      tags = [],\n      i18nStrings,\n      loading = false,\n      tagLimit = 50,\n      allowedCharacterPattern,\n      keysRequest,\n      valuesRequest,\n      onChange\n    } = _a,\n    restProps = __rest(_a, [\"tags\", \"i18nStrings\", \"loading\", \"tagLimit\", \"allowedCharacterPattern\", \"keysRequest\", \"valuesRequest\", \"onChange\"]);\n  const baseComponentProps = useBaseComponent('TagEditor');\n  const i18n = useInternalI18n('tag-editor');\n  const remainingTags = tagLimit - tags.filter(tag => !tag.markedForRemoval).length;\n  const attributeEditorRef = useRef(null);\n  const keyInputRefs = useRef([]);\n  const valueInputRefs = useRef([]);\n  const undoButtonRefs = useRef([]);\n  const initialKeyOptionsRef = useRef([]);\n  const keyDirtyStateRef = useRef([]);\n  const focusEventRef = useRef();\n  useLayoutEffect(() => {\n    var _a;\n    (_a = focusEventRef.current) === null || _a === void 0 ? void 0 : _a.apply(undefined);\n    focusEventRef.current = undefined;\n  });\n  const errors = validate(tags, keyDirtyStateRef.current, i18n, i18nStrings, allowedCharacterPattern ? new RegExp(allowedCharacterPattern) : undefined);\n  const internalTags = useMemoizedArray(tags.map((tag, i) => ({\n    tag,\n    error: errors[i]\n  })), (prev, next) => {\n    var _a, _b, _c, _d;\n    return prev.tag === next.tag && ((_a = prev.error) === null || _a === void 0 ? void 0 : _a.key) === ((_b = next.error) === null || _b === void 0 ? void 0 : _b.key) && ((_c = prev.error) === null || _c === void 0 ? void 0 : _c.value) === ((_d = next.error) === null || _d === void 0 ? void 0 : _d.value);\n  });\n  useImperativeHandle(ref, () => ({\n    focus() {\n      var _a, _b;\n      const errorIndex = findIndex(internalTags, _ref2 => {\n        let {\n          error\n        } = _ref2;\n        return (error === null || error === void 0 ? void 0 : error.key) || (error === null || error === void 0 ? void 0 : error.value);\n      });\n      if (errorIndex !== -1) {\n        const refArray = ((_a = internalTags[errorIndex].error) === null || _a === void 0 ? void 0 : _a.key) ? keyInputRefs : valueInputRefs;\n        (_b = refArray.current[errorIndex]) === null || _b === void 0 ? void 0 : _b.focus();\n      }\n    }\n  }), [internalTags]);\n  const validateAndFire = useCallback(newTags => {\n    fireNonCancelableEvent(onChange, {\n      tags: newTags,\n      valid: !validate(newTags, keyDirtyStateRef.current, i18n, i18nStrings, allowedCharacterPattern ? new RegExp(allowedCharacterPattern) : undefined).some(error => error)\n    });\n  }, [onChange, i18n, i18nStrings, allowedCharacterPattern]);\n  const onAddButtonClick = () => {\n    validateAndFire([...tags, {\n      key: '',\n      value: '',\n      existing: false\n    }]);\n    focusEventRef.current = () => {\n      var _a;\n      (_a = keyInputRefs.current[tags.length]) === null || _a === void 0 ? void 0 : _a.focus();\n    };\n  };\n  const onRemoveButtonClick = useStableCallback(_ref3 => {\n    let {\n      detail\n    } = _ref3;\n    var _a, _b, _c, _d, _e;\n    const existing = tags[detail.itemIndex].existing;\n    validateAndFire([...tags.slice(0, detail.itemIndex), ...(existing ? [Object.assign(Object.assign({}, tags[detail.itemIndex]), {\n      markedForRemoval: true\n    })] : []), ...tags.slice(detail.itemIndex + 1)]);\n    if (existing) {\n      focusEventRef.current = () => {\n        var _a;\n        (_a = undoButtonRefs.current[detail.itemIndex]) === null || _a === void 0 ? void 0 : _a.focus();\n      };\n    } else {\n      keyDirtyStateRef.current.splice(detail.itemIndex, 1);\n      const nextKey = keyInputRefs.current[detail.itemIndex + 1];\n      if (nextKey) {\n        // if next key is present, focus _current_ key which will be replaced by next after state update\n        (_a = keyInputRefs.current[detail.itemIndex]) === null || _a === void 0 ? void 0 : _a.focus();\n      } else if (detail.itemIndex > 0) {\n        // otherwise focus previous key/value/undo button\n        const previousIsExisting = tags[detail.itemIndex - 1].existing;\n        if (previousIsExisting) {\n          if (tags[detail.itemIndex - 1].markedForRemoval) {\n            (_b = undoButtonRefs.current[detail.itemIndex - 1]) === null || _b === void 0 ? void 0 : _b.focus();\n          } else {\n            (_c = valueInputRefs.current[detail.itemIndex - 1]) === null || _c === void 0 ? void 0 : _c.focus();\n          }\n        } else {\n          (_d = keyInputRefs.current[detail.itemIndex - 1]) === null || _d === void 0 ? void 0 : _d.focus();\n        }\n      } else {\n        // or the 'add' button\n        (_e = attributeEditorRef.current) === null || _e === void 0 ? void 0 : _e.focusAddButton();\n      }\n    }\n  });\n  const onKeyChange = useStableCallback((value, row) => {\n    keyDirtyStateRef.current[row] = true;\n    validateAndFire([...tags.slice(0, row), Object.assign(Object.assign({}, tags[row]), {\n      key: value\n    }), ...tags.slice(row + 1)]);\n  });\n  const onKeyBlur = useStableCallback(row => {\n    keyDirtyStateRef.current[row] = true;\n    // Force re-render by providing a new array reference\n    validateAndFire([...tags]);\n  });\n  const onValueChange = useStableCallback((value, row) => {\n    validateAndFire([...tags.slice(0, row), Object.assign(Object.assign({}, tags[row]), {\n      value\n    }), ...tags.slice(row + 1)]);\n  });\n  const onUndoRemoval = useStableCallback(row => {\n    validateAndFire([...tags.slice(0, row), Object.assign(Object.assign({}, tags[row]), {\n      markedForRemoval: false\n    }), ...tags.slice(row + 1)]);\n    focusEventRef.current = () => {\n      var _a;\n      (_a = attributeEditorRef.current) === null || _a === void 0 ? void 0 : _a.focusRemoveButton(row);\n    };\n  });\n  const definition = useMemo(() => [{\n    label: i18n('i18nStrings.keyHeader', i18nStrings === null || i18nStrings === void 0 ? void 0 : i18nStrings.keyHeader),\n    control: (_ref4, row) => {\n      let {\n        tag\n      } = _ref4;\n      return React.createElement(TagControl, {\n        row: row,\n        value: tag.key,\n        readOnly: tag.existing,\n        limit: 200,\n        defaultOptions: [],\n        placeholder: i18n('i18nStrings.keyPlaceholder', i18nStrings === null || i18nStrings === void 0 ? void 0 : i18nStrings.keyPlaceholder),\n        errorText: i18n('i18nStrings.keysSuggestionError', i18nStrings === null || i18nStrings === void 0 ? void 0 : i18nStrings.keysSuggestionError),\n        loadingText: i18n('i18nStrings.keysSuggestionLoading', i18nStrings === null || i18nStrings === void 0 ? void 0 : i18nStrings.keysSuggestionLoading),\n        suggestionText: i18n('i18nStrings.keySuggestion', i18nStrings === null || i18nStrings === void 0 ? void 0 : i18nStrings.keySuggestion),\n        tooManySuggestionText: i18n('i18nStrings.tooManyKeysSuggestion', i18nStrings === null || i18nStrings === void 0 ? void 0 : i18nStrings.tooManyKeysSuggestion),\n        enteredTextLabel: i18nStrings === null || i18nStrings === void 0 ? void 0 : i18nStrings.enteredKeyLabel,\n        clearAriaLabel: i18nStrings === null || i18nStrings === void 0 ? void 0 : i18nStrings.clearAriaLabel,\n        onRequest: keysRequest,\n        onChange: onKeyChange,\n        onBlur: onKeyBlur,\n        initialOptionsRef: initialKeyOptionsRef,\n        ref: ref => {\n          keyInputRefs.current[row] = ref;\n        }\n      });\n    },\n    errorText: _ref5 => {\n      let {\n        error\n      } = _ref5;\n      return error === null || error === void 0 ? void 0 : error.key;\n    }\n  }, {\n    label: React.createElement(React.Fragment, null, i18n('i18nStrings.valueHeader', i18nStrings === null || i18nStrings === void 0 ? void 0 : i18nStrings.valueHeader), \" -\", ' ', React.createElement(\"i\", null, i18n('i18nStrings.optional', i18nStrings === null || i18nStrings === void 0 ? void 0 : i18nStrings.optional))),\n    control: (_ref6, row) => {\n      let {\n        tag\n      } = _ref6;\n      var _a;\n      return tag.markedForRemoval ? React.createElement(\"div\", {\n        role: \"alert\"\n      }, React.createElement(InternalBox, {\n        margin: {\n          top: 'xxs'\n        }\n      }, i18n('i18nStrings.undoPrompt', i18nStrings === null || i18nStrings === void 0 ? void 0 : i18nStrings.undoPrompt), ' ', React.createElement(UndoButton, {\n        onClick: () => onUndoRemoval(row),\n        ref: elem => {\n          undoButtonRefs.current[row] = elem;\n        }\n      }, i18n('i18nStrings.undoButton', i18nStrings === null || i18nStrings === void 0 ? void 0 : i18nStrings.undoButton)))) : React.createElement(TagControl, {\n        row: row,\n        value: tag.value,\n        readOnly: false,\n        limit: 200,\n        defaultOptions: (_a = tag.valueSuggestionOptions) !== null && _a !== void 0 ? _a : [],\n        placeholder: i18n('i18nStrings.valuePlaceholder', i18nStrings === null || i18nStrings === void 0 ? void 0 : i18nStrings.valuePlaceholder),\n        errorText: i18n('i18nStrings.valuesSuggestionError', i18nStrings === null || i18nStrings === void 0 ? void 0 : i18nStrings.valuesSuggestionError),\n        loadingText: i18n('i18nStrings.valuesSuggestionLoading', i18nStrings === null || i18nStrings === void 0 ? void 0 : i18nStrings.valuesSuggestionLoading),\n        suggestionText: i18n('i18nStrings.valueSuggestion', i18nStrings === null || i18nStrings === void 0 ? void 0 : i18nStrings.valueSuggestion),\n        tooManySuggestionText: i18n('i18nStrings.tooManyValuesSuggestion', i18nStrings === null || i18nStrings === void 0 ? void 0 : i18nStrings.tooManyValuesSuggestion),\n        enteredTextLabel: i18nStrings === null || i18nStrings === void 0 ? void 0 : i18nStrings.enteredValueLabel,\n        clearAriaLabel: i18nStrings === null || i18nStrings === void 0 ? void 0 : i18nStrings.clearAriaLabel,\n        filteringKey: tag.key,\n        onRequest: valuesRequest && (value => valuesRequest(tag.key, value)),\n        onChange: onValueChange,\n        ref: ref => {\n          valueInputRefs.current[row] = ref;\n        }\n      });\n    },\n    errorText: _ref7 => {\n      let {\n        error\n      } = _ref7;\n      return error === null || error === void 0 ? void 0 : error.value;\n    }\n  }], [i18n, i18nStrings, keysRequest, onKeyChange, onKeyBlur, valuesRequest, onValueChange, onUndoRemoval]);\n  const forwardedI18nStrings = useMemo(() => ({\n    errorIconAriaLabel: i18nStrings === null || i18nStrings === void 0 ? void 0 : i18nStrings.errorIconAriaLabel,\n    itemRemovedAriaLive: i18nStrings === null || i18nStrings === void 0 ? void 0 : i18nStrings.itemRemovedAriaLive,\n    removeButtonAriaLabel: i18n('i18nStrings.removeButtonAriaLabel', (i18nStrings === null || i18nStrings === void 0 ? void 0 : i18nStrings.removeButtonAriaLabel) && (_ref8 => {\n      let {\n        tag\n      } = _ref8;\n      return i18nStrings.removeButtonAriaLabel(tag);\n    }), format => _ref9 => {\n      let {\n        tag\n      } = _ref9;\n      return format({\n        tag__key: tag.key\n      });\n    })\n  }), [i18nStrings, i18n]);\n  if (loading) {\n    return React.createElement(\"div\", {\n      className: styles.root,\n      ref: baseComponentProps.__internalRootRef\n    }, React.createElement(InternalStatusIndicator, {\n      className: styles.loading,\n      type: \"loading\"\n    }, React.createElement(LiveRegion, {\n      visible: true\n    }, i18n('i18nStrings.loading', i18nStrings === null || i18nStrings === void 0 ? void 0 : i18nStrings.loading))));\n  }\n  const baseProps = getBaseProps(restProps);\n  return React.createElement(InternalAttributeEditor, Object.assign({}, baseProps, baseComponentProps, {\n    ref: attributeEditorRef,\n    className: clsx(styles.root, baseProps.className),\n    items: internalTags,\n    isItemRemovable: isItemRemovable,\n    onAddButtonClick: onAddButtonClick,\n    onRemoveButtonClick: onRemoveButtonClick,\n    addButtonText: (_b = i18n('i18nStrings.addButton', i18nStrings === null || i18nStrings === void 0 ? void 0 : i18nStrings.addButton)) !== null && _b !== void 0 ? _b : '',\n    removeButtonText: i18nStrings === null || i18nStrings === void 0 ? void 0 : i18nStrings.removeButton,\n    disableAddButton: remainingTags <= 0,\n    empty: i18n('i18nStrings.emptyTags', i18nStrings === null || i18nStrings === void 0 ? void 0 : i18nStrings.emptyTags),\n    additionalInfo: remainingTags < 0 ? React.createElement(FormFieldError, {\n      errorIconAriaLabel: i18nStrings === null || i18nStrings === void 0 ? void 0 : i18nStrings.errorIconAriaLabel\n    }, (_d = i18n('i18nStrings.tagLimitExceeded', (_c = i18nStrings === null || i18nStrings === void 0 ? void 0 : i18nStrings.tagLimitExceeded) === null || _c === void 0 ? void 0 : _c.call(i18nStrings, tagLimit), format => format({\n      tagLimit\n    }))) !== null && _d !== void 0 ? _d : '') : remainingTags === 0 ? (_f = i18n('i18nStrings.tagLimitReached', (_e = i18nStrings === null || i18nStrings === void 0 ? void 0 : i18nStrings.tagLimitReached) === null || _e === void 0 ? void 0 : _e.call(i18nStrings, tagLimit), format => format({\n      tagLimit\n    }))) !== null && _f !== void 0 ? _f : '' : i18n('i18nStrings.tagLimit', (_g = i18nStrings === null || i18nStrings === void 0 ? void 0 : i18nStrings.tagLimit) === null || _g === void 0 ? void 0 : _g.call(i18nStrings, remainingTags, tagLimit), format => format({\n      tagLimitAvailable: `${remainingTags === tagLimit}`,\n      availableTags: remainingTags,\n      tagLimit\n    })),\n    definition: definition,\n    i18nStrings: forwardedI18nStrings\n  }));\n});\napplyDisplayName(TagEditor, 'TagEditor');\nexport default TagEditor;","map":{"version":3,"mappings":"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","names":["React","useCallback","useImperativeHandle","useLayoutEffect","useMemo","useRef","clsx","getBaseProps","fireNonCancelableEvent","InternalAttributeEditor","InternalStatusIndicator","InternalBox","FormFieldError","TagControl","UndoButton","validate","findIndex","useMemoizedArray","styles","applyDisplayName","useBaseComponent","LiveRegion","useInternalI18n","useStableCallback","isItemRemovable","tag","markedForRemoval","TagEditor","forwardRef","_a","ref","tags","i18nStrings","loading","tagLimit","allowedCharacterPattern","keysRequest","valuesRequest","onChange","restProps","baseComponentProps","i18n","remainingTags","filter","length","attributeEditorRef","keyInputRefs","valueInputRefs","undoButtonRefs","initialKeyOptionsRef","keyDirtyStateRef","focusEventRef","current","apply","undefined","errors","RegExp","internalTags","map","i","error","prev","next","key","value","focus","errorIndex","refArray","validateAndFire","newTags","valid","some","onAddButtonClick","existing","onRemoveButtonClick","detail","itemIndex","slice","splice","nextKey","previousIsExisting","focusAddButton","onKeyChange","row","onKeyBlur","onValueChange","onUndoRemoval","focusRemoveButton","definition","label","keyHeader","control","readOnly","limit","defaultOptions","placeholder","keyPlaceholder","errorText","keysSuggestionError","loadingText","keysSuggestionLoading","suggestionText","keySuggestion","tooManySuggestionText","tooManyKeysSuggestion","enteredTextLabel","enteredKeyLabel","clearAriaLabel","onRequest","onBlur","initialOptionsRef","valueHeader","optional","role","margin","top","undoPrompt","onClick","elem","undoButton","valueSuggestionOptions","valuePlaceholder","valuesSuggestionError","valuesSuggestionLoading","valueSuggestion","tooManyValuesSuggestion","enteredValueLabel","filteringKey","forwardedI18nStrings","errorIconAriaLabel","itemRemovedAriaLive","removeButtonAriaLabel","format","tag__key","className","root","__internalRootRef","type","visible","baseProps","items","addButtonText","addButton","removeButtonText","removeButton","disableAddButton","empty","emptyTags","additionalInfo","tagLimitExceeded","tagLimitReached","tagLimitAvailable","availableTags"],"sources":["/Users/tangyizhi/Desktop/Assignment 2/frontend/node_modules/@cloudscape-design/components/tag-editor/lib/default/tag-editor/index.tsx"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport React, { useCallback, useImperativeHandle, useLayoutEffect, useMemo, useRef } from 'react';\nimport clsx from 'clsx';\n\nimport { getBaseProps } from '../internal/base-component';\nimport { fireNonCancelableEvent, NonCancelableCustomEvent } from '../internal/events';\n\nimport { InputProps } from '../input/interfaces';\nimport { AutosuggestProps } from '../autosuggest/interfaces';\nimport { AttributeEditorProps } from '../attribute-editor/interfaces';\nimport InternalAttributeEditor from '../attribute-editor/internal';\nimport InternalStatusIndicator from '../status-indicator/internal';\nimport InternalBox from '../box/internal';\nimport { FormFieldError } from '../form-field/internal';\n\nimport { TagControl, UndoButton } from './internal';\nimport { TagEditorProps } from './interfaces';\nimport { validate, ValidationError } from './validation';\nimport { findIndex, useMemoizedArray } from './utils';\n\nimport styles from './styles.css.js';\nimport { applyDisplayName } from '../internal/utils/apply-display-name';\nimport useBaseComponent from '../internal/hooks/use-base-component';\nimport LiveRegion from '../internal/components/live-region';\nimport { useInternalI18n } from '../i18n/context';\nimport { useStableCallback } from '@cloudscape-design/component-toolkit/internal';\n\nexport { TagEditorProps };\n\ninterface InternalTag {\n  tag: TagEditorProps.Tag;\n  error?: ValidationError;\n}\n\nconst isItemRemovable = ({ tag }: InternalTag) => !tag.markedForRemoval;\n\nconst TagEditor = React.forwardRef(\n  (\n    {\n      tags = [],\n      i18nStrings,\n      loading = false,\n      tagLimit = 50,\n      allowedCharacterPattern,\n      keysRequest,\n      valuesRequest,\n      onChange,\n      ...restProps\n    }: TagEditorProps,\n    ref: React.Ref<TagEditorProps.Ref>\n  ) => {\n    const baseComponentProps = useBaseComponent('TagEditor');\n    const i18n = useInternalI18n('tag-editor');\n\n    const remainingTags = tagLimit - tags.filter(tag => !tag.markedForRemoval).length;\n\n    const attributeEditorRef = useRef<AttributeEditorProps.Ref>(null);\n    const keyInputRefs = useRef<(InputProps.Ref | undefined | null)[]>([]);\n    const valueInputRefs = useRef<(InputProps.Ref | undefined | null)[]>([]);\n    const undoButtonRefs = useRef<(HTMLAnchorElement | undefined | null)[]>([]);\n\n    const initialKeyOptionsRef = useRef<AutosuggestProps.Options>([]);\n    const keyDirtyStateRef = useRef<boolean[]>([]);\n    const focusEventRef = useRef<() => void>();\n\n    useLayoutEffect(() => {\n      focusEventRef.current?.apply(undefined);\n      focusEventRef.current = undefined;\n    });\n\n    const errors = validate(\n      tags,\n      keyDirtyStateRef.current,\n      i18n,\n      i18nStrings,\n      allowedCharacterPattern ? new RegExp(allowedCharacterPattern) : undefined\n    );\n\n    const internalTags = useMemoizedArray(\n      tags.map((tag, i) => ({ tag, error: errors[i] })),\n      (prev, next) => {\n        return prev.tag === next.tag && prev.error?.key === next.error?.key && prev.error?.value === next.error?.value;\n      }\n    );\n\n    useImperativeHandle(\n      ref,\n      () => ({\n        focus() {\n          const errorIndex = findIndex(internalTags, ({ error }) => error?.key || error?.value);\n          if (errorIndex !== -1) {\n            const refArray = internalTags[errorIndex].error?.key ? keyInputRefs : valueInputRefs;\n            refArray.current[errorIndex]?.focus();\n          }\n        },\n      }),\n      [internalTags]\n    );\n\n    const validateAndFire = useCallback(\n      (newTags: ReadonlyArray<TagEditorProps.Tag>) => {\n        fireNonCancelableEvent(onChange, {\n          tags: newTags,\n          valid: !validate(\n            newTags,\n            keyDirtyStateRef.current,\n            i18n,\n            i18nStrings,\n            allowedCharacterPattern ? new RegExp(allowedCharacterPattern) : undefined\n          ).some(error => error),\n        });\n      },\n      [onChange, i18n, i18nStrings, allowedCharacterPattern]\n    );\n\n    const onAddButtonClick = () => {\n      validateAndFire([...tags, { key: '', value: '', existing: false }]);\n      focusEventRef.current = () => {\n        keyInputRefs.current[tags.length]?.focus();\n      };\n    };\n\n    const onRemoveButtonClick = useStableCallback(\n      ({ detail }: NonCancelableCustomEvent<AttributeEditorProps.RemoveButtonClickDetail>) => {\n        const existing = tags[detail.itemIndex].existing;\n        validateAndFire([\n          ...tags.slice(0, detail.itemIndex),\n          ...(existing ? [{ ...tags[detail.itemIndex], markedForRemoval: true }] : []),\n          ...tags.slice(detail.itemIndex + 1),\n        ]);\n        if (existing) {\n          focusEventRef.current = () => {\n            undoButtonRefs.current[detail.itemIndex]?.focus();\n          };\n        } else {\n          keyDirtyStateRef.current.splice(detail.itemIndex, 1);\n          const nextKey = keyInputRefs.current[detail.itemIndex + 1];\n          if (nextKey) {\n            // if next key is present, focus _current_ key which will be replaced by next after state update\n            keyInputRefs.current[detail.itemIndex]?.focus();\n          } else if (detail.itemIndex > 0) {\n            // otherwise focus previous key/value/undo button\n            const previousIsExisting = tags[detail.itemIndex - 1].existing;\n            if (previousIsExisting) {\n              if (tags[detail.itemIndex - 1].markedForRemoval) {\n                undoButtonRefs.current[detail.itemIndex - 1]?.focus();\n              } else {\n                valueInputRefs.current[detail.itemIndex - 1]?.focus();\n              }\n            } else {\n              keyInputRefs.current[detail.itemIndex - 1]?.focus();\n            }\n          } else {\n            // or the 'add' button\n            attributeEditorRef.current?.focusAddButton();\n          }\n        }\n      }\n    );\n\n    const onKeyChange = useStableCallback((value: string, row: number) => {\n      keyDirtyStateRef.current[row] = true;\n      validateAndFire([...tags.slice(0, row), { ...tags[row], key: value }, ...tags.slice(row + 1)]);\n    });\n\n    const onKeyBlur = useStableCallback((row: number) => {\n      keyDirtyStateRef.current[row] = true;\n      // Force re-render by providing a new array reference\n      validateAndFire([...tags]);\n    });\n\n    const onValueChange = useStableCallback((value: string, row: number) => {\n      validateAndFire([...tags.slice(0, row), { ...tags[row], value }, ...tags.slice(row + 1)]);\n    });\n\n    const onUndoRemoval = useStableCallback((row: number) => {\n      validateAndFire([...tags.slice(0, row), { ...tags[row], markedForRemoval: false }, ...tags.slice(row + 1)]);\n      focusEventRef.current = () => {\n        attributeEditorRef.current?.focusRemoveButton(row);\n      };\n    });\n\n    const definition = useMemo(\n      () => [\n        {\n          label: i18n('i18nStrings.keyHeader', i18nStrings?.keyHeader),\n          control: ({ tag }: InternalTag, row: number) => (\n            <TagControl\n              row={row}\n              value={tag.key}\n              readOnly={tag.existing}\n              limit={200}\n              defaultOptions={[]}\n              placeholder={i18n('i18nStrings.keyPlaceholder', i18nStrings?.keyPlaceholder)}\n              errorText={i18n('i18nStrings.keysSuggestionError', i18nStrings?.keysSuggestionError)}\n              loadingText={i18n('i18nStrings.keysSuggestionLoading', i18nStrings?.keysSuggestionLoading)}\n              suggestionText={i18n('i18nStrings.keySuggestion', i18nStrings?.keySuggestion)}\n              tooManySuggestionText={i18n('i18nStrings.tooManyKeysSuggestion', i18nStrings?.tooManyKeysSuggestion)}\n              enteredTextLabel={i18nStrings?.enteredKeyLabel}\n              clearAriaLabel={i18nStrings?.clearAriaLabel}\n              onRequest={keysRequest}\n              onChange={onKeyChange}\n              onBlur={onKeyBlur}\n              initialOptionsRef={initialKeyOptionsRef}\n              ref={ref => {\n                keyInputRefs.current[row] = ref;\n              }}\n            />\n          ),\n          errorText: ({ error }: InternalTag) => error?.key,\n        },\n        {\n          label: (\n            <>\n              {i18n('i18nStrings.valueHeader', i18nStrings?.valueHeader)} -{' '}\n              <i>{i18n('i18nStrings.optional', i18nStrings?.optional)}</i>\n            </>\n          ),\n          control: ({ tag }: InternalTag, row: number) =>\n            tag.markedForRemoval ? (\n              <div role=\"alert\">\n                <InternalBox margin={{ top: 'xxs' }}>\n                  {i18n('i18nStrings.undoPrompt', i18nStrings?.undoPrompt)}{' '}\n                  <UndoButton\n                    onClick={() => onUndoRemoval(row)}\n                    ref={elem => {\n                      undoButtonRefs.current[row] = elem;\n                    }}\n                  >\n                    {i18n('i18nStrings.undoButton', i18nStrings?.undoButton)}\n                  </UndoButton>\n                </InternalBox>\n              </div>\n            ) : (\n              <TagControl\n                row={row}\n                value={tag.value}\n                readOnly={false}\n                limit={200}\n                defaultOptions={tag.valueSuggestionOptions ?? []}\n                placeholder={i18n('i18nStrings.valuePlaceholder', i18nStrings?.valuePlaceholder)}\n                errorText={i18n('i18nStrings.valuesSuggestionError', i18nStrings?.valuesSuggestionError)}\n                loadingText={i18n('i18nStrings.valuesSuggestionLoading', i18nStrings?.valuesSuggestionLoading)}\n                suggestionText={i18n('i18nStrings.valueSuggestion', i18nStrings?.valueSuggestion)}\n                tooManySuggestionText={i18n(\n                  'i18nStrings.tooManyValuesSuggestion',\n                  i18nStrings?.tooManyValuesSuggestion\n                )}\n                enteredTextLabel={i18nStrings?.enteredValueLabel}\n                clearAriaLabel={i18nStrings?.clearAriaLabel}\n                filteringKey={tag.key}\n                onRequest={valuesRequest && (value => valuesRequest(tag.key, value))}\n                onChange={onValueChange}\n                ref={ref => {\n                  valueInputRefs.current[row] = ref;\n                }}\n              />\n            ),\n          errorText: ({ error }: InternalTag) => error?.value,\n        },\n      ],\n      [i18n, i18nStrings, keysRequest, onKeyChange, onKeyBlur, valuesRequest, onValueChange, onUndoRemoval]\n    );\n\n    const forwardedI18nStrings = useMemo<AttributeEditorProps.I18nStrings<InternalTag>>(\n      () => ({\n        errorIconAriaLabel: i18nStrings?.errorIconAriaLabel,\n        itemRemovedAriaLive: i18nStrings?.itemRemovedAriaLive,\n        removeButtonAriaLabel: i18n(\n          'i18nStrings.removeButtonAriaLabel',\n          i18nStrings?.removeButtonAriaLabel && (({ tag }) => i18nStrings.removeButtonAriaLabel!(tag)),\n          format =>\n            ({ tag }) =>\n              format({ tag__key: tag.key })\n        ),\n      }),\n      [i18nStrings, i18n]\n    );\n\n    if (loading) {\n      return (\n        <div className={styles.root} ref={baseComponentProps.__internalRootRef}>\n          <InternalStatusIndicator className={styles.loading} type=\"loading\">\n            <LiveRegion visible={true}>{i18n('i18nStrings.loading', i18nStrings?.loading)}</LiveRegion>\n          </InternalStatusIndicator>\n        </div>\n      );\n    }\n\n    const baseProps = getBaseProps(restProps);\n    return (\n      <InternalAttributeEditor<InternalTag>\n        {...baseProps}\n        {...baseComponentProps}\n        ref={attributeEditorRef}\n        className={clsx(styles.root, baseProps.className)}\n        items={internalTags}\n        isItemRemovable={isItemRemovable}\n        onAddButtonClick={onAddButtonClick}\n        onRemoveButtonClick={onRemoveButtonClick}\n        addButtonText={i18n('i18nStrings.addButton', i18nStrings?.addButton) ?? ''}\n        removeButtonText={i18nStrings?.removeButton}\n        disableAddButton={remainingTags <= 0}\n        empty={i18n('i18nStrings.emptyTags', i18nStrings?.emptyTags)}\n        additionalInfo={\n          remainingTags < 0 ? (\n            <FormFieldError errorIconAriaLabel={i18nStrings?.errorIconAriaLabel}>\n              {i18n('i18nStrings.tagLimitExceeded', i18nStrings?.tagLimitExceeded?.(tagLimit), format =>\n                format({ tagLimit })\n              ) ?? ''}\n            </FormFieldError>\n          ) : remainingTags === 0 ? (\n            i18n('i18nStrings.tagLimitReached', i18nStrings?.tagLimitReached?.(tagLimit), format =>\n              format({ tagLimit })\n            ) ?? ''\n          ) : (\n            i18n('i18nStrings.tagLimit', i18nStrings?.tagLimit?.(remainingTags, tagLimit), format =>\n              format({ tagLimitAvailable: `${remainingTags === tagLimit}`, availableTags: remainingTags, tagLimit })\n            )\n          )\n        }\n        definition={definition}\n        i18nStrings={forwardedI18nStrings}\n      />\n    );\n  }\n);\n\napplyDisplayName(TagEditor, 'TagEditor');\nexport default TagEditor;\n"]},"metadata":{},"sourceType":"module"}