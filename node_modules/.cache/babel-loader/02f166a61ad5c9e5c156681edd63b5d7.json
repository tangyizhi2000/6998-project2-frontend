{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { useCallback, useEffect, useMemo } from 'react';\nimport { scrollElementIntoView } from '../internal/utils/scrollable-containers';\nfunction iterateTableCells(table, func) {\n  table.querySelectorAll('tr').forEach((row, rowIndex) => {\n    row.querySelectorAll('td').forEach((cell, cellIndex) => {\n      func(cell, rowIndex, cellIndex);\n    });\n  });\n}\n/**\n * This hook is used to navigate between table cells using the keyboard arrow keys.\n * All the functionality is implemented in the hook, so the table component does not\n * need to implement any keyboard event handlers.\n * @param enable - Toggle functionality of the hook\n * @param tableRoot - A ref to a table container. Ideally the root element of the table (<table>); tbody is also acceptable.\n * @param columnDefinitions - The column definitions for the table.\n * @param numRows - The number of rows in the table.\n */\nfunction useTableFocusNavigation(selectionType, tableRoot, columnDefinitions, numRows) {\n  const focusableColumns = useMemo(() => {\n    const cols = columnDefinitions.map(column => !!column.editConfig);\n    if (selectionType) {\n      cols.unshift(false);\n    }\n    return cols;\n  }, [columnDefinitions, selectionType]);\n  const maxColumnIndex = focusableColumns.length - 1;\n  const minColumnIndex = selectionType ? 1 : 0;\n  const focusCell = useCallback((rowIndex, columnIndex) => {\n    if (tableRoot === null || tableRoot === void 0 ? void 0 : tableRoot.current) {\n      iterateTableCells(tableRoot.current, (cell, rIndex, cIndex) => {\n        var _a;\n        if (rIndex === rowIndex && cIndex === columnIndex) {\n          const editButton = cell.querySelector('button:last-child');\n          if (editButton) {\n            (_a = editButton.focus) === null || _a === void 0 ? void 0 : _a.call(editButton);\n            scrollElementIntoView(editButton);\n          }\n        }\n      });\n    }\n  }, [tableRoot]);\n  const shiftFocus = useCallback((vertical, horizontal) => {\n    var _a;\n    const focusedCell = (_a = tableRoot.current) === null || _a === void 0 ? void 0 : _a.querySelector('td:focus-within');\n    if (!focusedCell) {\n      return;\n    }\n    const columnIndex = focusedCell.cellIndex;\n    const rowIndex = focusedCell.parentElement.rowIndex;\n    let newRowIndex = rowIndex;\n    let newColumnIndex = columnIndex;\n    if (vertical !== 0) {\n      newRowIndex = Math.min(numRows, Math.max(rowIndex + vertical, 0));\n    }\n    if (horizontal !== 0) {\n      while (newColumnIndex <= maxColumnIndex && newColumnIndex >= minColumnIndex) {\n        newColumnIndex += horizontal;\n        if (focusableColumns[newColumnIndex]) {\n          break;\n        }\n      }\n    }\n    if ((rowIndex !== newRowIndex || columnIndex !== newColumnIndex) && tableRoot.current) {\n      focusCell(newRowIndex, newColumnIndex);\n    }\n  }, [focusCell, focusableColumns, maxColumnIndex, minColumnIndex, numRows, tableRoot]);\n  const handleArrowKeyEvents = useCallback(event => {\n    var _a, _b;\n    const abort = !!((_a = tableRoot.current) === null || _a === void 0 ? void 0 : _a.querySelector('[data-inline-editing-active = \"true\"]')) || !((_b = document.activeElement) === null || _b === void 0 ? void 0 : _b.closest('[data-inline-editing-active]'));\n    if (abort) {\n      return;\n    }\n    switch (event.key) {\n      case 'ArrowUp':\n        event.preventDefault();\n        shiftFocus(-1, 0);\n        break;\n      case 'ArrowDown':\n        event.preventDefault();\n        shiftFocus(1, 0);\n        break;\n      case 'ArrowLeft':\n        event.preventDefault();\n        shiftFocus(0, -1);\n        break;\n      case 'ArrowRight':\n        event.preventDefault();\n        shiftFocus(0, 1);\n        break;\n      // istanbul ignore next (default case = do nothing, not testable)\n      default:\n        return;\n    }\n  }, [shiftFocus, tableRoot]);\n  useEffect(() => {\n    if (!tableRoot.current) {\n      return;\n    }\n    const tableElement = tableRoot.current;\n    tableRoot.current.addEventListener('keydown', handleArrowKeyEvents);\n    return () => tableElement && tableElement.removeEventListener('keydown', handleArrowKeyEvents);\n  }, [focusableColumns, handleArrowKeyEvents, tableRoot]);\n}\nexport default useTableFocusNavigation;","map":{"version":3,"mappings":"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","names":["useCallback","useEffect","useMemo","scrollElementIntoView","iterateTableCells","table","func","querySelectorAll","forEach","row","rowIndex","cell","cellIndex","useTableFocusNavigation","selectionType","tableRoot","columnDefinitions","numRows","focusableColumns","cols","map","column","editConfig","unshift","maxColumnIndex","length","minColumnIndex","focusCell","columnIndex","current","rIndex","cIndex","editButton","querySelector","focus","shiftFocus","vertical","horizontal","focusedCell","parentElement","newRowIndex","newColumnIndex","Math","min","max","handleArrowKeyEvents","event","abort","activeElement","closest","key","preventDefault","tableElement","addEventListener","removeEventListener"],"sources":["/Users/tangyizhi/Desktop/Assignment2/frontend/node_modules/@cloudscape-design/components/table/lib/default/table/use-table-focus-navigation.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { RefObject, useCallback, useEffect, useMemo } from 'react';\nimport { scrollElementIntoView } from '../internal/utils/scrollable-containers';\nimport { TableProps } from './interfaces';\n\nfunction iterateTableCells<T extends HTMLElement>(\n  table: T,\n  func: (cell: HTMLTableCellElement, rowIndex: number, columnIndex: number) => void\n) {\n  table.querySelectorAll('tr').forEach((row: HTMLTableRowElement, rowIndex: number) => {\n    row.querySelectorAll('td').forEach((cell, cellIndex) => {\n      func(cell, rowIndex, cellIndex);\n    });\n  });\n}\n\n/**\n * This hook is used to navigate between table cells using the keyboard arrow keys.\n * All the functionality is implemented in the hook, so the table component does not\n * need to implement any keyboard event handlers.\n * @param enable - Toggle functionality of the hook\n * @param tableRoot - A ref to a table container. Ideally the root element of the table (<table>); tbody is also acceptable.\n * @param columnDefinitions - The column definitions for the table.\n * @param numRows - The number of rows in the table.\n */\nfunction useTableFocusNavigation<T extends { editConfig?: TableProps.EditConfig<any> }>(\n  selectionType: TableProps['selectionType'],\n  tableRoot: RefObject<HTMLTableElement>,\n  columnDefinitions: Readonly<T[]>,\n  numRows: number\n) {\n  const focusableColumns = useMemo(() => {\n    const cols = columnDefinitions.map(column => !!column.editConfig);\n    if (selectionType) {\n      cols.unshift(false);\n    }\n    return cols;\n  }, [columnDefinitions, selectionType]);\n\n  const maxColumnIndex = focusableColumns.length - 1;\n  const minColumnIndex = selectionType ? 1 : 0;\n\n  const focusCell = useCallback(\n    (rowIndex: number, columnIndex: number) => {\n      if (tableRoot?.current) {\n        iterateTableCells(tableRoot.current, (cell, rIndex, cIndex) => {\n          if (rIndex === rowIndex && cIndex === columnIndex) {\n            const editButton = cell.querySelector('button:last-child') as HTMLButtonElement | null;\n\n            if (editButton) {\n              editButton.focus?.();\n              scrollElementIntoView(editButton);\n            }\n          }\n        });\n      }\n    },\n    [tableRoot]\n  );\n\n  const shiftFocus = useCallback(\n    (vertical: -1 | 0 | 1, horizontal: -1 | 0 | 1) => {\n      const focusedCell = tableRoot.current?.querySelector<HTMLTableCellElement>('td:focus-within');\n      if (!focusedCell) {\n        return;\n      }\n\n      const columnIndex = focusedCell.cellIndex;\n      const rowIndex = (focusedCell.parentElement as HTMLTableRowElement).rowIndex;\n\n      let newRowIndex = rowIndex;\n      let newColumnIndex = columnIndex;\n\n      if (vertical !== 0) {\n        newRowIndex = Math.min(numRows, Math.max(rowIndex + vertical, 0));\n      }\n\n      if (horizontal !== 0) {\n        while (newColumnIndex <= maxColumnIndex && newColumnIndex >= minColumnIndex) {\n          newColumnIndex += horizontal;\n          if (focusableColumns[newColumnIndex]) {\n            break;\n          }\n        }\n      }\n\n      if ((rowIndex !== newRowIndex || columnIndex !== newColumnIndex) && tableRoot.current) {\n        focusCell(newRowIndex, newColumnIndex);\n      }\n    },\n    [focusCell, focusableColumns, maxColumnIndex, minColumnIndex, numRows, tableRoot]\n  );\n\n  const handleArrowKeyEvents = useCallback(\n    (event: KeyboardEvent) => {\n      const abort =\n        !!tableRoot.current?.querySelector('[data-inline-editing-active = \"true\"]') ||\n        !document.activeElement?.closest('[data-inline-editing-active]');\n\n      if (abort) {\n        return;\n      }\n      switch (event.key) {\n        case 'ArrowUp':\n          event.preventDefault();\n          shiftFocus(-1, 0);\n          break;\n        case 'ArrowDown':\n          event.preventDefault();\n          shiftFocus(1, 0);\n          break;\n        case 'ArrowLeft':\n          event.preventDefault();\n          shiftFocus(0, -1);\n          break;\n        case 'ArrowRight':\n          event.preventDefault();\n          shiftFocus(0, 1);\n          break;\n        // istanbul ignore next (default case = do nothing, not testable)\n        default:\n          return;\n      }\n    },\n    [shiftFocus, tableRoot]\n  );\n\n  useEffect(() => {\n    if (!tableRoot.current) {\n      return;\n    }\n\n    const tableElement = tableRoot.current;\n    tableRoot.current.addEventListener('keydown', handleArrowKeyEvents);\n\n    return () => tableElement && tableElement.removeEventListener('keydown', handleArrowKeyEvents);\n  }, [focusableColumns, handleArrowKeyEvents, tableRoot]);\n}\n\nexport default useTableFocusNavigation;\n"]},"metadata":{},"sourceType":"module"}