{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport React, { useRef, useState } from 'react';\nimport InternalAutosuggest from '../autosuggest/internal';\nimport { KeyCode } from '../internal/keycode';\nimport { makeCancellable, PromiseCancelledSignal } from '../internal/utils/promises';\nimport styles from './styles.css.js';\nexport const TagControl = React.forwardRef((_ref, ref) => {\n  let {\n    row,\n    value,\n    readOnly,\n    defaultOptions,\n    placeholder,\n    errorText,\n    loadingText,\n    suggestionText,\n    tooManySuggestionText,\n    limit,\n    filteringKey,\n    enteredTextLabel,\n    clearAriaLabel,\n    onChange,\n    onBlur,\n    onRequest,\n    initialOptionsRef\n  } = _ref;\n  const [options, setOptions] = useState(defaultOptions);\n  const [statusType, setStatusType] = useState();\n  const requestCancelFnRef = useRef({\n    cancel: () => {},\n    isCancelled: () => false\n  });\n  const latestFilteringQuery = useRef({\n    key: undefined,\n    value: undefined\n  });\n  const isSameQuery = (key, value) => latestFilteringQuery.current.key === key && latestFilteringQuery.current.value === value;\n  const onLoadItems = filteringText => {\n    if (!onRequest || isSameQuery(filteringKey, filteringText) || requestCancelFnRef.current.isCancelled()) {\n      return;\n    }\n    requestCancelFnRef.current.cancel();\n    if (latestFilteringQuery.current.key !== filteringKey) {\n      // Reset suggestions for values if the key is different.\n      setOptions([]);\n    } else if (filteringText === '' && (initialOptionsRef === null || initialOptionsRef === void 0 ? void 0 : initialOptionsRef.current) && initialOptionsRef.current.length > 0) {\n      // Load in the background, if the value is empty and we already have suggestions.\n      setOptions(initialOptionsRef.current);\n    }\n    setStatusType('loading');\n    latestFilteringQuery.current = {\n      key: filteringKey,\n      value: filteringText\n    };\n    const {\n      promise,\n      cancel,\n      isCancelled\n    } = makeCancellable(onRequest(filteringText));\n    promise.then(newValues => {\n      const newOptions = newValues.map(value => ({\n        value\n      }));\n      setStatusType(undefined);\n      setOptions(newOptions);\n      if (initialOptionsRef) {\n        initialOptionsRef.current = newOptions;\n      }\n    }).catch(err => {\n      if (!(err instanceof PromiseCancelledSignal)) {\n        setStatusType('error');\n      }\n    });\n    requestCancelFnRef.current = {\n      cancel,\n      isCancelled\n    };\n  };\n  return React.createElement(InternalAutosuggest, {\n    ref: ref,\n    value: value,\n    readOnly: readOnly,\n    statusType: statusType,\n    options: options.length < limit ? options : [],\n    empty: options.length < limit ? suggestionText : tooManySuggestionText,\n    placeholder: placeholder,\n    errorText: errorText,\n    loadingText: loadingText,\n    enteredTextLabel: enteredTextLabel,\n    clearAriaLabel: clearAriaLabel,\n    onChange: _ref2 => {\n      let {\n        detail\n      } = _ref2;\n      return onChange(detail.value, row);\n    },\n    onBlur: () => onBlur === null || onBlur === void 0 ? void 0 : onBlur(row),\n    onFocus: () => {\n      onLoadItems('');\n    },\n    onLoadItems: _ref3 => {\n      let {\n        detail\n      } = _ref3;\n      onLoadItems(detail.filteringText);\n    }\n  });\n});\nexport const UndoButton = React.forwardRef((_ref4, ref) => {\n  let {\n    children,\n    onClick\n  } = _ref4;\n  return React.createElement(\"a\", {\n    ref: ref,\n    role: \"button\",\n    tabIndex: 0,\n    className: styles['undo-button'],\n    onClick: onClick,\n    onKeyDown: event => {\n      if (event.keyCode === KeyCode.space || event.keyCode === KeyCode.enter) {\n        event.preventDefault();\n      }\n      // Enter activates the button on key down instead of key up.\n      if (event.keyCode === KeyCode.enter) {\n        onClick();\n      }\n    },\n    onKeyUp: event => {\n      // Emulate button behavior, which also fires on space.\n      if (event.keyCode === KeyCode.space) {\n        onClick();\n      }\n    }\n  }, children);\n});","map":{"version":3,"mappings":"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","names":["React","useRef","useState","InternalAutosuggest","KeyCode","makeCancellable","PromiseCancelledSignal","styles","TagControl","forwardRef","ref","row","value","readOnly","defaultOptions","placeholder","errorText","loadingText","suggestionText","tooManySuggestionText","limit","filteringKey","enteredTextLabel","clearAriaLabel","onChange","onBlur","onRequest","initialOptionsRef","options","setOptions","statusType","setStatusType","requestCancelFnRef","cancel","isCancelled","latestFilteringQuery","key","undefined","isSameQuery","current","onLoadItems","filteringText","length","promise","then","newValues","newOptions","map","catch","err","empty","detail","onFocus","UndoButton","children","onClick","role","tabIndex","className","onKeyDown","event","keyCode","space","enter","preventDefault","onKeyUp"],"sources":["/Users/tangyizhi/Desktop/Assignment2/frontend/node_modules/@cloudscape-design/components/tag-editor/lib/default/tag-editor/internal.tsx"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport React, { useRef, useState } from 'react';\n\nimport { AutosuggestProps } from '../autosuggest/interfaces';\nimport InternalAutosuggest from '../autosuggest/internal';\nimport { InputProps } from '../input/interfaces';\nimport { DropdownStatusProps } from '../internal/components/dropdown-status';\n\nimport { KeyCode } from '../internal/keycode';\nimport { makeCancellable, PromiseCancelledSignal } from '../internal/utils/promises';\n\nimport styles from './styles.css.js';\n\ninterface FilteringParams {\n  key?: string;\n  value?: string;\n}\nexport interface TagControlProps {\n  row: number;\n  value: string;\n  readOnly: boolean;\n  defaultOptions: AutosuggestProps.Options;\n  placeholder?: string;\n  errorText?: string;\n  loadingText?: string;\n  suggestionText?: string;\n  tooManySuggestionText?: string;\n  limit: number;\n  filteringKey?: string;\n  clearAriaLabel?: string;\n  enteredTextLabel?: (value: string) => string;\n  onChange: (value: string, row: number) => void;\n  onBlur?: (row: number) => void;\n  onRequest?: (value: string) => Promise<readonly string[]>;\n\n  initialOptionsRef?: React.MutableRefObject<AutosuggestProps.Options>;\n}\n\nexport const TagControl = React.forwardRef(\n  (\n    {\n      row,\n      value,\n      readOnly,\n      defaultOptions,\n      placeholder,\n      errorText,\n      loadingText,\n      suggestionText,\n      tooManySuggestionText,\n      limit,\n      filteringKey,\n      enteredTextLabel,\n      clearAriaLabel,\n      onChange,\n      onBlur,\n      onRequest,\n      initialOptionsRef,\n    }: TagControlProps,\n    ref: React.Ref<InputProps.Ref>\n  ) => {\n    const [options, setOptions] = useState<AutosuggestProps.Options>(defaultOptions);\n    const [statusType, setStatusType] = useState<DropdownStatusProps.StatusType>();\n    const requestCancelFnRef = useRef<{ cancel: () => void; isCancelled: () => boolean }>({\n      cancel: () => {},\n      isCancelled: () => false,\n    });\n\n    const latestFilteringQuery = useRef<FilteringParams>({ key: undefined, value: undefined });\n    const isSameQuery = (key: string | undefined, value: string) =>\n      latestFilteringQuery.current.key === key && latestFilteringQuery.current.value === value;\n\n    const onLoadItems = (filteringText: string) => {\n      if (!onRequest || isSameQuery(filteringKey, filteringText) || requestCancelFnRef.current.isCancelled()) {\n        return;\n      }\n      requestCancelFnRef.current.cancel();\n\n      if (latestFilteringQuery.current.key !== filteringKey) {\n        // Reset suggestions for values if the key is different.\n        setOptions([]);\n      } else if (filteringText === '' && initialOptionsRef?.current && initialOptionsRef.current.length > 0) {\n        // Load in the background, if the value is empty and we already have suggestions.\n        setOptions(initialOptionsRef.current);\n      }\n\n      setStatusType('loading');\n      latestFilteringQuery.current = { key: filteringKey, value: filteringText };\n\n      const { promise, cancel, isCancelled } = makeCancellable(onRequest(filteringText));\n      promise\n        .then(newValues => {\n          const newOptions = newValues.map(value => ({ value }));\n          setStatusType(undefined);\n          setOptions(newOptions);\n          if (initialOptionsRef) {\n            initialOptionsRef.current = newOptions;\n          }\n        })\n        .catch(err => {\n          if (!(err instanceof PromiseCancelledSignal)) {\n            setStatusType('error');\n          }\n        });\n      requestCancelFnRef.current = { cancel, isCancelled };\n    };\n\n    return (\n      <InternalAutosuggest\n        ref={ref}\n        value={value}\n        readOnly={readOnly}\n        statusType={statusType}\n        options={options.length < limit ? options : []}\n        empty={options.length < limit ? suggestionText : tooManySuggestionText}\n        placeholder={placeholder}\n        errorText={errorText}\n        loadingText={loadingText}\n        enteredTextLabel={enteredTextLabel}\n        clearAriaLabel={clearAriaLabel}\n        onChange={({ detail }) => onChange(detail.value, row)}\n        onBlur={() => onBlur?.(row)}\n        onFocus={() => {\n          onLoadItems('');\n        }}\n        onLoadItems={({ detail }) => {\n          onLoadItems(detail.filteringText);\n        }}\n      />\n    );\n  }\n);\n\nexport interface UndoButtonProps {\n  children: React.ReactNode;\n  onClick: () => void;\n}\n\nexport const UndoButton = React.forwardRef(\n  ({ children, onClick }: UndoButtonProps, ref: React.Ref<HTMLAnchorElement>) => {\n    return (\n      <a\n        ref={ref}\n        role=\"button\"\n        tabIndex={0}\n        className={styles['undo-button']}\n        onClick={onClick}\n        onKeyDown={event => {\n          if (event.keyCode === KeyCode.space || event.keyCode === KeyCode.enter) {\n            event.preventDefault();\n          }\n          // Enter activates the button on key down instead of key up.\n          if (event.keyCode === KeyCode.enter) {\n            onClick();\n          }\n        }}\n        onKeyUp={event => {\n          // Emulate button behavior, which also fires on space.\n          if (event.keyCode === KeyCode.space) {\n            onClick();\n          }\n        }}\n      >\n        {children}\n      </a>\n    );\n  }\n);\n"]},"metadata":{},"sourceType":"module"}