{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { useReducer } from \"react\";\nimport { LayoutEngine } from \"../internal/layout-engine/engine\";\nimport { Coordinates } from \"../internal/utils/coordinates\";\nimport { getDefaultColumnSpan, getDefaultRowSpan, getMinColumnSpan, getMinRowSpan } from \"../internal/utils/layout\";\nimport { Position } from \"../internal/utils/position\";\nimport { createOperationAnnouncement } from \"./utils/announcements\";\nimport { getHoveredRect } from \"./utils/get-hovered-rect\";\nimport { getInsertionDirection, getLayoutPlaceholders, getLayoutRows, getLayoutShift } from \"./utils/layout\";\nimport { appendMovePath, appendResizePath } from \"./utils/path\";\nexport function useTransition() {\n  return useReducer(transitionReducer, {\n    transition: null,\n    removeTransition: null,\n    announcement: null\n  });\n}\nexport function selectTransitionRows(state) {\n  return state.transition ? getLayoutRows(state.transition) : 0;\n}\nfunction transitionReducer(state, action) {\n  switch (action.type) {\n    case \"init\":\n      return initTransition(action);\n    case \"init-remove\":\n      return initRemoveTransition(action);\n    case \"submit\":\n      return submitTransition(state);\n    case \"discard\":\n      return discardTransition(state);\n    case \"update-with-pointer\":\n      return updateTransitionWithPointerEvent(state, action);\n    case \"update-with-keyboard\":\n      return updateTransitionWithKeyboardEvent(state, action);\n    case \"acquire-item\":\n      return acquireTransitionItem(state, action);\n  }\n}\nfunction initTransition(_ref) {\n  let {\n    operation,\n    interactionType,\n    itemsLayout,\n    draggableItem,\n    draggableRect,\n    collisionIds\n  } = _ref;\n  const transition = {\n    operation,\n    interactionType,\n    itemsLayout,\n    layoutEngine: new LayoutEngine(itemsLayout),\n    insertionDirection: null,\n    draggableItem,\n    draggableRect,\n    acquiredItem: null,\n    collisionIds: new Set(),\n    layoutShift: null,\n    path: []\n  };\n  const placeholdersLayout = getLayoutPlaceholders(transition);\n  const layoutItem = itemsLayout.items.find(it => it.id === draggableItem.id);\n  let path = [];\n  if (interactionType === \"pointer\" || operation === \"insert\") {\n    const collisionRect = getHoveredRect(collisionIds, placeholdersLayout.items);\n    const appendPath = operation === \"resize\" ? appendResizePath : appendMovePath;\n    path = layoutItem ? appendPath([], collisionRect) : [];\n  } else if (layoutItem) {\n    path = operation === \"resize\" ? [new Position({\n      x: layoutItem.x + layoutItem.width,\n      y: layoutItem.y + layoutItem.height\n    })] : [new Position({\n      x: layoutItem.x,\n      y: layoutItem.y\n    })];\n  }\n  return {\n    transition: {\n      ...transition,\n      path\n    },\n    removeTransition: null,\n    announcement: layoutItem ? {\n      type: \"dnd-started\",\n      item: draggableItem,\n      operation\n    } : null\n  };\n}\nfunction initRemoveTransition(_ref2) {\n  let {\n    items,\n    removedItem,\n    itemsLayout\n  } = _ref2;\n  const layoutShift = new LayoutEngine(itemsLayout).remove(removedItem.id);\n  const removeTransition = {\n    items,\n    removedItem,\n    layoutShift\n  };\n  return {\n    transition: null,\n    removeTransition,\n    announcement: null\n  };\n}\nfunction submitTransition(state) {\n  var _a;\n  const {\n    transition,\n    removeTransition\n  } = state;\n  if (removeTransition) {\n    const disturbed = new Set(removeTransition.layoutShift.moves.map(move => move.itemId));\n    disturbed.delete(removeTransition.removedItem.id);\n    return {\n      transition: null,\n      removeTransition: null,\n      announcement: {\n        type: \"item-removed\",\n        item: removeTransition.removedItem,\n        disturbed\n      }\n    };\n  }\n  if (!transition) {\n    throw new Error(\"Invariant violation: no transition.\");\n  }\n  const {\n    operation,\n    itemsLayout,\n    draggableItem: item,\n    acquiredItem\n  } = transition;\n  const itemBelongsToBoard = item.id === (acquiredItem === null || acquiredItem === void 0 ? void 0 : acquiredItem.id) || itemsLayout.items.some(it => it.id === item.id);\n  return ((_a = transition.layoutShift) === null || _a === void 0 ? void 0 : _a.conflicts.length) === 0 ? {\n    transition: null,\n    removeTransition: null,\n    announcement: itemBelongsToBoard ? {\n      type: \"dnd-committed\",\n      item,\n      operation\n    } : null\n  } : {\n    transition: null,\n    removeTransition: null,\n    announcement: itemBelongsToBoard ? {\n      type: \"dnd-discarded\",\n      item,\n      operation\n    } : null\n  };\n}\nfunction discardTransition(state) {\n  const {\n    transition,\n    removeTransition\n  } = state;\n  if (removeTransition) {\n    throw new Error(\"Can't discard remove transition.\");\n  }\n  if (!transition) {\n    throw new Error(\"Invariant violation: no transition.\");\n  }\n  const {\n    operation,\n    itemsLayout,\n    draggableItem: item,\n    acquiredItem\n  } = transition;\n  const itemBelongsToBoard = item.id === (acquiredItem === null || acquiredItem === void 0 ? void 0 : acquiredItem.id) || itemsLayout.items.some(it => it.id === item.id);\n  return {\n    transition: null,\n    removeTransition: null,\n    announcement: itemBelongsToBoard ? {\n      type: \"dnd-discarded\",\n      item,\n      operation\n    } : null\n  };\n}\nfunction updateTransitionWithPointerEvent(state, _ref3) {\n  let {\n    collisionIds,\n    positionOffset,\n    draggableRect\n  } = _ref3;\n  var _a, _b, _c;\n  const {\n    transition\n  } = state;\n  if (!transition) {\n    throw new Error(\"Invariant violation: no transition.\");\n  }\n  const layout = (_b = (_a = transition.layoutShift) === null || _a === void 0 ? void 0 : _a.next) !== null && _b !== void 0 ? _b : transition.itemsLayout;\n  const layoutItem = layout.items.find(it => it.id === transition.draggableItem.id);\n  const itemWidth = layoutItem ? layoutItem.width : getDefaultColumnSpan(transition.draggableItem, layout.columns);\n  const itemHeight = layoutItem ? layoutItem.height : getDefaultRowSpan(transition.draggableItem);\n  const itemSize = itemWidth * itemHeight;\n  const isOutOfBoundaries = transition.operation !== \"resize\" ? collisionIds.length < itemSize : collisionIds.length === 0;\n  if (isOutOfBoundaries) {\n    return {\n      transition: {\n        ...transition,\n        draggableRect,\n        collisionIds: new Set(),\n        layoutShift: null,\n        insertionDirection: null\n      },\n      removeTransition: null,\n      announcement: null\n    };\n  }\n  const placeholdersLayout = getLayoutPlaceholders(transition);\n  const collisionRect = getHoveredRect(collisionIds, placeholdersLayout.items);\n  const appendPath = transition.operation === \"resize\" ? appendResizePath : appendMovePath;\n  const path = appendPath(transition.path, collisionRect);\n  const insertionDirection = (_c = transition.insertionDirection) !== null && _c !== void 0 ? _c : getInsertionDirection(positionOffset);\n  const layoutShift = getLayoutShift(transition, path, insertionDirection);\n  return {\n    transition: {\n      ...transition,\n      draggableRect,\n      collisionIds: new Set(collisionIds),\n      layoutShift,\n      path,\n      insertionDirection\n    },\n    removeTransition: null,\n    announcement: null\n  };\n}\nfunction updateTransitionWithKeyboardEvent(state, _ref4) {\n  let {\n    direction\n  } = _ref4;\n  const {\n    transition\n  } = state;\n  if (!transition) {\n    throw new Error(\"Invariant violation: no transition.\");\n  }\n  const updateManualItemTransition = (transition, direction) => {\n    var _a, _b;\n    const xDelta = direction === \"left\" ? -1 : direction === \"right\" ? 1 : 0;\n    const yDelta = direction === \"up\" ? -1 : direction === \"down\" ? 1 : 0;\n    const lastPosition = transition.path[transition.path.length - 1];\n    const nextPosition = new Position({\n      x: lastPosition.x + xDelta,\n      y: lastPosition.y + yDelta\n    });\n    const nextPath = [...transition.path, nextPosition];\n    // Check resizing below min size.\n    const layout = (_b = (_a = transition.layoutShift) === null || _a === void 0 ? void 0 : _a.next) !== null && _b !== void 0 ? _b : transition.itemsLayout;\n    const layoutItem = layout.items.find(it => it.id === transition.draggableItem.id);\n    const minWidth = getMinColumnSpan(transition.draggableItem, transition.itemsLayout.columns);\n    const minHeight = getMinRowSpan(transition.draggableItem);\n    if (transition.operation === \"resize\" && layoutItem && (layoutItem.width + xDelta < minWidth || layoutItem.height + yDelta < minHeight)) {\n      return state;\n    }\n    try {\n      const layoutShift = getLayoutShift(transition, nextPath);\n      const nextTransition = {\n        ...transition,\n        layoutShift,\n        path: nextPath\n      };\n      return {\n        transition: nextTransition,\n        removeTransition: null,\n        announcement: createOperationAnnouncement(nextTransition, direction)\n      };\n    } catch (e) {\n      // Can't create next layout because the next path is out of bounds.\n      return state;\n    }\n  };\n  switch (direction) {\n    case \"left\":\n      return updateManualItemTransition(transition, \"left\");\n    case \"right\":\n      return updateManualItemTransition(transition, \"right\");\n    case \"up\":\n      return updateManualItemTransition(transition, \"up\");\n    case \"down\":\n      return updateManualItemTransition(transition, \"down\");\n  }\n}\nfunction acquireTransitionItem(state, _ref5) {\n  let {\n    position,\n    layoutElement,\n    acquiredItemElement\n  } = _ref5;\n  const {\n    transition\n  } = state;\n  if (!transition) {\n    throw new Error(\"Invariant violation: no transition.\");\n  }\n  const {\n    columns\n  } = transition.itemsLayout;\n  const layoutRect = layoutElement.getBoundingClientRect();\n  const itemRect = transition.draggableRect;\n  const offset = new Coordinates({\n    x: itemRect.left - layoutRect.x,\n    y: itemRect.top - layoutRect.y\n  });\n  const insertionDirection = getInsertionDirection(offset);\n  // Update original insertion position if the item can't fit into the layout by width.\n  const width = getDefaultColumnSpan(transition.draggableItem, columns);\n  position = new Position({\n    x: Math.min(columns - width, position.x),\n    y: position.y\n  });\n  const path = [...transition.path, position];\n  const layoutShift = getLayoutShift(transition, path, insertionDirection);\n  // The columnOffset, columnSpan and rowSpan are of no use as of being overridden by the layout shift.\n  const acquiredItem = {\n    ...transition.draggableItem,\n    columnOffset: 0,\n    columnSpan: 1,\n    rowSpan: 1\n  };\n  const nextTransition = {\n    ...transition,\n    collisionIds: new Set(),\n    layoutShift,\n    path,\n    acquiredItem,\n    acquiredItemElement\n  };\n  return {\n    transition: nextTransition,\n    removeTransition: null,\n    announcement: createOperationAnnouncement(nextTransition, null)\n  };\n}","map":{"version":3,"names":["useReducer","LayoutEngine","Coordinates","getDefaultColumnSpan","getDefaultRowSpan","getMinColumnSpan","getMinRowSpan","Position","createOperationAnnouncement","getHoveredRect","getInsertionDirection","getLayoutPlaceholders","getLayoutRows","getLayoutShift","appendMovePath","appendResizePath","useTransition","transitionReducer","transition","removeTransition","announcement","selectTransitionRows","state","action","type","initTransition","initRemoveTransition","submitTransition","discardTransition","updateTransitionWithPointerEvent","updateTransitionWithKeyboardEvent","acquireTransitionItem","operation","interactionType","itemsLayout","draggableItem","draggableRect","collisionIds","layoutEngine","insertionDirection","acquiredItem","Set","layoutShift","path","placeholdersLayout","layoutItem","items","find","it","id","collisionRect","appendPath","x","width","y","height","item","removedItem","remove","_a","disturbed","moves","map","move","itemId","delete","Error","itemBelongsToBoard","some","conflicts","length","positionOffset","_b","_c","layout","next","itemWidth","columns","itemHeight","itemSize","isOutOfBoundaries","direction","updateManualItemTransition","xDelta","yDelta","lastPosition","nextPosition","nextPath","minWidth","minHeight","nextTransition","e","position","layoutElement","acquiredItemElement","layoutRect","getBoundingClientRect","itemRect","offset","left","top","Math","min","columnOffset","columnSpan","rowSpan"],"sources":["/Users/tangyizhi/Desktop/Assignment 2/frontend/node_modules/@cloudscape-design/board-components/board/transition.js"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { useReducer } from \"react\";\nimport { LayoutEngine } from \"../internal/layout-engine/engine\";\nimport { Coordinates } from \"../internal/utils/coordinates\";\nimport { getDefaultColumnSpan, getDefaultRowSpan, getMinColumnSpan, getMinRowSpan } from \"../internal/utils/layout\";\nimport { Position } from \"../internal/utils/position\";\nimport { createOperationAnnouncement } from \"./utils/announcements\";\nimport { getHoveredRect } from \"./utils/get-hovered-rect\";\nimport { getInsertionDirection, getLayoutPlaceholders, getLayoutRows, getLayoutShift } from \"./utils/layout\";\nimport { appendMovePath, appendResizePath } from \"./utils/path\";\nexport function useTransition() {\n    return useReducer((transitionReducer), { transition: null, removeTransition: null, announcement: null });\n}\nexport function selectTransitionRows(state) {\n    return state.transition ? getLayoutRows(state.transition) : 0;\n}\nfunction transitionReducer(state, action) {\n    switch (action.type) {\n        case \"init\":\n            return initTransition(action);\n        case \"init-remove\":\n            return initRemoveTransition(action);\n        case \"submit\":\n            return submitTransition(state);\n        case \"discard\":\n            return discardTransition(state);\n        case \"update-with-pointer\":\n            return updateTransitionWithPointerEvent(state, action);\n        case \"update-with-keyboard\":\n            return updateTransitionWithKeyboardEvent(state, action);\n        case \"acquire-item\":\n            return acquireTransitionItem(state, action);\n    }\n}\nfunction initTransition({ operation, interactionType, itemsLayout, draggableItem, draggableRect, collisionIds, }) {\n    const transition = {\n        operation,\n        interactionType,\n        itemsLayout,\n        layoutEngine: new LayoutEngine(itemsLayout),\n        insertionDirection: null,\n        draggableItem,\n        draggableRect,\n        acquiredItem: null,\n        collisionIds: new Set(),\n        layoutShift: null,\n        path: [],\n    };\n    const placeholdersLayout = getLayoutPlaceholders(transition);\n    const layoutItem = itemsLayout.items.find((it) => it.id === draggableItem.id);\n    let path = [];\n    if (interactionType === \"pointer\" || operation === \"insert\") {\n        const collisionRect = getHoveredRect(collisionIds, placeholdersLayout.items);\n        const appendPath = operation === \"resize\" ? appendResizePath : appendMovePath;\n        path = layoutItem ? appendPath([], collisionRect) : [];\n    }\n    else if (layoutItem) {\n        path =\n            operation === \"resize\"\n                ? [new Position({ x: layoutItem.x + layoutItem.width, y: layoutItem.y + layoutItem.height })]\n                : [new Position({ x: layoutItem.x, y: layoutItem.y })];\n    }\n    return {\n        transition: { ...transition, path },\n        removeTransition: null,\n        announcement: layoutItem ? { type: \"dnd-started\", item: draggableItem, operation } : null,\n    };\n}\nfunction initRemoveTransition({ items, removedItem, itemsLayout }) {\n    const layoutShift = new LayoutEngine(itemsLayout).remove(removedItem.id);\n    const removeTransition = { items, removedItem, layoutShift };\n    return { transition: null, removeTransition, announcement: null };\n}\nfunction submitTransition(state) {\n    var _a;\n    const { transition, removeTransition } = state;\n    if (removeTransition) {\n        const disturbed = new Set(removeTransition.layoutShift.moves.map((move) => move.itemId));\n        disturbed.delete(removeTransition.removedItem.id);\n        return {\n            transition: null,\n            removeTransition: null,\n            announcement: { type: \"item-removed\", item: removeTransition.removedItem, disturbed },\n        };\n    }\n    if (!transition) {\n        throw new Error(\"Invariant violation: no transition.\");\n    }\n    const { operation, itemsLayout, draggableItem: item, acquiredItem } = transition;\n    const itemBelongsToBoard = item.id === (acquiredItem === null || acquiredItem === void 0 ? void 0 : acquiredItem.id) || itemsLayout.items.some((it) => it.id === item.id);\n    return ((_a = transition.layoutShift) === null || _a === void 0 ? void 0 : _a.conflicts.length) === 0\n        ? {\n            transition: null,\n            removeTransition: null,\n            announcement: itemBelongsToBoard ? { type: \"dnd-committed\", item, operation } : null,\n        }\n        : {\n            transition: null,\n            removeTransition: null,\n            announcement: itemBelongsToBoard ? { type: \"dnd-discarded\", item, operation } : null,\n        };\n}\nfunction discardTransition(state) {\n    const { transition, removeTransition } = state;\n    if (removeTransition) {\n        throw new Error(\"Can't discard remove transition.\");\n    }\n    if (!transition) {\n        throw new Error(\"Invariant violation: no transition.\");\n    }\n    const { operation, itemsLayout, draggableItem: item, acquiredItem } = transition;\n    const itemBelongsToBoard = item.id === (acquiredItem === null || acquiredItem === void 0 ? void 0 : acquiredItem.id) || itemsLayout.items.some((it) => it.id === item.id);\n    return {\n        transition: null,\n        removeTransition: null,\n        announcement: itemBelongsToBoard ? { type: \"dnd-discarded\", item, operation } : null,\n    };\n}\nfunction updateTransitionWithPointerEvent(state, { collisionIds, positionOffset, draggableRect }) {\n    var _a, _b, _c;\n    const { transition } = state;\n    if (!transition) {\n        throw new Error(\"Invariant violation: no transition.\");\n    }\n    const layout = (_b = (_a = transition.layoutShift) === null || _a === void 0 ? void 0 : _a.next) !== null && _b !== void 0 ? _b : transition.itemsLayout;\n    const layoutItem = layout.items.find((it) => it.id === transition.draggableItem.id);\n    const itemWidth = layoutItem ? layoutItem.width : getDefaultColumnSpan(transition.draggableItem, layout.columns);\n    const itemHeight = layoutItem ? layoutItem.height : getDefaultRowSpan(transition.draggableItem);\n    const itemSize = itemWidth * itemHeight;\n    const isOutOfBoundaries = transition.operation !== \"resize\" ? collisionIds.length < itemSize : collisionIds.length === 0;\n    if (isOutOfBoundaries) {\n        return {\n            transition: {\n                ...transition,\n                draggableRect,\n                collisionIds: new Set(),\n                layoutShift: null,\n                insertionDirection: null,\n            },\n            removeTransition: null,\n            announcement: null,\n        };\n    }\n    const placeholdersLayout = getLayoutPlaceholders(transition);\n    const collisionRect = getHoveredRect(collisionIds, placeholdersLayout.items);\n    const appendPath = transition.operation === \"resize\" ? appendResizePath : appendMovePath;\n    const path = appendPath(transition.path, collisionRect);\n    const insertionDirection = (_c = transition.insertionDirection) !== null && _c !== void 0 ? _c : getInsertionDirection(positionOffset);\n    const layoutShift = getLayoutShift(transition, path, insertionDirection);\n    return {\n        transition: {\n            ...transition,\n            draggableRect,\n            collisionIds: new Set(collisionIds),\n            layoutShift,\n            path,\n            insertionDirection,\n        },\n        removeTransition: null,\n        announcement: null,\n    };\n}\nfunction updateTransitionWithKeyboardEvent(state, { direction }) {\n    const { transition } = state;\n    if (!transition) {\n        throw new Error(\"Invariant violation: no transition.\");\n    }\n    const updateManualItemTransition = (transition, direction) => {\n        var _a, _b;\n        const xDelta = direction === \"left\" ? -1 : direction === \"right\" ? 1 : 0;\n        const yDelta = direction === \"up\" ? -1 : direction === \"down\" ? 1 : 0;\n        const lastPosition = transition.path[transition.path.length - 1];\n        const nextPosition = new Position({ x: lastPosition.x + xDelta, y: lastPosition.y + yDelta });\n        const nextPath = [...transition.path, nextPosition];\n        // Check resizing below min size.\n        const layout = (_b = (_a = transition.layoutShift) === null || _a === void 0 ? void 0 : _a.next) !== null && _b !== void 0 ? _b : transition.itemsLayout;\n        const layoutItem = layout.items.find((it) => it.id === transition.draggableItem.id);\n        const minWidth = getMinColumnSpan(transition.draggableItem, transition.itemsLayout.columns);\n        const minHeight = getMinRowSpan(transition.draggableItem);\n        if (transition.operation === \"resize\" &&\n            layoutItem &&\n            (layoutItem.width + xDelta < minWidth || layoutItem.height + yDelta < minHeight)) {\n            return state;\n        }\n        try {\n            const layoutShift = getLayoutShift(transition, nextPath);\n            const nextTransition = { ...transition, layoutShift, path: nextPath };\n            return {\n                transition: nextTransition,\n                removeTransition: null,\n                announcement: createOperationAnnouncement(nextTransition, direction),\n            };\n        }\n        catch (e) {\n            // Can't create next layout because the next path is out of bounds.\n            return state;\n        }\n    };\n    switch (direction) {\n        case \"left\":\n            return updateManualItemTransition(transition, \"left\");\n        case \"right\":\n            return updateManualItemTransition(transition, \"right\");\n        case \"up\":\n            return updateManualItemTransition(transition, \"up\");\n        case \"down\":\n            return updateManualItemTransition(transition, \"down\");\n    }\n}\nfunction acquireTransitionItem(state, { position, layoutElement, acquiredItemElement }) {\n    const { transition } = state;\n    if (!transition) {\n        throw new Error(\"Invariant violation: no transition.\");\n    }\n    const { columns } = transition.itemsLayout;\n    const layoutRect = layoutElement.getBoundingClientRect();\n    const itemRect = transition.draggableRect;\n    const offset = new Coordinates({ x: itemRect.left - layoutRect.x, y: itemRect.top - layoutRect.y });\n    const insertionDirection = getInsertionDirection(offset);\n    // Update original insertion position if the item can't fit into the layout by width.\n    const width = getDefaultColumnSpan(transition.draggableItem, columns);\n    position = new Position({ x: Math.min(columns - width, position.x), y: position.y });\n    const path = [...transition.path, position];\n    const layoutShift = getLayoutShift(transition, path, insertionDirection);\n    // The columnOffset, columnSpan and rowSpan are of no use as of being overridden by the layout shift.\n    const acquiredItem = { ...transition.draggableItem, columnOffset: 0, columnSpan: 1, rowSpan: 1 };\n    const nextTransition = {\n        ...transition,\n        collisionIds: new Set(),\n        layoutShift,\n        path,\n        acquiredItem,\n        acquiredItemElement,\n    };\n    return {\n        transition: nextTransition,\n        removeTransition: null,\n        announcement: createOperationAnnouncement(nextTransition, null),\n    };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}