{"ast":null,"code":"import { isXThreshold, isYThreshold } from './utils';\n/** Combine all line series into an array of scaled data points with the given scales. */\nexport default function makeScaledSeries(allSeries, xScale, yScale) {\n  const xOffset = xScale.isCategorical() ? Math.max(0, xScale.d3Scale.bandwidth() - 1) / 2 : 0;\n  const scaleX = x => (xScale.d3Scale(x) || 0) + xOffset;\n  const scaleY = y => yScale.d3Scale(y) || 0;\n  const allX = getAllX(allSeries);\n  function mergeLineSeriesPointsWithXThresholds(scaledPoints, xThresholdSeries, xThresholdSeriesColor) {\n    var _a, _b;\n    const x = scaleX(xThresholdSeries.x);\n    // Locate a point the x-threshold can be inserted after (if such exists).\n    let bisectIndex = -1;\n    for (let i = 0; i < scaledPoints.length - 1; i++) {\n      if (scaledPoints[i].x < x && x < scaledPoints[i + 1].x) {\n        bisectIndex = i;\n        break;\n      }\n    }\n    // Insert x-threshold point into the given series using extrapolated Y value.\n    // The extrapolated value is only used to render highlighted point on the chart plot.\n    if (bisectIndex !== -1) {\n      const prevY = ((_a = scaledPoints[bisectIndex].datum) === null || _a === void 0 ? void 0 : _a.y) || 0;\n      const nextY = ((_b = scaledPoints[bisectIndex + 1].datum) === null || _b === void 0 ? void 0 : _b.y) || 0;\n      const averageY = (prevY + nextY) / 2;\n      scaledPoints.push({\n        x: x,\n        y: scaleY(averageY),\n        datum: {\n          x: xThresholdSeries.x,\n          y: NaN\n        },\n        series: scaledPoints[bisectIndex].series,\n        color: xThresholdSeriesColor\n      });\n    }\n  }\n  const scaledSeriesX = allSeries.map(_ref => {\n    let {\n      series,\n      color\n    } = _ref;\n    const scaledPoints = [];\n    // Scale and add all line series data points.\n    if (series.type === 'line') {\n      for (const datum of series.data) {\n        scaledPoints.push({\n          x: scaleX(datum.x),\n          y: scaleY(datum.y),\n          datum,\n          series,\n          color\n        });\n      }\n      // Sort scaled points to ensure correct x-thresholds insertion.\n      scaledPoints.sort((s1, s2) => s1.x - s2.x);\n      // Merge x-thresholds into series if they don't have a shared coordinate.\n      for (const otherSeries of allSeries) {\n        if (isXThreshold(otherSeries.series)) {\n          mergeLineSeriesPointsWithXThresholds(scaledPoints, otherSeries.series, otherSeries.color);\n        }\n      }\n    }\n    // Y-thresholds only have Y. To make thresholds navigable they are mapped to all defined X values.\n    else if (isYThreshold(series)) {\n      for (const x of allX) {\n        scaledPoints.push({\n          x: scaleX(x),\n          y: scaleY(series.y),\n          datum: {\n            x,\n            y: series.y\n          },\n          series,\n          color\n        });\n      }\n      // Support threshold-only setup.\n      if (allX.length === 0) {\n        scaledPoints.push({\n          x: NaN,\n          y: scaleY(series.y),\n          series,\n          color\n        });\n      }\n    }\n    // X-thresholds only have X. The y value is taken as NaN which means there is no associated point - only vertical marker.\n    else if (isXThreshold(series)) {\n      scaledPoints.push({\n        x: scaleX(series.x),\n        y: NaN,\n        datum: {\n          x: series.x,\n          y: NaN\n        },\n        series,\n        color\n      });\n    }\n    // Bar series are handled separately.\n    return scaledPoints;\n  });\n  // Sort scaled points by x to ensure their order matches visual order in the chart to support navigation.\n  return flatten(scaledSeriesX).sort((s1, s2) => s1.x - s2.x);\n}\n/** Collect unique x values from all data series. */\nfunction getAllX(series) {\n  const addDataXSet = new Set();\n  for (const {\n    series: s\n  } of series) {\n    switch (s.type) {\n      // Add all X values from data series.\n      case 'bar':\n      case 'line':\n        for (const d of s.data) {\n          addDataXSet.add(d.x);\n        }\n        break;\n      case 'threshold':\n        // X-thresholds have a single X value.\n        if (isXThreshold(s)) {\n          addDataXSet.add(s.x);\n        }\n        // Thresholds don't have X values.\n        break;\n    }\n  }\n  const allDataX = [];\n  addDataXSet.forEach(x => allDataX.push(x));\n  return allDataX;\n}\nfunction flatten(arrays) {\n  const merged = [];\n  for (const array of arrays) {\n    for (const item of array) {\n      merged.push(item);\n    }\n  }\n  return merged;\n}","map":{"version":3,"mappings":"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","names":["isXThreshold","isYThreshold","makeScaledSeries","allSeries","xScale","yScale","xOffset","isCategorical","Math","max","d3Scale","bandwidth","scaleX","x","scaleY","y","allX","getAllX","mergeLineSeriesPointsWithXThresholds","scaledPoints","xThresholdSeries","xThresholdSeriesColor","bisectIndex","i","length","prevY","datum","nextY","averageY","push","NaN","series","color","scaledSeriesX","map","type","data","sort","s1","s2","otherSeries","flatten","addDataXSet","Set","s","d","add","allDataX","forEach","arrays","merged","array","item"],"sources":["/Users/tangyizhi/Desktop/Assignment 2/frontend/node_modules/@cloudscape-design/components/mixed-line-bar-chart/lib/default/mixed-line-bar-chart/make-scaled-series.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { ChartDataTypes, InternalChartSeries, MixedLineBarChartProps } from './interfaces';\nimport { ChartScale, NumericChartScale } from '../internal/components/cartesian-chart/scales';\nimport { isXThreshold, isYThreshold } from './utils';\n\nexport interface ScaledPoint<T> {\n  x: number;\n  y: number;\n  color: string;\n  datum?: MixedLineBarChartProps.Datum<T> | undefined;\n  series: MixedLineBarChartProps.ChartSeries<T>;\n}\n\n/** Combine all line series into an array of scaled data points with the given scales. */\nexport default function makeScaledSeries<T extends ChartDataTypes>(\n  allSeries: ReadonlyArray<InternalChartSeries<T>>,\n  xScale: ChartScale,\n  yScale: NumericChartScale\n): readonly ScaledPoint<T>[] {\n  const xOffset = xScale.isCategorical() ? Math.max(0, xScale.d3Scale.bandwidth() - 1) / 2 : 0;\n  const scaleX = (x: T) => (xScale.d3Scale(x as any) || 0) + xOffset;\n  const scaleY = (y: number) => yScale.d3Scale(y) || 0;\n  const allX = getAllX(allSeries);\n\n  function mergeLineSeriesPointsWithXThresholds(\n    scaledPoints: ScaledPoint<T>[],\n    xThresholdSeries: MixedLineBarChartProps.ThresholdSeries<T> & { x: T },\n    xThresholdSeriesColor: string\n  ) {\n    const x = scaleX(xThresholdSeries.x);\n\n    // Locate a point the x-threshold can be inserted after (if such exists).\n    let bisectIndex = -1;\n    for (let i = 0; i < scaledPoints.length - 1; i++) {\n      if (scaledPoints[i].x < x && x < scaledPoints[i + 1].x) {\n        bisectIndex = i;\n        break;\n      }\n    }\n\n    // Insert x-threshold point into the given series using extrapolated Y value.\n    // The extrapolated value is only used to render highlighted point on the chart plot.\n    if (bisectIndex !== -1) {\n      const prevY = scaledPoints[bisectIndex].datum?.y || 0;\n      const nextY = scaledPoints[bisectIndex + 1].datum?.y || 0;\n      const averageY = (prevY + nextY) / 2;\n      scaledPoints.push({\n        x: x,\n        y: scaleY(averageY),\n        datum: { x: xThresholdSeries.x, y: NaN },\n        series: scaledPoints[bisectIndex].series,\n        color: xThresholdSeriesColor,\n      });\n    }\n  }\n\n  const scaledSeriesX = allSeries.map(({ series, color }) => {\n    const scaledPoints: ScaledPoint<T>[] = [];\n\n    // Scale and add all line series data points.\n    if (series.type === 'line') {\n      for (const datum of series.data as MixedLineBarChartProps.Datum<T>[]) {\n        scaledPoints.push({ x: scaleX(datum.x), y: scaleY(datum.y), datum, series, color });\n      }\n\n      // Sort scaled points to ensure correct x-thresholds insertion.\n      scaledPoints.sort((s1, s2) => s1.x - s2.x);\n\n      // Merge x-thresholds into series if they don't have a shared coordinate.\n      for (const otherSeries of allSeries) {\n        if (isXThreshold(otherSeries.series)) {\n          mergeLineSeriesPointsWithXThresholds(scaledPoints, otherSeries.series, otherSeries.color);\n        }\n      }\n    }\n    // Y-thresholds only have Y. To make thresholds navigable they are mapped to all defined X values.\n    else if (isYThreshold(series)) {\n      for (const x of allX) {\n        scaledPoints.push({ x: scaleX(x), y: scaleY(series.y), datum: { x, y: series.y }, series, color });\n      }\n      // Support threshold-only setup.\n      if (allX.length === 0) {\n        scaledPoints.push({ x: NaN, y: scaleY(series.y), series, color });\n      }\n    }\n    // X-thresholds only have X. The y value is taken as NaN which means there is no associated point - only vertical marker.\n    else if (isXThreshold(series)) {\n      scaledPoints.push({ x: scaleX(series.x), y: NaN, datum: { x: series.x, y: NaN }, series, color });\n    }\n    // Bar series are handled separately.\n    return scaledPoints;\n  });\n\n  // Sort scaled points by x to ensure their order matches visual order in the chart to support navigation.\n  return flatten(scaledSeriesX).sort((s1, s2) => s1.x - s2.x);\n}\n\n/** Collect unique x values from all data series. */\nfunction getAllX<T>(series: ReadonlyArray<InternalChartSeries<T>>) {\n  const addDataXSet = new Set<T>();\n  for (const { series: s } of series) {\n    switch (s.type) {\n      // Add all X values from data series.\n      case 'bar':\n      case 'line':\n        for (const d of s.data) {\n          addDataXSet.add(d.x);\n        }\n        break;\n\n      case 'threshold':\n        // X-thresholds have a single X value.\n        if (isXThreshold(s)) {\n          addDataXSet.add(s.x);\n        }\n        // Thresholds don't have X values.\n        break;\n    }\n  }\n  const allDataX: T[] = [];\n  addDataXSet.forEach(x => allDataX.push(x));\n\n  return allDataX;\n}\n\nfunction flatten<T>(arrays: T[][]): T[] {\n  const merged: T[] = [];\n  for (const array of arrays) {\n    for (const item of array) {\n      merged.push(item);\n    }\n  }\n  return merged;\n}\n"]},"metadata":{},"sourceType":"module"}