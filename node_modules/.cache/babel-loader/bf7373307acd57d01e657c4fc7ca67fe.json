{"ast":null,"code":"import _defineProperty from \"/Users/tangyizhi/Desktop/Assignment2/frontend/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _toConsumableArray from \"/Users/tangyizhi/Desktop/Assignment2/frontend/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _slicedToArray from \"/Users/tangyizhi/Desktop/Assignment2/frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport { __rest } from \"tslib\";\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport clsx from 'clsx';\nimport React, { useCallback, useLayoutEffect, useMemo, useRef, useState } from 'react';\nimport customCssProps from '../internal/generated/custom-css-properties';\nimport { Flash, focusFlashById } from './flash';\nimport InternalIcon from '../icon/internal';\nimport { TransitionGroup } from 'react-transition-group';\nimport { Transition } from '../internal/components/transition';\nimport styles from './styles.css.js';\nimport { counterTypes, getFlashTypeCount, getItemColor, getVisibleCollapsedItems } from './utils';\nimport { animate, getDOMRects } from '../internal/animate';\nimport { useUniqueId } from '../internal/hooks/use-unique-id';\nimport { sendToggleMetric } from './internal/analytics';\nimport { useFlashbar } from './common';\nimport { throttle } from '../internal/utils/throttle';\nimport { scrollElementIntoView } from '../internal/utils/scrollable-containers';\nimport { findUpUntil } from '../internal/utils/dom';\nimport { useInternalI18n } from '../i18n/context';\nimport { getVisualContextClassname } from '../internal/components/visual-context';\nimport { useEffectOnUpdate } from '../internal/hooks/use-effect-on-update';\n// If the number of items is equal or less than this value,\n// the toggle element will not be displayed and the Flashbar will look like a regular single-item Flashbar.\nvar maxNonCollapsibleItems = 1;\nvar resizeListenerThrottleDelay = 100;\nexport default function CollapsibleFlashbar(_a) {\n  var items = _a.items,\n    restProps = __rest(_a, [\"items\"]);\n  var _useState = useState([]),\n    _useState2 = _slicedToArray(_useState, 2),\n    enteringItems = _useState2[0],\n    setEnteringItems = _useState2[1];\n  var _useState3 = useState([]),\n    _useState4 = _slicedToArray(_useState3, 2),\n    exitingItems = _useState4[0],\n    setExitingItems = _useState4[1];\n  var _useState5 = useState(false),\n    _useState6 = _slicedToArray(_useState5, 2),\n    isFlashbarStackExpanded = _useState6[0],\n    setIsFlashbarStackExpanded = _useState6[1];\n  var getElementsToAnimate = useCallback(function () {\n    var flashElements = isFlashbarStackExpanded ? expandedItemRefs.current : collapsedItemRefs.current;\n    return Object.assign(Object.assign({}, flashElements), {\n      notificationBar: notificationBarRef.current\n    });\n  }, [isFlashbarStackExpanded]);\n  var prepareAnimations = useCallback(function () {\n    var rects = getDOMRects(getElementsToAnimate());\n    setInitialAnimationState(rects);\n  }, [getElementsToAnimate]);\n  var _useFlashbar = useFlashbar(Object.assign(Object.assign({\n      items: items\n    }, restProps), {\n      onItemsAdded: function onItemsAdded(newItems) {\n        setEnteringItems([].concat(_toConsumableArray(enteringItems), _toConsumableArray(newItems)));\n      },\n      onItemsChanged: function onItemsChanged(options) {\n        // If not all items have ID, we can still animate collapse/expand transitions\n        // because we can rely on each item's index in the original array,\n        // but we can't do that when elements are added or removed, since the index changes.\n        if ((options === null || options === void 0 ? void 0 : options.allItemsHaveId) && !(options === null || options === void 0 ? void 0 : options.isReducedMotion)) {\n          prepareAnimations();\n        }\n      },\n      onItemsRemoved: function onItemsRemoved(removedItems) {\n        setExitingItems([].concat(_toConsumableArray(exitingItems), _toConsumableArray(removedItems)));\n      }\n    })),\n    baseProps = _useFlashbar.baseProps,\n    breakpoint = _useFlashbar.breakpoint,\n    isReducedMotion = _useFlashbar.isReducedMotion,\n    isVisualRefresh = _useFlashbar.isVisualRefresh,\n    mergedRef = _useFlashbar.mergedRef,\n    ref = _useFlashbar.ref;\n  var collapsedItemRefs = useRef({});\n  var expandedItemRefs = useRef({});\n  var _useState7 = useState(null),\n    _useState8 = _slicedToArray(_useState7, 2),\n    initialAnimationState = _useState8[0],\n    setInitialAnimationState = _useState8[1];\n  var listElementRef = useRef(null);\n  var notificationBarRef = useRef(null);\n  var _useState9 = useState(false),\n    _useState10 = _slicedToArray(_useState9, 2),\n    transitioning = _useState10[0],\n    setTransitioning = _useState10[1];\n  var flashbarElementId = useUniqueId('flashbar');\n  var itemCountElementId = useUniqueId('item-count');\n  if (items.length <= maxNonCollapsibleItems && isFlashbarStackExpanded) {\n    setIsFlashbarStackExpanded(false);\n  }\n  var animateFlash = !isReducedMotion;\n  function toggleCollapseExpand() {\n    sendToggleMetric(items.length, !isFlashbarStackExpanded);\n    if (!isReducedMotion) {\n      prepareAnimations();\n    }\n    setIsFlashbarStackExpanded(function (prev) {\n      return !prev;\n    });\n  }\n  useLayoutEffect(function () {\n    if (isFlashbarStackExpanded && (items === null || items === void 0 ? void 0 : items.length)) {\n      var mostRecentItem = items[0];\n      if (mostRecentItem.id !== undefined) {\n        focusFlashById(ref.current, mostRecentItem.id);\n      }\n    }\n    // Run this after expanding, but not every time the items change.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [isFlashbarStackExpanded]);\n  // When collapsing, scroll up if necessary to avoid losing track of the focused button\n  useEffectOnUpdate(function () {\n    if (!isFlashbarStackExpanded && notificationBarRef.current) {\n      scrollElementIntoView(notificationBarRef.current);\n    }\n  }, [isFlashbarStackExpanded]);\n  var updateBottomSpacing = useMemo(function () {\n    return throttle(function () {\n      // Allow vertical space between Flashbar and page bottom only when the Flashbar is reaching the end of the page,\n      // otherwise avoid spacing with eventual sticky elements below.\n      var listElement = listElementRef === null || listElementRef === void 0 ? void 0 : listElementRef.current;\n      var flashbar = listElement === null || listElement === void 0 ? void 0 : listElement.parentElement;\n      if (listElement && flashbar) {\n        // Make sure the bottom padding is present when we make the calculations,\n        // then we might decide to remove it or not.\n        flashbar.classList.remove(styles.floating);\n        var windowHeight = window.innerHeight;\n        // Take the parent region into account if using the App Layout, because it might have additional margins.\n        // Otherwise we use the Flashbar component for this calculation.\n        var outerElement = findUpUntil(flashbar, function (element) {\n          return element.getAttribute('role') === 'region';\n        }) || flashbar;\n        var applySpacing = isFlashbarStackExpanded && Math.ceil(outerElement.getBoundingClientRect().bottom) >= windowHeight;\n        if (!applySpacing) {\n          flashbar.classList.add(styles.floating);\n        }\n      }\n    }, resizeListenerThrottleDelay);\n  }, [isFlashbarStackExpanded]);\n  useLayoutEffect(function () {\n    window.addEventListener('resize', updateBottomSpacing);\n    return function () {\n      window.removeEventListener('resize', updateBottomSpacing);\n      updateBottomSpacing.cancel();\n    };\n  }, [updateBottomSpacing]);\n  var i18nStrings = restProps.i18nStrings;\n  var i18n = useInternalI18n('flashbar');\n  var ariaLabel = i18n('i18nStrings.ariaLabel', i18nStrings === null || i18nStrings === void 0 ? void 0 : i18nStrings.ariaLabel);\n  var notificationBarText = i18n('i18nStrings.notificationBarText', i18nStrings === null || i18nStrings === void 0 ? void 0 : i18nStrings.notificationBarText);\n  var notificationBarAriaLabel = i18n('i18nStrings.notificationBarAriaLabel', i18nStrings === null || i18nStrings === void 0 ? void 0 : i18nStrings.notificationBarAriaLabel);\n  var iconAriaLabels = {\n    errorIconAriaLabel: i18n('i18nStrings.errorIconAriaLabel', i18nStrings === null || i18nStrings === void 0 ? void 0 : i18nStrings.errorIconAriaLabel),\n    inProgressIconAriaLabel: i18n('i18nStrings.inProgressIconAriaLabel', i18nStrings === null || i18nStrings === void 0 ? void 0 : i18nStrings.inProgressIconAriaLabel),\n    infoIconAriaLabel: i18n('i18nStrings.infoIconAriaLabel', i18nStrings === null || i18nStrings === void 0 ? void 0 : i18nStrings.infoIconAriaLabel),\n    successIconAriaLabel: i18n('i18nStrings.successIconAriaLabel', i18nStrings === null || i18nStrings === void 0 ? void 0 : i18nStrings.successIconAriaLabel),\n    warningIconAriaLabel: i18n('i18nStrings.warningIconAriaLabel', i18nStrings === null || i18nStrings === void 0 ? void 0 : i18nStrings.warningIconAriaLabel)\n  };\n  useLayoutEffect(function () {\n    // When `useLayoutEffect` is called, the DOM is updated but has not been painted yet,\n    // so it's a good moment to trigger animations that will make calculations based on old and new DOM state.\n    // The old state is kept in `initialAnimationState`\n    // and the new state can be retrieved from the current DOM elements.\n    if (initialAnimationState) {\n      updateBottomSpacing();\n      animate({\n        elements: getElementsToAnimate(),\n        oldState: initialAnimationState,\n        newElementInitialState: function newElementInitialState(_ref) {\n          var top = _ref.top;\n          return {\n            scale: 0.9,\n            y: -0.2 * top\n          };\n        },\n        onTransitionsEnd: function onTransitionsEnd() {\n          return setTransitioning(false);\n        }\n      });\n      setTransitioning(true);\n      setInitialAnimationState(null);\n    }\n  }, [updateBottomSpacing, getElementsToAnimate, initialAnimationState, isFlashbarStackExpanded]);\n  var isCollapsible = items.length > maxNonCollapsibleItems;\n  var countByType = getFlashTypeCount(items);\n  var numberOfColorsInStack = new Set(items.map(getItemColor)).size;\n  var maxSlots = Math.max(numberOfColorsInStack, 3);\n  var stackDepth = Math.min(maxSlots, items.length);\n  var itemsToShow = isFlashbarStackExpanded ? items.map(function (item, index) {\n    return Object.assign(Object.assign({}, item), {\n      expandedIndex: index\n    });\n  }) : getVisibleCollapsedItems(items, stackDepth).map(function (item, index) {\n    return Object.assign(Object.assign({}, item), {\n      collapsedIndex: index\n    });\n  });\n  var getItemId = function getItemId(item) {\n    var _a, _b;\n    return (_b = (_a = item.id) !== null && _a !== void 0 ? _a : item.expandedIndex) !== null && _b !== void 0 ? _b : 0;\n  };\n  // This check allows us to use the standard \"enter\" Transition only when the notification was not existing before.\n  // If instead it was moved to the top of the stack but was already present in the array\n  // (e.g, after dismissing another notification),\n  // we need to use different, more custom and more controlled animations.\n  var hasEntered = function hasEntered(item) {\n    return enteringItems.some(function (_item) {\n      return _item.id && _item.id === item.id;\n    });\n  };\n  var hasLeft = function hasLeft(item) {\n    return !('expandedIndex' in item);\n  };\n  var hasEnteredOrLeft = function hasEnteredOrLeft(item) {\n    return hasEntered(item) || hasLeft(item);\n  };\n  var showInnerContent = function showInnerContent(item) {\n    return isFlashbarStackExpanded || hasLeft(item) || 'expandedIndex' in item && item.expandedIndex === 0;\n  };\n  var shouldUseStandardAnimation = function shouldUseStandardAnimation(item, index) {\n    return index === 0 && hasEnteredOrLeft(item);\n  };\n  var getAnimationElementId = function getAnimationElementId(item) {\n    return \"flash-\".concat(getItemId(item));\n  };\n  var renderList = function renderList() {\n    return React.createElement(\"ul\", {\n      ref: listElementRef,\n      className: clsx(styles['flash-list'], isFlashbarStackExpanded ? styles.expanded : styles.collapsed, transitioning && styles['animation-running'], initialAnimationState && styles['animation-ready'], isVisualRefresh && styles['visual-refresh']),\n      id: flashbarElementId,\n      \"aria-label\": ariaLabel,\n      \"aria-describedby\": isCollapsible ? itemCountElementId : undefined,\n      style: !isFlashbarStackExpanded || transitioning ? _defineProperty({}, customCssProps.flashbarStackDepth, stackDepth) : undefined\n    }, React.createElement(ListWrapper, {\n      withMotion: !isReducedMotion\n    }, itemsToShow.map(function (item, index) {\n      return React.createElement(Transition, {\n        key: getItemId(item),\n        in: !hasLeft(item),\n        onStatusChange: function onStatusChange(status) {\n          if (status === 'entered') {\n            setEnteringItems([]);\n          } else if (status === 'exited') {\n            setExitingItems([]);\n          }\n        }\n      }, function (state, transitionRootElement) {\n        var _a, _b, _c;\n        return React.createElement(\"li\", {\n          \"aria-hidden\": !showInnerContent(item),\n          className: showInnerContent(item) ? clsx(styles['flash-list-item'], !isFlashbarStackExpanded && styles.item, !collapsedItemRefs.current[getAnimationElementId(item)] && styles['expanded-only']) : clsx(styles.flash, styles[\"flash-type-\".concat((_a = item.type) !== null && _a !== void 0 ? _a : 'info')], styles.item),\n          ref: function ref(element) {\n            if (isFlashbarStackExpanded) {\n              expandedItemRefs.current[getAnimationElementId(item)] = element;\n            } else {\n              collapsedItemRefs.current[getAnimationElementId(item)] = element;\n            }\n          },\n          style: !isFlashbarStackExpanded || transitioning ? _defineProperty({}, customCssProps.flashbarStackIndex, (_c = (_b = item.collapsedIndex) !== null && _b !== void 0 ? _b : item.expandedIndex) !== null && _c !== void 0 ? _c : index) : undefined,\n          key: getItemId(item)\n        }, showInnerContent(item) && React.createElement(Flash\n        // eslint-disable-next-line react/forbid-component-props\n        , Object.assign({\n          // eslint-disable-next-line react/forbid-component-props\n          className: clsx(animateFlash && styles['flash-with-motion'], isVisualRefresh && styles['flash-refresh']),\n          key: getItemId(item),\n          ref: shouldUseStandardAnimation(item, index) ? transitionRootElement : undefined,\n          transitionState: shouldUseStandardAnimation(item, index) ? state : undefined,\n          i18nStrings: iconAriaLabels\n        }, item)));\n      });\n    })));\n  };\n  return React.createElement(\"div\", Object.assign({}, baseProps, {\n    className: clsx(baseProps.className, styles.flashbar, styles[\"breakpoint-\".concat(breakpoint)], styles.stack, isCollapsible && styles.collapsible, items.length === 2 && styles['short-list'], isFlashbarStackExpanded && styles.expanded, isVisualRefresh && styles['visual-refresh']),\n    ref: mergedRef\n  }), isFlashbarStackExpanded && renderList(), isCollapsible && React.createElement(\"div\", {\n    className: clsx(styles['notification-bar'], isVisualRefresh && styles['visual-refresh'], isFlashbarStackExpanded ? styles.expanded : styles.collapsed, transitioning && styles['animation-running'], items.length === 2 && styles['short-list'], getVisualContextClassname('flashbar') // Visual context is needed for focus ring to be white\n    ),\n    onClick: toggleCollapseExpand,\n    ref: notificationBarRef\n  }, React.createElement(\"span\", {\n    \"aria-live\": \"polite\",\n    className: styles.status,\n    role: \"status\",\n    id: itemCountElementId\n  }, notificationBarText && React.createElement(\"h2\", {\n    className: styles.header\n  }, notificationBarText), React.createElement(\"span\", {\n    className: styles['item-count']\n  }, counterTypes.map(function (_ref4) {\n    var type = _ref4.type,\n      labelName = _ref4.labelName,\n      iconName = _ref4.iconName;\n    return React.createElement(NotificationTypeCount, {\n      key: type,\n      iconName: iconName,\n      label: iconAriaLabels[labelName],\n      count: countByType[type]\n    });\n  }))), React.createElement(\"button\", {\n    \"aria-controls\": flashbarElementId,\n    \"aria-describedby\": itemCountElementId,\n    \"aria-expanded\": isFlashbarStackExpanded,\n    \"aria-label\": notificationBarAriaLabel,\n    className: clsx(styles.button, isFlashbarStackExpanded && styles.expanded)\n  }, React.createElement(InternalIcon, {\n    className: styles.icon,\n    size: \"normal\",\n    name: \"angle-down\"\n  }))), !isFlashbarStackExpanded && renderList());\n}\nvar NotificationTypeCount = function NotificationTypeCount(_ref5) {\n  var iconName = _ref5.iconName,\n    label = _ref5.label,\n    count = _ref5.count;\n  return React.createElement(\"span\", {\n    className: styles['type-count']\n  }, React.createElement(\"span\", {\n    \"aria-label\": label,\n    role: \"img\"\n  }, React.createElement(\"span\", {\n    title: label,\n    \"aria-hidden\": \"true\"\n  }, React.createElement(InternalIcon, {\n    name: iconName\n  }))), React.createElement(\"span\", {\n    className: styles['count-number']\n  }, count));\n};\nvar ListWrapper = function ListWrapper(_ref6) {\n  var children = _ref6.children,\n    withMotion = _ref6.withMotion;\n  return withMotion ? React.createElement(TransitionGroup, {\n    component: null\n  }, children) : React.createElement(React.Fragment, null, children);\n};","map":{"version":3,"mappings":";;;;AAAA;AACA;AACA,OAAOA,IAAI,MAAM,MAAM;AACvB,OAAOC,KAAK,IAAeC,WAAW,EAAEC,eAAe,EAAEC,OAAO,EAAEC,MAAM,EAAEC,QAAQ,QAAQ,OAAO;AACjG,OAAOC,cAAc,MAAM,6CAA6C;AACxE,SAASC,KAAK,EAAEC,cAAc,QAAQ,SAAS;AAE/C,OAAOC,YAAY,MAAM,kBAAkB;AAC3C,SAASC,eAAe,QAAQ,wBAAwB;AACxD,SAASC,UAAU,QAAQ,mCAAmC;AAC9D,OAAOC,MAAM,MAAM,iBAAiB;AACpC,SAASC,YAAY,EAAEC,iBAAiB,EAAEC,YAAY,EAAEC,wBAAwB,QAAuB,SAAS;AAChH,SAASC,OAAO,EAAEC,WAAW,QAAQ,qBAAqB;AAC1D,SAASC,WAAW,QAAQ,iCAAiC;AAE7D,SAASC,gBAAgB,QAAQ,sBAAsB;AACvD,SAASC,WAAW,QAAQ,UAAU;AACtC,SAASC,QAAQ,QAAQ,4BAA4B;AACrD,SAASC,qBAAqB,QAAQ,yCAAyC;AAC/E,SAASC,WAAW,QAAQ,uBAAuB;AACnD,SAASC,eAAe,QAAQ,iBAAiB;AACjD,SAASC,yBAAyB,QAAQ,uCAAuC;AACjF,SAASC,iBAAiB,QAAQ,wCAAwC;AAI1E;AACA;AACA,IAAMC,sBAAsB,GAAG,CAAC;AAEhC,IAAMC,2BAA2B,GAAG,GAAG;AAEvC,eAAc,SAAUC,mBAAmB,CAACC,EAAsC;EAAtC,IAAEC,KAAK,KAA+B,CAApCA,KAAK;IAAKC,SAAS,cAArB,SAAuB,CAAF;EAC/D,gBAA0C5B,QAAQ,CAAiD,EAAE,CAAC;IAAA;IAA/F6B,aAAa;IAAEC,gBAAgB;EACtC,iBAAwC9B,QAAQ,CAAiD,EAAE,CAAC;IAAA;IAA7F+B,YAAY;IAAEC,eAAe;EACpC,iBAA8DhC,QAAQ,CAAC,KAAK,CAAC;IAAA;IAAtEiC,uBAAuB;IAAEC,0BAA0B;EAE1D,IAAMC,oBAAoB,GAAGvC,WAAW,CAAC,YAAK;IAC5C,IAAMwC,aAAa,GAAGH,uBAAuB,GAAGI,gBAAgB,CAACC,OAAO,GAAGC,iBAAiB,CAACD,OAAO;IACpG,uCAAYF,aAAa;MAAEI,eAAe,EAAEC,kBAAkB,CAACH;IAAO;EACxE,CAAC,EAAE,CAACL,uBAAuB,CAAC,CAAC;EAE7B,IAAMS,iBAAiB,GAAG9C,WAAW,CAAC,YAAK;IACzC,IAAM+C,KAAK,GAAG9B,WAAW,CAACsB,oBAAoB,EAAE,CAAC;IACjDS,wBAAwB,CAACD,KAAK,CAAC;EACjC,CAAC,EAAE,CAACR,oBAAoB,CAAC,CAAC;EAE1B,mBAAoFnB,WAAW;MAC7FW,KAAK,EAALA;IAAK,GACFC,SAAS;MACZiB,YAAY,EAAE,8BAAQ,EAAG;QACvBf,gBAAgB,8BAAKD,aAAa,sBAAKiB,QAAQ,GAAE;MACnD,CAAC;MACDC,cAAc,EAAE,+BAAO,EAAG;QACxB;QACA;QACA;QACA,IAAI,QAAO,aAAPC,OAAO,uBAAPA,OAAO,CAAEC,cAAc,KAAI,EAACD,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAEE,eAAe,GAAE;UACxDR,iBAAiB,EAAE;;MAEvB,CAAC;MACDS,cAAc,EAAE,oCAAY,EAAG;QAC7BnB,eAAe,8BAAKD,YAAY,sBAAKqB,YAAY,GAAE;MACrD;IAAC,GACD;IAjBMC,SAAS,gBAATA,SAAS;IAAEC,UAAU,gBAAVA,UAAU;IAAEJ,eAAe,gBAAfA,eAAe;IAAEK,eAAe,gBAAfA,eAAe;IAAEC,SAAS,gBAATA,SAAS;IAAEC,GAAG,gBAAHA,GAAG;EAmB/E,IAAMlB,iBAAiB,GAAGxC,MAAM,CAA8C,EAAE,CAAC;EACjF,IAAMsC,gBAAgB,GAAGtC,MAAM,CAA8C,EAAE,CAAC;EAChF,iBAA0DC,QAAQ,CAA0C,IAAI,CAAC;IAAA;IAA1G0D,qBAAqB;IAAEd,wBAAwB;EACtD,IAAMe,cAAc,GAAG5D,MAAM,CAA0B,IAAI,CAAC;EAC5D,IAAM0C,kBAAkB,GAAG1C,MAAM,CAAwB,IAAI,CAAC;EAC9D,iBAA0CC,QAAQ,CAAC,KAAK,CAAC;IAAA;IAAlD4D,aAAa;IAAEC,gBAAgB;EACtC,IAAMC,iBAAiB,GAAGhD,WAAW,CAAC,UAAU,CAAC;EACjD,IAAMiD,kBAAkB,GAAGjD,WAAW,CAAC,YAAY,CAAC;EAEpD,IAAIa,KAAK,CAACqC,MAAM,IAAIzC,sBAAsB,IAAIU,uBAAuB,EAAE;IACrEC,0BAA0B,CAAC,KAAK,CAAC;;EAGnC,IAAM+B,YAAY,GAAG,CAACf,eAAe;EAErC,SAASgB,oBAAoB;IAC3BnD,gBAAgB,CAACY,KAAK,CAACqC,MAAM,EAAE,CAAC/B,uBAAuB,CAAC;IACxD,IAAI,CAACiB,eAAe,EAAE;MACpBR,iBAAiB,EAAE;;IAErBR,0BAA0B,CAAC,cAAI;MAAA,OAAI,CAACiC,IAAI;IAAA,EAAC;EAC3C;EAEAtE,eAAe,CAAC,YAAK;IACnB,IAAIoC,uBAAuB,KAAIN,KAAK,aAALA,KAAK,uBAALA,KAAK,CAAEqC,MAAM,GAAE;MAC5C,IAAMI,cAAc,GAAGzC,KAAK,CAAC,CAAC,CAAC;MAC/B,IAAIyC,cAAc,CAACC,EAAE,KAAKC,SAAS,EAAE;QACnCnE,cAAc,CAACsD,GAAG,CAACnB,OAAO,EAAE8B,cAAc,CAACC,EAAE,CAAC;;;IAGlD;IACA;EACF,CAAC,EAAE,CAACpC,uBAAuB,CAAC,CAAC;EAE7B;EACAX,iBAAiB,CAAC,YAAK;IACrB,IAAI,CAACW,uBAAuB,IAAIQ,kBAAkB,CAACH,OAAO,EAAE;MAC1DpB,qBAAqB,CAACuB,kBAAkB,CAACH,OAAO,CAAC;;EAErD,CAAC,EAAE,CAACL,uBAAuB,CAAC,CAAC;EAE7B,IAAMsC,mBAAmB,GAAGzE,OAAO,CACjC;IAAA,OACEmB,QAAQ,CAAC,YAAK;MACZ;MACA;MACA,IAAMuD,WAAW,GAAGb,cAAc,aAAdA,cAAc,uBAAdA,cAAc,CAAErB,OAAO;MAC3C,IAAMmC,QAAQ,GAAGD,WAAW,aAAXA,WAAW,uBAAXA,WAAW,CAAEE,aAAa;MAC3C,IAAIF,WAAW,IAAIC,QAAQ,EAAE;QAC3B;QACA;QACAA,QAAQ,CAACE,SAAS,CAACC,MAAM,CAACrE,MAAM,CAACsE,QAAQ,CAAC;QAC1C,IAAMC,YAAY,GAAGC,MAAM,CAACC,WAAW;QACvC;QACA;QACA,IAAMC,YAAY,GAAG9D,WAAW,CAACsD,QAAQ,EAAE,iBAAO;UAAA,OAAIS,OAAO,CAACC,YAAY,CAAC,MAAM,CAAC,KAAK,QAAQ;QAAA,EAAC,IAAIV,QAAQ;QAC5G,IAAMW,YAAY,GAChBnD,uBAAuB,IAAIoD,IAAI,CAACC,IAAI,CAACL,YAAY,CAACM,qBAAqB,EAAE,CAACC,MAAM,CAAC,IAAIV,YAAY;QACnG,IAAI,CAACM,YAAY,EAAE;UACjBX,QAAQ,CAACE,SAAS,CAACc,GAAG,CAAClF,MAAM,CAACsE,QAAQ,CAAC;;;IAG7C,CAAC,EAAErD,2BAA2B,CAAC;EAAA,GACjC,CAACS,uBAAuB,CAAC,CAC1B;EAEDpC,eAAe,CAAC,YAAK;IACnBkF,MAAM,CAACW,gBAAgB,CAAC,QAAQ,EAAEnB,mBAAmB,CAAC;IACtD,OAAO,YAAK;MACVQ,MAAM,CAACY,mBAAmB,CAAC,QAAQ,EAAEpB,mBAAmB,CAAC;MACzDA,mBAAmB,CAACqB,MAAM,EAAE;IAC9B,CAAC;EACH,CAAC,EAAE,CAACrB,mBAAmB,CAAC,CAAC;EAEzB,IAAQsB,WAAW,GAAKjE,SAAS,CAAzBiE,WAAW;EAEnB,IAAMC,IAAI,GAAG1E,eAAe,CAAC,UAAU,CAAC;EACxC,IAAM2E,SAAS,GAAGD,IAAI,CAAC,uBAAuB,EAAED,WAAW,aAAXA,WAAW,uBAAXA,WAAW,CAAEE,SAAS,CAAC;EACvE,IAAMC,mBAAmB,GAAGF,IAAI,CAAC,iCAAiC,EAAED,WAAW,aAAXA,WAAW,uBAAXA,WAAW,CAAEG,mBAAmB,CAAC;EACrG,IAAMC,wBAAwB,GAAGH,IAAI,CAAC,sCAAsC,EAAED,WAAW,aAAXA,WAAW,uBAAXA,WAAW,CAAEI,wBAAwB,CAAC;EACpH,IAAMC,cAAc,GAAG;IACrBC,kBAAkB,EAAEL,IAAI,CAAC,gCAAgC,EAAED,WAAW,aAAXA,WAAW,uBAAXA,WAAW,CAAEM,kBAAkB,CAAC;IAC3FC,uBAAuB,EAAEN,IAAI,CAAC,qCAAqC,EAAED,WAAW,aAAXA,WAAW,uBAAXA,WAAW,CAAEO,uBAAuB,CAAC;IAC1GC,iBAAiB,EAAEP,IAAI,CAAC,+BAA+B,EAAED,WAAW,aAAXA,WAAW,uBAAXA,WAAW,CAAEQ,iBAAiB,CAAC;IACxFC,oBAAoB,EAAER,IAAI,CAAC,kCAAkC,EAAED,WAAW,aAAXA,WAAW,uBAAXA,WAAW,CAAES,oBAAoB,CAAC;IACjGC,oBAAoB,EAAET,IAAI,CAAC,kCAAkC,EAAED,WAAW,aAAXA,WAAW,uBAAXA,WAAW,CAAEU,oBAAoB;GACjG;EAED1G,eAAe,CAAC,YAAK;IACnB;IACA;IACA;IACA;IAEA,IAAI6D,qBAAqB,EAAE;MACzBa,mBAAmB,EAAE;MAErB3D,OAAO,CAAC;QACN4F,QAAQ,EAAErE,oBAAoB,EAAE;QAChCsE,QAAQ,EAAE/C,qBAAqB;QAC/BgD,sBAAsB,EAAE;UAAA,IAAGC,GAAG,QAAHA,GAAG;UAAA,OAAQ;YAAEC,KAAK,EAAE,GAAG;YAAEC,CAAC,EAAE,CAAC,GAAG,GAAGF;UAAG,CAAE;QAAA,CAAC;QACpEG,gBAAgB,EAAE;UAAA,OAAMjD,gBAAgB,CAAC,KAAK,CAAC;QAAA;OAChD,CAAC;MAEFA,gBAAgB,CAAC,IAAI,CAAC;MACtBjB,wBAAwB,CAAC,IAAI,CAAC;;EAElC,CAAC,EAAE,CAAC2B,mBAAmB,EAAEpC,oBAAoB,EAAEuB,qBAAqB,EAAEzB,uBAAuB,CAAC,CAAC;EAE/F,IAAM8E,aAAa,GAAGpF,KAAK,CAACqC,MAAM,GAAGzC,sBAAsB;EAE3D,IAAMyF,WAAW,GAAGvG,iBAAiB,CAACkB,KAAK,CAAC;EAE5C,IAAMsF,qBAAqB,GAAG,IAAIC,GAAG,CAACvF,KAAK,CAACwF,GAAG,CAACzG,YAAY,CAAC,CAAC,CAAC0G,IAAI;EACnE,IAAMC,QAAQ,GAAGhC,IAAI,CAACiC,GAAG,CAACL,qBAAqB,EAAE,CAAC,CAAC;EACnD,IAAMM,UAAU,GAAGlC,IAAI,CAACmC,GAAG,CAACH,QAAQ,EAAE1F,KAAK,CAACqC,MAAM,CAAC;EAEnD,IAAMyD,WAAW,GAAGxF,uBAAuB,GACvCN,KAAK,CAACwF,GAAG,CAAC,UAACO,IAAI,EAAEC,KAAK;IAAA,OAAKC,gCAAMF,IAAI;MAAEG,aAAa,EAAEF;IAAK;EAAA,CAAG,CAAC,GAC/DhH,wBAAwB,CAACgB,KAAK,EAAE4F,UAAU,CAAC,CAACJ,GAAG,CAAC,UAACO,IAAmB,EAAEC,KAAa;IAAA,OAAKC,gCACnFF,IAAI;MACPI,cAAc,EAAEH;IAAK;EAAA,CACrB,CAAC;EAEP,IAAMI,SAAS,GAAG,SAAZA,SAAS,CAAIL,IAAqD,EAAI;IAAA;IAC1E,uBAAI,CAACrD,EAAE,mCAAKqD,IAAsB,CAACG,aAAa,mCAAI,CAAC;EAAA;EAEvD;EACA;EACA;EACA;EACA,IAAMG,UAAU,GAAG,SAAbA,UAAU,CAAIN,IAAqD;IAAA,OACvE7F,aAAa,CAACoG,IAAI,CAAC,eAAK;MAAA,OAAIC,KAAK,CAAC7D,EAAE,IAAI6D,KAAK,CAAC7D,EAAE,KAAKqD,IAAI,CAACrD,EAAE;IAAA,EAAC;EAAA;EAC/D,IAAM8D,OAAO,GAAG,SAAVA,OAAO,CAAIT,IAAqD;IAAA,OAAK,EAAE,eAAe,IAAIA,IAAI,CAAC;EAAA;EACrG,IAAMU,gBAAgB,GAAG,SAAnBA,gBAAgB,CAAIV,IAAqD;IAAA,OAAKM,UAAU,CAACN,IAAI,CAAC,IAAIS,OAAO,CAACT,IAAI,CAAC;EAAA;EAErH,IAAMW,gBAAgB,GAAG,SAAnBA,gBAAgB,CAAIX,IAAqD;IAAA,OAC7EzF,uBAAuB,IAAIkG,OAAO,CAACT,IAAI,CAAC,IAAK,eAAe,IAAIA,IAAI,IAAIA,IAAI,CAACG,aAAa,KAAK,CAAE;EAAA;EAEnG,IAAMS,0BAA0B,GAAG,SAA7BA,0BAA0B,CAAIZ,IAAmB,EAAEC,KAAa;IAAA,OAAKA,KAAK,KAAK,CAAC,IAAIS,gBAAgB,CAACV,IAAI,CAAC;EAAA;EAEhH,IAAMa,qBAAqB,GAAG,SAAxBA,qBAAqB,CAAIb,IAAmB;IAAA,uBAAcK,SAAS,CAACL,IAAI,CAAC;EAAA,CAAE;EAEjF,IAAMc,UAAU,GAAG,SAAbA,UAAU;IAAA,OACd7I;MACE8D,GAAG,EAAEE,cAAc;MACnB8E,SAAS,EAAE/I,IAAI,CACba,MAAM,CAAC,YAAY,CAAC,EACpB0B,uBAAuB,GAAG1B,MAAM,CAACmI,QAAQ,GAAGnI,MAAM,CAACoI,SAAS,EAC5D/E,aAAa,IAAIrD,MAAM,CAAC,mBAAmB,CAAC,EAC5CmD,qBAAqB,IAAInD,MAAM,CAAC,iBAAiB,CAAC,EAClDgD,eAAe,IAAIhD,MAAM,CAAC,gBAAgB,CAAC,CAC5C;MACD8D,EAAE,EAAEP,iBAAiB;MAAA,cACTiC,SAAS;MAAA,oBACHgB,aAAa,GAAGhD,kBAAkB,GAAGO,SAAS;MAChEsE,KAAK,EACH,CAAC3G,uBAAuB,IAAI2B,aAAa,uBAElC3D,cAAc,CAAC4I,kBAAkB,EAAGtB,UAAU,IAEjDjD;IAAS,GAGf3E,oBAACmJ,WAAW;MAACC,UAAU,EAAE,CAAC7F;IAAe,GACtCuE,WAAW,CAACN,GAAG,CAAC,UAACO,IAAmB,EAAEC,KAAa;MAAA,OAClDhI,oBAACW,UAAU;QACT0I,GAAG,EAAEjB,SAAS,CAACL,IAAI,CAAC;QACpBuB,EAAE,EAAE,CAACd,OAAO,CAACT,IAAI,CAAC;QAClBwB,cAAc,EAAE,8BAAM,EAAG;UACvB,IAAIC,MAAM,KAAK,SAAS,EAAE;YACxBrH,gBAAgB,CAAC,EAAE,CAAC;WACrB,MAAM,IAAIqH,MAAM,KAAK,QAAQ,EAAE;YAC9BnH,eAAe,CAAC,EAAE,CAAC;;QAEvB;MAAC,GAEA,UAACoH,KAAa,EAAEC,qBAA4D,EAAI;;QAAC,OAChF1J;UAAA,eACe,CAAC0I,gBAAgB,CAACX,IAAI,CAAC;UACpCe,SAAS,EACPJ,gBAAgB,CAACX,IAAI,CAAC,GAClBhI,IAAI,CACFa,MAAM,CAAC,iBAAiB,CAAC,EACzB,CAAC0B,uBAAuB,IAAI1B,MAAM,CAACmH,IAAI,EACvC,CAACnF,iBAAiB,CAACD,OAAO,CAACiG,qBAAqB,CAACb,IAAI,CAAC,CAAC,IAAInH,MAAM,CAAC,eAAe,CAAC,CACnF,GACDb,IAAI,CAACa,MAAM,CAAC+I,KAAK,EAAE/I,MAAM,sBAAe,UAAI,CAACgJ,IAAI,mCAAI,MAAM,EAAG,EAAEhJ,MAAM,CAACmH,IAAI,CAAC;UAElFjE,GAAG,EAAE,oBAAO,EAAG;YACb,IAAIxB,uBAAuB,EAAE;cAC3BI,gBAAgB,CAACC,OAAO,CAACiG,qBAAqB,CAACb,IAAI,CAAC,CAAC,GAAGxC,OAAO;aAChE,MAAM;cACL3C,iBAAiB,CAACD,OAAO,CAACiG,qBAAqB,CAACb,IAAI,CAAC,CAAC,GAAGxC,OAAO;;UAEpE,CAAC;UACD0D,KAAK,EACH,CAAC3G,uBAAuB,IAAI2B,aAAa,uBAElC3D,cAAc,CAACuJ,kBAAkB,EAChC,YAAC9B,IAAsB,CAACI,cAAc,mCAAKJ,IAAsB,CAACG,aAAa,mCAAIF,KAAK,IAE5FrD,SAAS;UAEf0E,GAAG,EAAEjB,SAAS,CAACL,IAAI;QAAC,GAEnBW,gBAAgB,CAACX,IAAI,CAAC,IACrB/H,oBAACO;QACC;QAAA;UAAA;UACAuI,SAAS,EAAE/I,IAAI,CACbuE,YAAY,IAAI1D,MAAM,CAAC,mBAAmB,CAAC,EAC3CgD,eAAe,IAAIhD,MAAM,CAAC,eAAe,CAAC,CAC3C;UACDyI,GAAG,EAAEjB,SAAS,CAACL,IAAI,CAAC;UACpBjE,GAAG,EAAE6E,0BAA0B,CAACZ,IAAI,EAAEC,KAAK,CAAC,GAAG0B,qBAAqB,GAAG/E,SAAS;UAChFmF,eAAe,EAAEnB,0BAA0B,CAACZ,IAAI,EAAEC,KAAK,CAAC,GAAGyB,KAAK,GAAG9E,SAAS;UAC5EuB,WAAW,EAAEK;QAAc,GACvBwB,IAAI,EAEX,CACE;OACN,CACU;IAAA,CACd,CAAC,CACU,CACX;EAAA,CACN;EAED,OACE/H,6CACM0D,SAAS;IACboF,SAAS,EAAE/I,IAAI,CACb2D,SAAS,CAACoF,SAAS,EACnBlI,MAAM,CAACkE,QAAQ,EACflE,MAAM,sBAAe+C,UAAU,EAAG,EAClC/C,MAAM,CAACmJ,KAAK,EACZ3C,aAAa,IAAIxG,MAAM,CAACoJ,WAAW,EACnChI,KAAK,CAACqC,MAAM,KAAK,CAAC,IAAIzD,MAAM,CAAC,YAAY,CAAC,EAC1C0B,uBAAuB,IAAI1B,MAAM,CAACmI,QAAQ,EAC1CnF,eAAe,IAAIhD,MAAM,CAAC,gBAAgB,CAAC,CAC5C;IACDkD,GAAG,EAAED;EAAS,IAEbvB,uBAAuB,IAAIuG,UAAU,EAAE,EACvCzB,aAAa,IACZpH;IACE8I,SAAS,EAAE/I,IAAI,CACba,MAAM,CAAC,kBAAkB,CAAC,EAC1BgD,eAAe,IAAIhD,MAAM,CAAC,gBAAgB,CAAC,EAC3C0B,uBAAuB,GAAG1B,MAAM,CAACmI,QAAQ,GAAGnI,MAAM,CAACoI,SAAS,EAC5D/E,aAAa,IAAIrD,MAAM,CAAC,mBAAmB,CAAC,EAC5CoB,KAAK,CAACqC,MAAM,KAAK,CAAC,IAAIzD,MAAM,CAAC,YAAY,CAAC,EAC1Cc,yBAAyB,CAAC,UAAU,CAAC,CAAC;IAAA,CACvC;IACDuI,OAAO,EAAE1F,oBAAoB;IAC7BT,GAAG,EAAEhB;EAAkB,GAEvB9C;IAAA,aAAgB,QAAQ;IAAC8I,SAAS,EAAElI,MAAM,CAAC4I,MAAM;IAAEU,IAAI,EAAC,QAAQ;IAACxF,EAAE,EAAEN;EAAkB,GACpFiC,mBAAmB,IAAIrG;IAAI8I,SAAS,EAAElI,MAAM,CAACuJ;EAAM,GAAG9D,mBAAmB,CAAM,EAChFrG;IAAM8I,SAAS,EAAElI,MAAM,CAAC,YAAY;EAAC,GAClCC,YAAY,CAAC2G,GAAG,CAAC;IAAA,IAAGoC,IAAI,SAAJA,IAAI;MAAEQ,SAAS,SAATA,SAAS;MAAEC,QAAQ,SAARA,QAAQ;IAAA,OAC5CrK,oBAACsK,qBAAqB;MACpBjB,GAAG,EAAEO,IAAI;MACTS,QAAQ,EAAEA,QAAQ;MAClBE,KAAK,EAAEhE,cAAc,CAAC6D,SAAS,CAAC;MAChCI,KAAK,EAAEnD,WAAW,CAACuC,IAAI;IAAC,EACxB;EAAA,CACH,CAAC,CACG,CACF,EACP5J;IAAA,iBACiBmE,iBAAiB;IAAA,oBACdC,kBAAkB;IAAA,iBACrB9B,uBAAuB;IAAA,cAC1BgE,wBAAwB;IACpCwC,SAAS,EAAE/I,IAAI,CAACa,MAAM,CAAC6J,MAAM,EAAEnI,uBAAuB,IAAI1B,MAAM,CAACmI,QAAQ;EAAC,GAE1E/I,oBAACS,YAAY;IAACqI,SAAS,EAAElI,MAAM,CAAC8J,IAAI;IAAEjD,IAAI,EAAC,QAAQ;IAACkD,IAAI,EAAC;EAAY,EAAG,CACjE,CAEZ,EACA,CAACrI,uBAAuB,IAAIuG,UAAU,EAAE,CACrC;AAEV;AAEA,IAAMyB,qBAAqB,GAAG,SAAxBA,qBAAqB,QAQtB;EAAA,IAPHD,QAAQ,SAARA,QAAQ;IACRE,KAAK,SAALA,KAAK;IACLC,KAAK,SAALA,KAAK;EAML,OACExK;IAAM8I,SAAS,EAAElI,MAAM,CAAC,YAAY;EAAC,GACnCZ;IAAA,cAAkBuK,KAAK;IAAEL,IAAI,EAAC;EAAK,GACjClK;IAAM4K,KAAK,EAAEL,KAAK;IAAA,eAAc;EAAM,GACpCvK,oBAACS,YAAY;IAACkK,IAAI,EAAEN;EAAQ,EAAI,CAC3B,CACF,EACPrK;IAAM8I,SAAS,EAAElI,MAAM,CAAC,cAAc;EAAC,GAAG4J,KAAK,CAAQ,CAClD;AAEX,CAAC;AAED,IAAMrB,WAAW,GAAG,SAAdA,WAAW;EAAA,IAAM0B,QAAQ,SAARA,QAAQ;IAAEzB,UAAU,SAAVA,UAAU;EAAA,OACzCA,UAAU,GAAGpJ,oBAACU,eAAe;IAACoK,SAAS,EAAE;EAAI,GAAGD,QAAQ,CAAmB,GAAG7K,0CAAG6K,QAAQ,CAAI;AAAA","names":["clsx","React","useCallback","useLayoutEffect","useMemo","useRef","useState","customCssProps","Flash","focusFlashById","InternalIcon","TransitionGroup","Transition","styles","counterTypes","getFlashTypeCount","getItemColor","getVisibleCollapsedItems","animate","getDOMRects","useUniqueId","sendToggleMetric","useFlashbar","throttle","scrollElementIntoView","findUpUntil","useInternalI18n","getVisualContextClassname","useEffectOnUpdate","maxNonCollapsibleItems","resizeListenerThrottleDelay","CollapsibleFlashbar","_a","items","restProps","enteringItems","setEnteringItems","exitingItems","setExitingItems","isFlashbarStackExpanded","setIsFlashbarStackExpanded","getElementsToAnimate","flashElements","expandedItemRefs","current","collapsedItemRefs","notificationBar","notificationBarRef","prepareAnimations","rects","setInitialAnimationState","onItemsAdded","newItems","onItemsChanged","options","allItemsHaveId","isReducedMotion","onItemsRemoved","removedItems","baseProps","breakpoint","isVisualRefresh","mergedRef","ref","initialAnimationState","listElementRef","transitioning","setTransitioning","flashbarElementId","itemCountElementId","length","animateFlash","toggleCollapseExpand","prev","mostRecentItem","id","undefined","updateBottomSpacing","listElement","flashbar","parentElement","classList","remove","floating","windowHeight","window","innerHeight","outerElement","element","getAttribute","applySpacing","Math","ceil","getBoundingClientRect","bottom","add","addEventListener","removeEventListener","cancel","i18nStrings","i18n","ariaLabel","notificationBarText","notificationBarAriaLabel","iconAriaLabels","errorIconAriaLabel","inProgressIconAriaLabel","infoIconAriaLabel","successIconAriaLabel","warningIconAriaLabel","elements","oldState","newElementInitialState","top","scale","y","onTransitionsEnd","isCollapsible","countByType","numberOfColorsInStack","Set","map","size","maxSlots","max","stackDepth","min","itemsToShow","item","index","Object","expandedIndex","collapsedIndex","getItemId","hasEntered","some","_item","hasLeft","hasEnteredOrLeft","showInnerContent","shouldUseStandardAnimation","getAnimationElementId","renderList","className","expanded","collapsed","style","flashbarStackDepth","ListWrapper","withMotion","key","in","onStatusChange","status","state","transitionRootElement","flash","type","flashbarStackIndex","transitionState","stack","collapsible","onClick","role","header","labelName","iconName","NotificationTypeCount","label","count","button","icon","name","title","children","component"],"sources":["/Users/tangyizhi/Desktop/Assignment2/frontend/node_modules/@cloudscape-design/components/flashbar/lib/default/flashbar/collapsible-flashbar.tsx"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport clsx from 'clsx';\nimport React, { ReactNode, useCallback, useLayoutEffect, useMemo, useRef, useState } from 'react';\nimport customCssProps from '../internal/generated/custom-css-properties';\nimport { Flash, focusFlashById } from './flash';\nimport { FlashbarProps } from './interfaces';\nimport InternalIcon from '../icon/internal';\nimport { TransitionGroup } from 'react-transition-group';\nimport { Transition } from '../internal/components/transition';\nimport styles from './styles.css.js';\nimport { counterTypes, getFlashTypeCount, getItemColor, getVisibleCollapsedItems, StackableItem } from './utils';\nimport { animate, getDOMRects } from '../internal/animate';\nimport { useUniqueId } from '../internal/hooks/use-unique-id';\nimport { IconProps } from '../icon/interfaces';\nimport { sendToggleMetric } from './internal/analytics';\nimport { useFlashbar } from './common';\nimport { throttle } from '../internal/utils/throttle';\nimport { scrollElementIntoView } from '../internal/utils/scrollable-containers';\nimport { findUpUntil } from '../internal/utils/dom';\nimport { useInternalI18n } from '../i18n/context';\nimport { getVisualContextClassname } from '../internal/components/visual-context';\nimport { useEffectOnUpdate } from '../internal/hooks/use-effect-on-update';\n\nexport { FlashbarProps };\n\n// If the number of items is equal or less than this value,\n// the toggle element will not be displayed and the Flashbar will look like a regular single-item Flashbar.\nconst maxNonCollapsibleItems = 1;\n\nconst resizeListenerThrottleDelay = 100;\n\nexport default function CollapsibleFlashbar({ items, ...restProps }: FlashbarProps) {\n  const [enteringItems, setEnteringItems] = useState<ReadonlyArray<FlashbarProps.MessageDefinition>>([]);\n  const [exitingItems, setExitingItems] = useState<ReadonlyArray<FlashbarProps.MessageDefinition>>([]);\n  const [isFlashbarStackExpanded, setIsFlashbarStackExpanded] = useState(false);\n\n  const getElementsToAnimate = useCallback(() => {\n    const flashElements = isFlashbarStackExpanded ? expandedItemRefs.current : collapsedItemRefs.current;\n    return { ...flashElements, notificationBar: notificationBarRef.current };\n  }, [isFlashbarStackExpanded]);\n\n  const prepareAnimations = useCallback(() => {\n    const rects = getDOMRects(getElementsToAnimate());\n    setInitialAnimationState(rects);\n  }, [getElementsToAnimate]);\n\n  const { baseProps, breakpoint, isReducedMotion, isVisualRefresh, mergedRef, ref } = useFlashbar({\n    items,\n    ...restProps,\n    onItemsAdded: newItems => {\n      setEnteringItems([...enteringItems, ...newItems]);\n    },\n    onItemsChanged: options => {\n      // If not all items have ID, we can still animate collapse/expand transitions\n      // because we can rely on each item's index in the original array,\n      // but we can't do that when elements are added or removed, since the index changes.\n      if (options?.allItemsHaveId && !options?.isReducedMotion) {\n        prepareAnimations();\n      }\n    },\n    onItemsRemoved: removedItems => {\n      setExitingItems([...exitingItems, ...removedItems]);\n    },\n  });\n\n  const collapsedItemRefs = useRef<Record<string | number, HTMLElement | null>>({});\n  const expandedItemRefs = useRef<Record<string | number, HTMLElement | null>>({});\n  const [initialAnimationState, setInitialAnimationState] = useState<Record<string | number, DOMRect> | null>(null);\n  const listElementRef = useRef<HTMLUListElement | null>(null);\n  const notificationBarRef = useRef<HTMLDivElement | null>(null);\n  const [transitioning, setTransitioning] = useState(false);\n  const flashbarElementId = useUniqueId('flashbar');\n  const itemCountElementId = useUniqueId('item-count');\n\n  if (items.length <= maxNonCollapsibleItems && isFlashbarStackExpanded) {\n    setIsFlashbarStackExpanded(false);\n  }\n\n  const animateFlash = !isReducedMotion;\n\n  function toggleCollapseExpand() {\n    sendToggleMetric(items.length, !isFlashbarStackExpanded);\n    if (!isReducedMotion) {\n      prepareAnimations();\n    }\n    setIsFlashbarStackExpanded(prev => !prev);\n  }\n\n  useLayoutEffect(() => {\n    if (isFlashbarStackExpanded && items?.length) {\n      const mostRecentItem = items[0];\n      if (mostRecentItem.id !== undefined) {\n        focusFlashById(ref.current, mostRecentItem.id);\n      }\n    }\n    // Run this after expanding, but not every time the items change.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [isFlashbarStackExpanded]);\n\n  // When collapsing, scroll up if necessary to avoid losing track of the focused button\n  useEffectOnUpdate(() => {\n    if (!isFlashbarStackExpanded && notificationBarRef.current) {\n      scrollElementIntoView(notificationBarRef.current);\n    }\n  }, [isFlashbarStackExpanded]);\n\n  const updateBottomSpacing = useMemo(\n    () =>\n      throttle(() => {\n        // Allow vertical space between Flashbar and page bottom only when the Flashbar is reaching the end of the page,\n        // otherwise avoid spacing with eventual sticky elements below.\n        const listElement = listElementRef?.current;\n        const flashbar = listElement?.parentElement;\n        if (listElement && flashbar) {\n          // Make sure the bottom padding is present when we make the calculations,\n          // then we might decide to remove it or not.\n          flashbar.classList.remove(styles.floating);\n          const windowHeight = window.innerHeight;\n          // Take the parent region into account if using the App Layout, because it might have additional margins.\n          // Otherwise we use the Flashbar component for this calculation.\n          const outerElement = findUpUntil(flashbar, element => element.getAttribute('role') === 'region') || flashbar;\n          const applySpacing =\n            isFlashbarStackExpanded && Math.ceil(outerElement.getBoundingClientRect().bottom) >= windowHeight;\n          if (!applySpacing) {\n            flashbar.classList.add(styles.floating);\n          }\n        }\n      }, resizeListenerThrottleDelay),\n    [isFlashbarStackExpanded]\n  );\n\n  useLayoutEffect(() => {\n    window.addEventListener('resize', updateBottomSpacing);\n    return () => {\n      window.removeEventListener('resize', updateBottomSpacing);\n      updateBottomSpacing.cancel();\n    };\n  }, [updateBottomSpacing]);\n\n  const { i18nStrings } = restProps;\n\n  const i18n = useInternalI18n('flashbar');\n  const ariaLabel = i18n('i18nStrings.ariaLabel', i18nStrings?.ariaLabel);\n  const notificationBarText = i18n('i18nStrings.notificationBarText', i18nStrings?.notificationBarText);\n  const notificationBarAriaLabel = i18n('i18nStrings.notificationBarAriaLabel', i18nStrings?.notificationBarAriaLabel);\n  const iconAriaLabels = {\n    errorIconAriaLabel: i18n('i18nStrings.errorIconAriaLabel', i18nStrings?.errorIconAriaLabel),\n    inProgressIconAriaLabel: i18n('i18nStrings.inProgressIconAriaLabel', i18nStrings?.inProgressIconAriaLabel),\n    infoIconAriaLabel: i18n('i18nStrings.infoIconAriaLabel', i18nStrings?.infoIconAriaLabel),\n    successIconAriaLabel: i18n('i18nStrings.successIconAriaLabel', i18nStrings?.successIconAriaLabel),\n    warningIconAriaLabel: i18n('i18nStrings.warningIconAriaLabel', i18nStrings?.warningIconAriaLabel),\n  };\n\n  useLayoutEffect(() => {\n    // When `useLayoutEffect` is called, the DOM is updated but has not been painted yet,\n    // so it's a good moment to trigger animations that will make calculations based on old and new DOM state.\n    // The old state is kept in `initialAnimationState`\n    // and the new state can be retrieved from the current DOM elements.\n\n    if (initialAnimationState) {\n      updateBottomSpacing();\n\n      animate({\n        elements: getElementsToAnimate(),\n        oldState: initialAnimationState,\n        newElementInitialState: ({ top }) => ({ scale: 0.9, y: -0.2 * top }),\n        onTransitionsEnd: () => setTransitioning(false),\n      });\n\n      setTransitioning(true);\n      setInitialAnimationState(null);\n    }\n  }, [updateBottomSpacing, getElementsToAnimate, initialAnimationState, isFlashbarStackExpanded]);\n\n  const isCollapsible = items.length > maxNonCollapsibleItems;\n\n  const countByType = getFlashTypeCount(items);\n\n  const numberOfColorsInStack = new Set(items.map(getItemColor)).size;\n  const maxSlots = Math.max(numberOfColorsInStack, 3);\n  const stackDepth = Math.min(maxSlots, items.length);\n\n  const itemsToShow = isFlashbarStackExpanded\n    ? items.map((item, index) => ({ ...item, expandedIndex: index }))\n    : getVisibleCollapsedItems(items, stackDepth).map((item: StackableItem, index: number) => ({\n        ...item,\n        collapsedIndex: index,\n      }));\n\n  const getItemId = (item: StackableItem | FlashbarProps.MessageDefinition) =>\n    item.id ?? (item as StackableItem).expandedIndex ?? 0;\n\n  // This check allows us to use the standard \"enter\" Transition only when the notification was not existing before.\n  // If instead it was moved to the top of the stack but was already present in the array\n  // (e.g, after dismissing another notification),\n  // we need to use different, more custom and more controlled animations.\n  const hasEntered = (item: StackableItem | FlashbarProps.MessageDefinition) =>\n    enteringItems.some(_item => _item.id && _item.id === item.id);\n  const hasLeft = (item: StackableItem | FlashbarProps.MessageDefinition) => !('expandedIndex' in item);\n  const hasEnteredOrLeft = (item: StackableItem | FlashbarProps.MessageDefinition) => hasEntered(item) || hasLeft(item);\n\n  const showInnerContent = (item: StackableItem | FlashbarProps.MessageDefinition) =>\n    isFlashbarStackExpanded || hasLeft(item) || ('expandedIndex' in item && item.expandedIndex === 0);\n\n  const shouldUseStandardAnimation = (item: StackableItem, index: number) => index === 0 && hasEnteredOrLeft(item);\n\n  const getAnimationElementId = (item: StackableItem) => `flash-${getItemId(item)}`;\n\n  const renderList = () => (\n    <ul\n      ref={listElementRef}\n      className={clsx(\n        styles['flash-list'],\n        isFlashbarStackExpanded ? styles.expanded : styles.collapsed,\n        transitioning && styles['animation-running'],\n        initialAnimationState && styles['animation-ready'],\n        isVisualRefresh && styles['visual-refresh']\n      )}\n      id={flashbarElementId}\n      aria-label={ariaLabel}\n      aria-describedby={isCollapsible ? itemCountElementId : undefined}\n      style={\n        !isFlashbarStackExpanded || transitioning\n          ? {\n              [customCssProps.flashbarStackDepth]: stackDepth,\n            }\n          : undefined\n      }\n    >\n      <ListWrapper withMotion={!isReducedMotion}>\n        {itemsToShow.map((item: StackableItem, index: number) => (\n          <Transition\n            key={getItemId(item)}\n            in={!hasLeft(item)}\n            onStatusChange={status => {\n              if (status === 'entered') {\n                setEnteringItems([]);\n              } else if (status === 'exited') {\n                setExitingItems([]);\n              }\n            }}\n          >\n            {(state: string, transitionRootElement: React.Ref<HTMLDivElement> | undefined) => (\n              <li\n                aria-hidden={!showInnerContent(item)}\n                className={\n                  showInnerContent(item)\n                    ? clsx(\n                        styles['flash-list-item'],\n                        !isFlashbarStackExpanded && styles.item,\n                        !collapsedItemRefs.current[getAnimationElementId(item)] && styles['expanded-only']\n                      )\n                    : clsx(styles.flash, styles[`flash-type-${item.type ?? 'info'}`], styles.item)\n                }\n                ref={element => {\n                  if (isFlashbarStackExpanded) {\n                    expandedItemRefs.current[getAnimationElementId(item)] = element;\n                  } else {\n                    collapsedItemRefs.current[getAnimationElementId(item)] = element;\n                  }\n                }}\n                style={\n                  !isFlashbarStackExpanded || transitioning\n                    ? {\n                        [customCssProps.flashbarStackIndex]:\n                          (item as StackableItem).collapsedIndex ?? (item as StackableItem).expandedIndex ?? index,\n                      }\n                    : undefined\n                }\n                key={getItemId(item)}\n              >\n                {showInnerContent(item) && (\n                  <Flash\n                    // eslint-disable-next-line react/forbid-component-props\n                    className={clsx(\n                      animateFlash && styles['flash-with-motion'],\n                      isVisualRefresh && styles['flash-refresh']\n                    )}\n                    key={getItemId(item)}\n                    ref={shouldUseStandardAnimation(item, index) ? transitionRootElement : undefined}\n                    transitionState={shouldUseStandardAnimation(item, index) ? state : undefined}\n                    i18nStrings={iconAriaLabels}\n                    {...item}\n                  />\n                )}\n              </li>\n            )}\n          </Transition>\n        ))}\n      </ListWrapper>\n    </ul>\n  );\n\n  return (\n    <div\n      {...baseProps}\n      className={clsx(\n        baseProps.className,\n        styles.flashbar,\n        styles[`breakpoint-${breakpoint}`],\n        styles.stack,\n        isCollapsible && styles.collapsible,\n        items.length === 2 && styles['short-list'],\n        isFlashbarStackExpanded && styles.expanded,\n        isVisualRefresh && styles['visual-refresh']\n      )}\n      ref={mergedRef}\n    >\n      {isFlashbarStackExpanded && renderList()}\n      {isCollapsible && (\n        <div\n          className={clsx(\n            styles['notification-bar'],\n            isVisualRefresh && styles['visual-refresh'],\n            isFlashbarStackExpanded ? styles.expanded : styles.collapsed,\n            transitioning && styles['animation-running'],\n            items.length === 2 && styles['short-list'],\n            getVisualContextClassname('flashbar') // Visual context is needed for focus ring to be white\n          )}\n          onClick={toggleCollapseExpand}\n          ref={notificationBarRef}\n        >\n          <span aria-live=\"polite\" className={styles.status} role=\"status\" id={itemCountElementId}>\n            {notificationBarText && <h2 className={styles.header}>{notificationBarText}</h2>}\n            <span className={styles['item-count']}>\n              {counterTypes.map(({ type, labelName, iconName }) => (\n                <NotificationTypeCount\n                  key={type}\n                  iconName={iconName}\n                  label={iconAriaLabels[labelName]}\n                  count={countByType[type]}\n                />\n              ))}\n            </span>\n          </span>\n          <button\n            aria-controls={flashbarElementId}\n            aria-describedby={itemCountElementId}\n            aria-expanded={isFlashbarStackExpanded}\n            aria-label={notificationBarAriaLabel}\n            className={clsx(styles.button, isFlashbarStackExpanded && styles.expanded)}\n          >\n            <InternalIcon className={styles.icon} size=\"normal\" name=\"angle-down\" />\n          </button>\n        </div>\n      )}\n      {!isFlashbarStackExpanded && renderList()}\n    </div>\n  );\n}\n\nconst NotificationTypeCount = ({\n  iconName,\n  label,\n  count,\n}: {\n  iconName: IconProps.Name;\n  label?: string;\n  count: number;\n}) => {\n  return (\n    <span className={styles['type-count']}>\n      <span aria-label={label} role=\"img\">\n        <span title={label} aria-hidden=\"true\">\n          <InternalIcon name={iconName} />\n        </span>\n      </span>\n      <span className={styles['count-number']}>{count}</span>\n    </span>\n  );\n};\n\nconst ListWrapper = ({ children, withMotion }: { children: ReactNode; withMotion: boolean }) =>\n  withMotion ? <TransitionGroup component={null}>{children}</TransitionGroup> : <>{children}</>;\n"]},"metadata":{},"sourceType":"module"}