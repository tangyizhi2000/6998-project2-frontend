{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/tangyizhi/Desktop/Assignment2/frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/tangyizhi/Desktop/Assignment2/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/tangyizhi/Desktop/Assignment2/frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { useEffect, useMemo } from 'react';\nimport { defaultIsSuppressed, findFocusinCell, moveFocusBy, muteElementFocusables, restoreElementFocusables, ensureSingleFocusable, getFirstFocusable } from './utils';\nimport { KeyCode } from '../../internal/keycode';\nimport { nodeContains } from '@cloudscape-design/component-toolkit/dom';\nimport { useStableCallback } from '@cloudscape-design/component-toolkit/internal';\n/**\n * Makes table navigable with keyboard commands.\n * See https://www.w3.org/WAI/ARIA/apg/patterns/grid\n *\n * The hook attaches the GridNavigationHelper helper when active=true.\n * See GridNavigationHelper for more details.\n */\nexport function useGridNavigation(_ref) {\n  var active = _ref.active,\n    pageSize = _ref.pageSize,\n    getTable = _ref.getTable,\n    isSuppressed = _ref.isSuppressed;\n  var gridNavigation = useMemo(function () {\n    return new GridNavigationHelper();\n  }, []);\n  var getTableStable = useStableCallback(getTable);\n  var isSuppressedStable = useStableCallback(function (element) {\n    var _a;\n    return (_a = isSuppressed === null || isSuppressed === void 0 ? void 0 : isSuppressed(element)) !== null && _a !== void 0 ? _a : false;\n  });\n  // Initialize the model with the table container assuming it is mounted synchronously and only once.\n  useEffect(function () {\n    if (active) {\n      var table = getTableStable();\n      table && gridNavigation.init(table, isSuppressedStable);\n    }\n    return function () {\n      return gridNavigation.cleanup();\n    };\n  }, [active, gridNavigation, getTableStable, isSuppressedStable]);\n  // Notify the model of the props change.\n  useEffect(function () {\n    gridNavigation.update({\n      pageSize: pageSize\n    });\n  }, [gridNavigation, pageSize]);\n}\n/**\n * This helper encapsulates the grid navigation behaviors which are:\n * 1. Responding to keyboard commands and moving the focus accordingly;\n * 2. Muting table interactive elements for only one to be user-focusable at a time;\n * 3. Suppressing the above behaviors when focusing an element inside a dialog or when instructed by the isSuppressed callback.\n *\n * All behaviors are attached upon initialization and are re-evaluated with every focusin, focusout, and keydown events,\n * and also when a node removal inside the table is observed to ensure consistency at any given moment.\n *\n * When the navigation is suppressed the keyboard commands are no longer intercepted and all table interactive elements are made\n * user-focusable to unblock the Tab navigation. The suppression should only be used for interactive elements inside the table that would\n * otherwise conflict with the navigation. Once the interactive element is deactivated or lose focus the table navigation becomes active again.\n */\nvar GridNavigationHelper = /*#__PURE__*/function () {\n  function GridNavigationHelper() {\n    var _this = this;\n    _classCallCheck(this, GridNavigationHelper);\n    // Props\n    this._pageSize = 0;\n    this._table = null;\n    this._isSuppressed = function () {\n      return false;\n    };\n    // State\n    this.prevFocusedCell = null;\n    this.focusedCell = null;\n    this.onFocusin = function (event) {\n      var _a;\n      var cell = findFocusinCell(event);\n      if (!cell) {\n        return;\n      }\n      _this.prevFocusedCell = cell;\n      _this.focusedCell = cell;\n      muteElementFocusables(_this.table, _this.isSuppressed(cell.element));\n      ensureSingleFocusable(_this.table, cell);\n      // Focusing on cell is not eligible when it contains focusable elements in the content.\n      // If content focusables are available - move the focus to the first one.\n      if (cell.element === cell.cellElement) {\n        (_a = getFirstFocusable(cell.cellElement)) === null || _a === void 0 ? void 0 : _a.focus();\n      }\n    };\n    this.onFocusout = function () {\n      _this.focusedCell = null;\n    };\n    this.onKeydown = function (event) {\n      if (!_this.focusedCell) {\n        return;\n      }\n      var ctrlKey = event.ctrlKey ? 1 : 0;\n      var altKey = event.altKey ? 1 : 0;\n      var shiftKey = event.shiftKey ? 1 : 0;\n      var metaKey = event.metaKey ? 1 : 0;\n      var numModifiersPressed = ctrlKey + altKey + shiftKey + metaKey;\n      var key = event.keyCode;\n      if (numModifiersPressed === 1 && event.ctrlKey) {\n        key = -key;\n      } else if (numModifiersPressed) {\n        return;\n      }\n      var from = _this.focusedCell;\n      var minExtreme = Number.NEGATIVE_INFINITY;\n      var maxExtreme = Number.POSITIVE_INFINITY;\n      // Do not intercept any keys when the navigation is suppressed.\n      if (_this.isSuppressed(from.element)) {\n        return;\n      }\n      switch (key) {\n        case KeyCode.up:\n          event.preventDefault();\n          return moveFocusBy(_this.table, from, {\n            y: -1,\n            x: 0\n          });\n        case KeyCode.down:\n          event.preventDefault();\n          return moveFocusBy(_this.table, from, {\n            y: 1,\n            x: 0\n          });\n        case KeyCode.left:\n          event.preventDefault();\n          return moveFocusBy(_this.table, from, {\n            y: 0,\n            x: -1\n          });\n        case KeyCode.right:\n          event.preventDefault();\n          return moveFocusBy(_this.table, from, {\n            y: 0,\n            x: 1\n          });\n        case KeyCode.pageUp:\n          event.preventDefault();\n          return moveFocusBy(_this.table, from, {\n            y: -_this.pageSize,\n            x: 0\n          });\n        case KeyCode.pageDown:\n          event.preventDefault();\n          return moveFocusBy(_this.table, from, {\n            y: _this.pageSize,\n            x: 0\n          });\n        case KeyCode.home:\n          event.preventDefault();\n          return moveFocusBy(_this.table, from, {\n            y: 0,\n            x: minExtreme\n          });\n        case KeyCode.end:\n          event.preventDefault();\n          return moveFocusBy(_this.table, from, {\n            y: 0,\n            x: maxExtreme\n          });\n        case -KeyCode.home:\n          event.preventDefault();\n          return moveFocusBy(_this.table, from, {\n            y: minExtreme,\n            x: minExtreme\n          });\n        case -KeyCode.end:\n          event.preventDefault();\n          return moveFocusBy(_this.table, from, {\n            y: maxExtreme,\n            x: maxExtreme\n          });\n        default:\n          return;\n      }\n    };\n    this.onTableNodeMutation = function (mutationRecords) {\n      var _a;\n      // When focused cell is un-mounted the focusout event handler removes this.cell,\n      // while this.prevFocusedCell is retained until the next focusin event.\n      var cell = (_a = _this.focusedCell) !== null && _a !== void 0 ? _a : _this.prevFocusedCell;\n      var cellSuppressed = cell ? _this.isSuppressed(cell.element) : false;\n      // Update table elements focus if new nodes were added.\n      if (mutationRecords.some(function (record) {\n        return record.addedNodes.length > 0;\n      })) {\n        muteElementFocusables(_this.table, cellSuppressed);\n        ensureSingleFocusable(_this.table, cell);\n      }\n      if (cell) {\n        var _iterator = _createForOfIteratorHelper(mutationRecords),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var record = _step.value;\n            if (record.type === 'childList') {\n              // The lost focus in an unmount event is reapplied to the table using the previous cell position.\n              // The moveFocusBy takes care of finding the closest position if the previous one no longer exists.\n              for (var _i = 0, _Array$from = Array.from(record.removedNodes); _i < _Array$from.length; _i++) {\n                var removedNode = _Array$from[_i];\n                if (removedNode === cell.element || nodeContains(removedNode, cell.element)) {\n                  ensureSingleFocusable(_this.table, cell);\n                  moveFocusBy(_this.table, cell, {\n                    y: 0,\n                    x: 0\n                  });\n                }\n              }\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n    };\n  }\n  _createClass(GridNavigationHelper, [{\n    key: \"init\",\n    value: function init(table, isSuppressed) {\n      var _this2 = this;\n      this._table = table;\n      this._isSuppressed = isSuppressed;\n      this.table.addEventListener('focusin', this.onFocusin);\n      this.table.addEventListener('focusout', this.onFocusout);\n      this.table.addEventListener('keydown', this.onKeydown);\n      var tableNodesObserver = new MutationObserver(this.onTableNodeMutation);\n      tableNodesObserver.observe(table, {\n        childList: true,\n        subtree: true\n      });\n      muteElementFocusables(this.table, false);\n      ensureSingleFocusable(this.table, null);\n      this.cleanup = function () {\n        _this2.table.removeEventListener('focusin', _this2.onFocusin);\n        _this2.table.removeEventListener('focusout', _this2.onFocusout);\n        _this2.table.removeEventListener('keydown', _this2.onKeydown);\n        tableNodesObserver.disconnect();\n        restoreElementFocusables(_this2.table);\n      };\n    }\n  }, {\n    key: \"cleanup\",\n    value: function cleanup() {\n      // Do nothing before initialized.\n    }\n  }, {\n    key: \"update\",\n    value: function update(_ref2) {\n      var pageSize = _ref2.pageSize;\n      this._pageSize = pageSize;\n    }\n  }, {\n    key: \"pageSize\",\n    get: function get() {\n      return this._pageSize;\n    }\n  }, {\n    key: \"table\",\n    get: function get() {\n      if (!this._table) {\n        throw new Error('Invariant violation: GridNavigationHelper is used before initialization.');\n      }\n      return this._table;\n    }\n  }, {\n    key: \"isSuppressed\",\n    value: function isSuppressed(focusedElement) {\n      return defaultIsSuppressed(focusedElement) || this._isSuppressed(focusedElement);\n    }\n  }]);\n  return GridNavigationHelper;\n}();","map":{"version":3,"mappings":"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","names":["useEffect","useMemo","defaultIsSuppressed","findFocusinCell","moveFocusBy","muteElementFocusables","restoreElementFocusables","ensureSingleFocusable","getFirstFocusable","KeyCode","nodeContains","useStableCallback","useGridNavigation","active","pageSize","getTable","isSuppressed","gridNavigation","GridNavigationHelper","getTableStable","isSuppressedStable","element","table","init","cleanup","update","event","cell","prevFocusedCell","focusedCell","cellElement","focus","ctrlKey","altKey","shiftKey","metaKey","numModifiersPressed","key","keyCode","from","minExtreme","Number","NEGATIVE_INFINITY","maxExtreme","POSITIVE_INFINITY","up","preventDefault","y","x","down","left","right","pageUp","pageDown","home","end","mutationRecords","cellSuppressed","some","record","addedNodes","length","type","Array","removedNodes","removedNode","_table","_isSuppressed","addEventListener","onFocusin","onFocusout","onKeydown","tableNodesObserver","MutationObserver","onTableNodeMutation","observe","childList","subtree","removeEventListener","disconnect","_pageSize","Error","focusedElement"],"sources":["/Users/tangyizhi/Desktop/Assignment2/frontend/node_modules/@cloudscape-design/components/table/table-role/lib/default/table/table-role/use-grid-navigation.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { useEffect, useMemo } from 'react';\nimport {\n  defaultIsSuppressed,\n  findFocusinCell,\n  moveFocusBy,\n  muteElementFocusables,\n  restoreElementFocusables,\n  ensureSingleFocusable,\n  getFirstFocusable,\n} from './utils';\nimport { FocusedCell, GridNavigationProps } from './interfaces';\nimport { KeyCode } from '../../internal/keycode';\nimport { nodeContains } from '@cloudscape-design/component-toolkit/dom';\nimport { useStableCallback } from '@cloudscape-design/component-toolkit/internal';\n\n/**\n * Makes table navigable with keyboard commands.\n * See https://www.w3.org/WAI/ARIA/apg/patterns/grid\n *\n * The hook attaches the GridNavigationHelper helper when active=true.\n * See GridNavigationHelper for more details.\n */\nexport function useGridNavigation({ active, pageSize, getTable, isSuppressed }: GridNavigationProps) {\n  const gridNavigation = useMemo(() => new GridNavigationHelper(), []);\n\n  const getTableStable = useStableCallback(getTable);\n  const isSuppressedStable = useStableCallback((element: HTMLElement) => isSuppressed?.(element) ?? false);\n\n  // Initialize the model with the table container assuming it is mounted synchronously and only once.\n  useEffect(() => {\n    if (active) {\n      const table = getTableStable();\n      table && gridNavigation.init(table, isSuppressedStable);\n    }\n    return () => gridNavigation.cleanup();\n  }, [active, gridNavigation, getTableStable, isSuppressedStable]);\n\n  // Notify the model of the props change.\n  useEffect(() => {\n    gridNavigation.update({ pageSize });\n  }, [gridNavigation, pageSize]);\n}\n\n/**\n * This helper encapsulates the grid navigation behaviors which are:\n * 1. Responding to keyboard commands and moving the focus accordingly;\n * 2. Muting table interactive elements for only one to be user-focusable at a time;\n * 3. Suppressing the above behaviors when focusing an element inside a dialog or when instructed by the isSuppressed callback.\n *\n * All behaviors are attached upon initialization and are re-evaluated with every focusin, focusout, and keydown events,\n * and also when a node removal inside the table is observed to ensure consistency at any given moment.\n *\n * When the navigation is suppressed the keyboard commands are no longer intercepted and all table interactive elements are made\n * user-focusable to unblock the Tab navigation. The suppression should only be used for interactive elements inside the table that would\n * otherwise conflict with the navigation. Once the interactive element is deactivated or lose focus the table navigation becomes active again.\n */\nclass GridNavigationHelper {\n  // Props\n  private _pageSize = 0;\n  private _table: null | HTMLTableElement = null;\n  private _isSuppressed: (focusedElement: HTMLElement) => boolean = () => false;\n\n  // State\n  private prevFocusedCell: null | FocusedCell = null;\n  private focusedCell: null | FocusedCell = null;\n\n  public init(table: HTMLTableElement, isSuppressed: (focusedElement: HTMLElement) => boolean) {\n    this._table = table;\n    this._isSuppressed = isSuppressed;\n\n    this.table.addEventListener('focusin', this.onFocusin);\n    this.table.addEventListener('focusout', this.onFocusout);\n    this.table.addEventListener('keydown', this.onKeydown);\n\n    const tableNodesObserver = new MutationObserver(this.onTableNodeMutation);\n    tableNodesObserver.observe(table, { childList: true, subtree: true });\n\n    muteElementFocusables(this.table, false);\n    ensureSingleFocusable(this.table, null);\n\n    this.cleanup = () => {\n      this.table.removeEventListener('focusin', this.onFocusin);\n      this.table.removeEventListener('focusout', this.onFocusout);\n      this.table.removeEventListener('keydown', this.onKeydown);\n\n      tableNodesObserver.disconnect();\n\n      restoreElementFocusables(this.table);\n    };\n  }\n\n  public cleanup() {\n    // Do nothing before initialized.\n  }\n\n  public update({ pageSize }: { pageSize: number }) {\n    this._pageSize = pageSize;\n  }\n\n  private get pageSize() {\n    return this._pageSize;\n  }\n\n  private get table(): HTMLTableElement {\n    if (!this._table) {\n      throw new Error('Invariant violation: GridNavigationHelper is used before initialization.');\n    }\n    return this._table;\n  }\n\n  private isSuppressed(focusedElement: HTMLElement): boolean {\n    return defaultIsSuppressed(focusedElement) || this._isSuppressed(focusedElement);\n  }\n\n  private onFocusin = (event: FocusEvent) => {\n    const cell = findFocusinCell(event);\n    if (!cell) {\n      return;\n    }\n\n    this.prevFocusedCell = cell;\n    this.focusedCell = cell;\n\n    muteElementFocusables(this.table, this.isSuppressed(cell.element));\n    ensureSingleFocusable(this.table, cell);\n\n    // Focusing on cell is not eligible when it contains focusable elements in the content.\n    // If content focusables are available - move the focus to the first one.\n    if (cell.element === cell.cellElement) {\n      getFirstFocusable(cell.cellElement)?.focus();\n    }\n  };\n\n  private onFocusout = () => {\n    this.focusedCell = null;\n  };\n\n  private onKeydown = (event: KeyboardEvent) => {\n    if (!this.focusedCell) {\n      return;\n    }\n\n    const ctrlKey = event.ctrlKey ? 1 : 0;\n    const altKey = event.altKey ? 1 : 0;\n    const shiftKey = event.shiftKey ? 1 : 0;\n    const metaKey = event.metaKey ? 1 : 0;\n    const numModifiersPressed = ctrlKey + altKey + shiftKey + metaKey;\n\n    let key = event.keyCode;\n    if (numModifiersPressed === 1 && event.ctrlKey) {\n      key = -key;\n    } else if (numModifiersPressed) {\n      return;\n    }\n\n    const from = this.focusedCell;\n    const minExtreme = Number.NEGATIVE_INFINITY;\n    const maxExtreme = Number.POSITIVE_INFINITY;\n\n    // Do not intercept any keys when the navigation is suppressed.\n    if (this.isSuppressed(from.element)) {\n      return;\n    }\n\n    switch (key) {\n      case KeyCode.up:\n        event.preventDefault();\n        return moveFocusBy(this.table, from, { y: -1, x: 0 });\n\n      case KeyCode.down:\n        event.preventDefault();\n        return moveFocusBy(this.table, from, { y: 1, x: 0 });\n\n      case KeyCode.left:\n        event.preventDefault();\n        return moveFocusBy(this.table, from, { y: 0, x: -1 });\n\n      case KeyCode.right:\n        event.preventDefault();\n        return moveFocusBy(this.table, from, { y: 0, x: 1 });\n\n      case KeyCode.pageUp:\n        event.preventDefault();\n        return moveFocusBy(this.table, from, { y: -this.pageSize, x: 0 });\n\n      case KeyCode.pageDown:\n        event.preventDefault();\n        return moveFocusBy(this.table, from, { y: this.pageSize, x: 0 });\n\n      case KeyCode.home:\n        event.preventDefault();\n        return moveFocusBy(this.table, from, { y: 0, x: minExtreme });\n\n      case KeyCode.end:\n        event.preventDefault();\n        return moveFocusBy(this.table, from, { y: 0, x: maxExtreme });\n\n      case -KeyCode.home:\n        event.preventDefault();\n        return moveFocusBy(this.table, from, { y: minExtreme, x: minExtreme });\n\n      case -KeyCode.end:\n        event.preventDefault();\n        return moveFocusBy(this.table, from, { y: maxExtreme, x: maxExtreme });\n\n      default:\n        return;\n    }\n  };\n\n  private onTableNodeMutation = (mutationRecords: MutationRecord[]) => {\n    // When focused cell is un-mounted the focusout event handler removes this.cell,\n    // while this.prevFocusedCell is retained until the next focusin event.\n    const cell = this.focusedCell ?? this.prevFocusedCell;\n    const cellSuppressed = cell ? this.isSuppressed(cell.element) : false;\n\n    // Update table elements focus if new nodes were added.\n    if (mutationRecords.some(record => record.addedNodes.length > 0)) {\n      muteElementFocusables(this.table, cellSuppressed);\n      ensureSingleFocusable(this.table, cell);\n    }\n\n    if (cell) {\n      for (const record of mutationRecords) {\n        if (record.type === 'childList') {\n          // The lost focus in an unmount event is reapplied to the table using the previous cell position.\n          // The moveFocusBy takes care of finding the closest position if the previous one no longer exists.\n          for (const removedNode of Array.from(record.removedNodes)) {\n            if (removedNode === cell.element || nodeContains(removedNode, cell.element)) {\n              ensureSingleFocusable(this.table, cell);\n              moveFocusBy(this.table, cell, { y: 0, x: 0 });\n            }\n          }\n        }\n      }\n    }\n  };\n}\n"]},"metadata":{},"sourceType":"module"}