{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { useCallback, useEffect, useMemo, useRef } from 'react';\nimport AsyncStore from '../../area-chart/async-store';\nimport clsx from 'clsx';\nimport { useResizeObserver, useStableCallback } from '@cloudscape-design/component-toolkit/internal';\nimport { isCellStatesEqual, isWrapperStatesEqual, updateCellOffsets } from './utils';\n// We allow the table to have a minimum of 148px of available space besides the sum of the widths of the sticky columns\n// This value is an UX recommendation and is approximately 1/3 of our smallest breakpoint (465px)\nconst MINIMUM_SCROLLABLE_SPACE = 148;\nexport function useStickyColumns(_ref) {\n  let {\n    visibleColumns,\n    stickyColumnsFirst,\n    stickyColumnsLast\n  } = _ref;\n  const store = useMemo(() => new StickyColumnsStore(), []);\n  const wrapperRef = useRef(null);\n  const tableRef = useRef(null);\n  const cellsRef = useRef({});\n  const hasStickyColumns = stickyColumnsFirst + stickyColumnsLast > 0;\n  const updateStickyStyles = useStableCallback(() => {\n    if (wrapperRef.current && tableRef.current) {\n      store.updateCellStyles({\n        wrapper: wrapperRef.current,\n        table: tableRef.current,\n        cells: cellsRef.current,\n        visibleColumns,\n        stickyColumnsFirst,\n        stickyColumnsLast\n      });\n    }\n  });\n  useResizeObserver(wrapperRef, updateStickyStyles);\n  useResizeObserver(tableRef, updateStickyStyles);\n  useEffect(() => {\n    if (wrapperRef.current && tableRef.current) {\n      store.updateCellStyles({\n        wrapper: wrapperRef.current,\n        table: tableRef.current,\n        cells: cellsRef.current,\n        visibleColumns,\n        stickyColumnsFirst,\n        stickyColumnsLast\n      });\n    }\n  }, [store, stickyColumnsFirst, stickyColumnsLast, visibleColumns]);\n  // Update wrapper styles imperatively to avoid unnecessary re-renders.\n  useEffect(() => {\n    if (!hasStickyColumns) {\n      return;\n    }\n    const selector = state => state.wrapperState;\n    const updateWrapperStyles = (state, prev) => {\n      if (isWrapperStatesEqual(state, prev)) {\n        return;\n      }\n      if (wrapperRef.current) {\n        wrapperRef.current.style.scrollPaddingLeft = state.scrollPaddingLeft + 'px';\n        wrapperRef.current.style.scrollPaddingRight = state.scrollPaddingRight + 'px';\n      }\n    };\n    const unsubscribe = store.subscribe(selector, (newState, prevState) => updateWrapperStyles(selector(newState), selector(prevState)));\n    return unsubscribe;\n  }, [store, hasStickyColumns]);\n  const setWrapper = useCallback(node => {\n    if (wrapperRef.current) {\n      wrapperRef.current.removeEventListener('scroll', updateStickyStyles);\n    }\n    if (node && hasStickyColumns) {\n      node.addEventListener('scroll', updateStickyStyles);\n    }\n    wrapperRef.current = node;\n  }, [hasStickyColumns, updateStickyStyles]);\n  const setTable = useCallback(node => {\n    tableRef.current = node;\n  }, []);\n  const setCell = useCallback((columnId, node) => {\n    if (node) {\n      cellsRef.current[columnId] = node;\n    } else {\n      delete cellsRef.current[columnId];\n    }\n  }, []);\n  return {\n    store,\n    style: {\n      // Provide wrapper styles as props so that a re-render won't cause invalidation.\n      wrapper: hasStickyColumns ? Object.assign({}, store.get().wrapperState) : undefined\n    },\n    refs: {\n      wrapper: setWrapper,\n      table: setTable,\n      cell: setCell\n    }\n  };\n}\nexport function useStickyCellStyles(_ref2) {\n  let {\n    stickyColumns,\n    columnId,\n    getClassName\n  } = _ref2;\n  var _a;\n  const setCell = stickyColumns.refs.cell;\n  // unsubscribeRef to hold the function to unsubscribe from the store's updates\n  const unsubscribeRef = useRef(null);\n  // refCallback updates the cell ref and sets up the store subscription\n  const refCallback = useCallback(cellElement => {\n    if (unsubscribeRef.current) {\n      // Unsubscribe before we do any updates to avoid leaving any subscriptions hanging\n      unsubscribeRef.current();\n    }\n    // Update cellRef and the store's state to point to the new DOM node\n    setCell(columnId, cellElement);\n    // Update cell styles imperatively to avoid unnecessary re-renders.\n    const selector = state => state.cellState[columnId];\n    const updateCellStyles = (state, prev) => {\n      if (isCellStatesEqual(state, prev)) {\n        return;\n      }\n      const className = getClassName(state);\n      if (cellElement) {\n        Object.keys(className).forEach(key => {\n          if (className[key]) {\n            cellElement.classList.add(key);\n          } else {\n            cellElement.classList.remove(key);\n          }\n        });\n        cellElement.style.left = (state === null || state === void 0 ? void 0 : state.offset.left) !== undefined ? `${state.offset.left}px` : '';\n        cellElement.style.right = (state === null || state === void 0 ? void 0 : state.offset.right) !== undefined ? `${state.offset.right}px` : '';\n      }\n    };\n    // If the node is not null (i.e., the table cell is being mounted or updated, not unmounted),\n    // set up a new subscription to the store's updates\n    if (cellElement) {\n      unsubscribeRef.current = stickyColumns.store.subscribe(selector, (newState, prevState) => {\n        updateCellStyles(selector(newState), selector(prevState));\n      });\n    }\n  },\n  // getClassName is expected to be pure\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  [columnId, setCell, stickyColumns.store]);\n  // Provide cell styles as props so that a re-render won't cause invalidation.\n  const cellStyles = stickyColumns.store.get().cellState[columnId];\n  return {\n    ref: refCallback,\n    className: cellStyles ? clsx(getClassName(cellStyles)) : undefined,\n    style: (_a = cellStyles === null || cellStyles === void 0 ? void 0 : cellStyles.offset) !== null && _a !== void 0 ? _a : undefined\n  };\n}\nexport default class StickyColumnsStore extends AsyncStore {\n  constructor() {\n    super({\n      cellState: {},\n      wrapperState: {\n        scrollPaddingLeft: 0,\n        scrollPaddingRight: 0\n      }\n    });\n    this.cellOffsets = {\n      offsets: new Map(),\n      stickyWidthLeft: 0,\n      stickyWidthRight: 0\n    };\n    this.isStuckToTheLeft = false;\n    this.isStuckToTheRight = false;\n    this.padLeft = false;\n    this.generateCellStyles = props => {\n      const isEnabled = this.isEnabled(props);\n      const lastLeftStickyColumnIndex = props.stickyColumnsFirst - 1;\n      const lastRightStickyColumnIndex = props.visibleColumns.length - props.stickyColumnsLast;\n      return props.visibleColumns.reduce((acc, columnId, index) => {\n        var _a, _b, _c, _d;\n        let stickySide = 'non-sticky';\n        if (index < props.stickyColumnsFirst) {\n          stickySide = 'left';\n        } else if (index >= props.visibleColumns.length - props.stickyColumnsLast) {\n          stickySide = 'right';\n        }\n        if (!isEnabled || stickySide === 'non-sticky') {\n          acc[columnId] = null;\n          return acc;\n        }\n        // Determine the offset of the sticky column using the `cellOffsets` state object\n        const isFirstColumn = index === 0;\n        const stickyColumnOffsetLeft = (_b = (_a = this.cellOffsets.offsets.get(columnId)) === null || _a === void 0 ? void 0 : _a.first) !== null && _b !== void 0 ? _b : 0;\n        const stickyColumnOffsetRight = (_d = (_c = this.cellOffsets.offsets.get(columnId)) === null || _c === void 0 ? void 0 : _c.last) !== null && _d !== void 0 ? _d : 0;\n        acc[columnId] = {\n          padLeft: isFirstColumn && this.padLeft,\n          lastLeft: this.isStuckToTheLeft && lastLeftStickyColumnIndex === index,\n          lastRight: this.isStuckToTheRight && lastRightStickyColumnIndex === index,\n          offset: {\n            left: stickySide === 'left' ? stickyColumnOffsetLeft : undefined,\n            right: stickySide === 'right' ? stickyColumnOffsetRight : undefined\n          }\n        };\n        return acc;\n      }, {});\n    };\n    this.updateCellOffsets = props => {\n      this.cellOffsets = updateCellOffsets(props.cells, props);\n    };\n    this.isEnabled = props => {\n      const noStickyColumns = props.stickyColumnsFirst + props.stickyColumnsLast === 0;\n      if (noStickyColumns) {\n        return false;\n      }\n      const wrapperWidth = props.wrapper.getBoundingClientRect().width;\n      const tableWidth = props.table.getBoundingClientRect().width;\n      const isWrapperScrollable = tableWidth > wrapperWidth;\n      if (!isWrapperScrollable) {\n        return false;\n      }\n      const totalStickySpace = this.cellOffsets.stickyWidthLeft + this.cellOffsets.stickyWidthRight;\n      const tablePaddingLeft = parseFloat(getComputedStyle(props.table).paddingLeft) || 0;\n      const tablePaddingRight = parseFloat(getComputedStyle(props.table).paddingRight) || 0;\n      const hasEnoughScrollableSpace = totalStickySpace + MINIMUM_SCROLLABLE_SPACE + tablePaddingLeft + tablePaddingRight < wrapperWidth;\n      if (!hasEnoughScrollableSpace) {\n        return false;\n      }\n      return true;\n    };\n  }\n  updateCellStyles(props) {\n    const hasStickyColumns = props.stickyColumnsFirst + props.stickyColumnsLast > 0;\n    const hadStickyColumns = this.cellOffsets.offsets.size > 0;\n    if (hasStickyColumns || hadStickyColumns) {\n      this.updateScroll(props);\n      this.updateCellOffsets(props);\n      this.set(() => ({\n        cellState: this.generateCellStyles(props),\n        wrapperState: {\n          scrollPaddingLeft: this.cellOffsets.stickyWidthLeft,\n          scrollPaddingRight: this.cellOffsets.stickyWidthRight\n        }\n      }));\n    }\n  }\n  updateScroll(props) {\n    const wrapperScrollLeft = props.wrapper.scrollLeft;\n    const wrapperScrollWidth = props.wrapper.scrollWidth;\n    const wrapperClientWidth = props.wrapper.clientWidth;\n    const tablePaddingLeft = parseFloat(getComputedStyle(props.table).paddingLeft) || 0;\n    const tablePaddingRight = parseFloat(getComputedStyle(props.table).paddingRight) || 0;\n    this.isStuckToTheLeft = wrapperScrollLeft > tablePaddingLeft;\n    // Math.ceil() is used here to address an edge-case in certain browsers, where they return non-integer wrapperScrollLeft values\n    // which are lower than expected (sub-pixel difference), resulting in the table always being in the \"stuck to the right\" state\n    this.isStuckToTheRight = Math.ceil(wrapperScrollLeft) < wrapperScrollWidth - wrapperClientWidth - tablePaddingRight;\n    this.padLeft = tablePaddingLeft !== 0 && this.isStuckToTheLeft;\n  }\n}","map":{"version":3,"mappings":"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","names":["useCallback","useEffect","useMemo","useRef","AsyncStore","clsx","useResizeObserver","useStableCallback","isCellStatesEqual","isWrapperStatesEqual","updateCellOffsets","MINIMUM_SCROLLABLE_SPACE","useStickyColumns","visibleColumns","stickyColumnsFirst","stickyColumnsLast","store","StickyColumnsStore","wrapperRef","tableRef","cellsRef","hasStickyColumns","updateStickyStyles","current","updateCellStyles","wrapper","table","cells","selector","state","wrapperState","updateWrapperStyles","prev","style","scrollPaddingLeft","scrollPaddingRight","unsubscribe","subscribe","newState","prevState","setWrapper","node","removeEventListener","addEventListener","setTable","setCell","columnId","Object","get","undefined","refs","cell","useStickyCellStyles","stickyColumns","getClassName","unsubscribeRef","refCallback","cellElement","cellState","className","keys","forEach","key","classList","add","remove","left","offset","right","cellStyles","ref","constructor","offsets","Map","stickyWidthLeft","stickyWidthRight","props","isEnabled","lastLeftStickyColumnIndex","lastRightStickyColumnIndex","length","reduce","acc","index","stickySide","isFirstColumn","stickyColumnOffsetLeft","cellOffsets","first","stickyColumnOffsetRight","last","padLeft","lastLeft","isStuckToTheLeft","lastRight","isStuckToTheRight","noStickyColumns","wrapperWidth","getBoundingClientRect","width","tableWidth","isWrapperScrollable","totalStickySpace","tablePaddingLeft","parseFloat","getComputedStyle","paddingLeft","tablePaddingRight","paddingRight","hasEnoughScrollableSpace","hadStickyColumns","size","updateScroll","set","generateCellStyles","wrapperScrollLeft","scrollLeft","wrapperScrollWidth","scrollWidth","wrapperClientWidth","clientWidth","Math","ceil"],"sources":["/Users/tangyizhi/Desktop/Assignment 2/frontend/node_modules/@cloudscape-design/components/table/sticky-columns/lib/default/table/sticky-columns/use-sticky-columns.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport React, { useCallback, useEffect, useMemo, useRef } from 'react';\nimport AsyncStore, { ReadonlyAsyncStore } from '../../area-chart/async-store';\nimport clsx from 'clsx';\nimport { useResizeObserver, useStableCallback } from '@cloudscape-design/component-toolkit/internal';\nimport {\n  CellOffsets,\n  StickyColumnsCellState,\n  StickyColumnsProps,\n  StickyColumnsState,\n  StickyColumnsWrapperState,\n} from './interfaces';\nimport { isCellStatesEqual, isWrapperStatesEqual, updateCellOffsets } from './utils';\n\n// We allow the table to have a minimum of 148px of available space besides the sum of the widths of the sticky columns\n// This value is an UX recommendation and is approximately 1/3 of our smallest breakpoint (465px)\nconst MINIMUM_SCROLLABLE_SPACE = 148;\n\nexport interface StickyColumnsModel {\n  store: ReadonlyAsyncStore<StickyColumnsState>;\n  style: {\n    wrapper?: React.CSSProperties;\n  };\n  refs: {\n    table: React.RefCallback<HTMLElement>;\n    wrapper: React.RefCallback<HTMLElement>;\n    cell: (columnId: PropertyKey, node: null | HTMLElement) => void;\n  };\n}\n\nexport function useStickyColumns({\n  visibleColumns,\n  stickyColumnsFirst,\n  stickyColumnsLast,\n}: StickyColumnsProps): StickyColumnsModel {\n  const store = useMemo(() => new StickyColumnsStore(), []);\n  const wrapperRef = useRef<HTMLElement>(null) as React.MutableRefObject<null | HTMLElement>;\n  const tableRef = useRef<HTMLElement>(null) as React.MutableRefObject<null | HTMLElement>;\n  const cellsRef = useRef<Record<PropertyKey, HTMLElement>>({});\n\n  const hasStickyColumns = stickyColumnsFirst + stickyColumnsLast > 0;\n\n  const updateStickyStyles = useStableCallback(() => {\n    if (wrapperRef.current && tableRef.current) {\n      store.updateCellStyles({\n        wrapper: wrapperRef.current,\n        table: tableRef.current,\n        cells: cellsRef.current,\n        visibleColumns,\n        stickyColumnsFirst,\n        stickyColumnsLast,\n      });\n    }\n  });\n\n  useResizeObserver(wrapperRef, updateStickyStyles);\n\n  useResizeObserver(tableRef, updateStickyStyles);\n\n  useEffect(() => {\n    if (wrapperRef.current && tableRef.current) {\n      store.updateCellStyles({\n        wrapper: wrapperRef.current,\n        table: tableRef.current,\n        cells: cellsRef.current,\n        visibleColumns,\n        stickyColumnsFirst,\n        stickyColumnsLast,\n      });\n    }\n  }, [store, stickyColumnsFirst, stickyColumnsLast, visibleColumns]);\n\n  // Update wrapper styles imperatively to avoid unnecessary re-renders.\n  useEffect(() => {\n    if (!hasStickyColumns) {\n      return;\n    }\n\n    const selector = (state: StickyColumnsState) => state.wrapperState;\n\n    const updateWrapperStyles = (state: StickyColumnsWrapperState, prev: StickyColumnsWrapperState) => {\n      if (isWrapperStatesEqual(state, prev)) {\n        return;\n      }\n\n      if (wrapperRef.current) {\n        wrapperRef.current.style.scrollPaddingLeft = state.scrollPaddingLeft + 'px';\n        wrapperRef.current.style.scrollPaddingRight = state.scrollPaddingRight + 'px';\n      }\n    };\n\n    const unsubscribe = store.subscribe(selector, (newState, prevState) =>\n      updateWrapperStyles(selector(newState), selector(prevState))\n    );\n    return unsubscribe;\n  }, [store, hasStickyColumns]);\n\n  const setWrapper = useCallback(\n    (node: null | HTMLElement) => {\n      if (wrapperRef.current) {\n        wrapperRef.current.removeEventListener('scroll', updateStickyStyles);\n      }\n      if (node && hasStickyColumns) {\n        node.addEventListener('scroll', updateStickyStyles);\n      }\n      wrapperRef.current = node;\n    },\n    [hasStickyColumns, updateStickyStyles]\n  );\n\n  const setTable = useCallback((node: null | HTMLElement) => {\n    tableRef.current = node;\n  }, []);\n\n  const setCell = useCallback((columnId: PropertyKey, node: null | HTMLElement) => {\n    if (node) {\n      cellsRef.current[columnId] = node;\n    } else {\n      delete cellsRef.current[columnId];\n    }\n  }, []);\n\n  return {\n    store,\n    style: {\n      // Provide wrapper styles as props so that a re-render won't cause invalidation.\n      wrapper: hasStickyColumns ? { ...store.get().wrapperState } : undefined,\n    },\n    refs: { wrapper: setWrapper, table: setTable, cell: setCell },\n  };\n}\n\ninterface UseStickyCellStylesProps {\n  stickyColumns: StickyColumnsModel;\n  columnId: PropertyKey;\n  getClassName: (styles: null | StickyColumnsCellState) => Record<string, boolean>;\n}\n\ninterface StickyCellStyles {\n  ref: React.RefCallback<HTMLElement>;\n  className?: string;\n  style?: React.CSSProperties;\n}\n\nexport function useStickyCellStyles({\n  stickyColumns,\n  columnId,\n  getClassName,\n}: UseStickyCellStylesProps): StickyCellStyles {\n  const setCell = stickyColumns.refs.cell;\n\n  // unsubscribeRef to hold the function to unsubscribe from the store's updates\n  const unsubscribeRef = useRef<null | (() => void)>(null);\n\n  // refCallback updates the cell ref and sets up the store subscription\n  const refCallback = useCallback(\n    cellElement => {\n      if (unsubscribeRef.current) {\n        // Unsubscribe before we do any updates to avoid leaving any subscriptions hanging\n        unsubscribeRef.current();\n      }\n\n      // Update cellRef and the store's state to point to the new DOM node\n      setCell(columnId, cellElement);\n\n      // Update cell styles imperatively to avoid unnecessary re-renders.\n      const selector = (state: StickyColumnsState) => state.cellState[columnId];\n\n      const updateCellStyles = (state: null | StickyColumnsCellState, prev: null | StickyColumnsCellState) => {\n        if (isCellStatesEqual(state, prev)) {\n          return;\n        }\n\n        const className = getClassName(state);\n        if (cellElement) {\n          Object.keys(className).forEach(key => {\n            if (className[key]) {\n              cellElement.classList.add(key);\n            } else {\n              cellElement.classList.remove(key);\n            }\n          });\n          cellElement.style.left = state?.offset.left !== undefined ? `${state.offset.left}px` : '';\n          cellElement.style.right = state?.offset.right !== undefined ? `${state.offset.right}px` : '';\n        }\n      };\n\n      // If the node is not null (i.e., the table cell is being mounted or updated, not unmounted),\n      // set up a new subscription to the store's updates\n      if (cellElement) {\n        unsubscribeRef.current = stickyColumns.store.subscribe(selector, (newState, prevState) => {\n          updateCellStyles(selector(newState), selector(prevState));\n        });\n      }\n    },\n\n    // getClassName is expected to be pure\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [columnId, setCell, stickyColumns.store]\n  );\n\n  // Provide cell styles as props so that a re-render won't cause invalidation.\n  const cellStyles = stickyColumns.store.get().cellState[columnId];\n  return {\n    ref: refCallback,\n    className: cellStyles ? clsx(getClassName(cellStyles)) : undefined,\n    style: cellStyles?.offset ?? undefined,\n  };\n}\n\ninterface UpdateCellStylesProps {\n  wrapper: HTMLElement;\n  table: HTMLElement;\n  cells: Record<PropertyKey, HTMLElement>;\n  visibleColumns: readonly PropertyKey[];\n  stickyColumnsFirst: number;\n  stickyColumnsLast: number;\n}\n\nexport default class StickyColumnsStore extends AsyncStore<StickyColumnsState> {\n  private cellOffsets: CellOffsets = {\n    offsets: new Map(),\n    stickyWidthLeft: 0,\n    stickyWidthRight: 0,\n  };\n  private isStuckToTheLeft = false;\n  private isStuckToTheRight = false;\n  private padLeft = false;\n\n  constructor() {\n    super({ cellState: {}, wrapperState: { scrollPaddingLeft: 0, scrollPaddingRight: 0 } });\n  }\n\n  public updateCellStyles(props: UpdateCellStylesProps) {\n    const hasStickyColumns = props.stickyColumnsFirst + props.stickyColumnsLast > 0;\n    const hadStickyColumns = this.cellOffsets.offsets.size > 0;\n\n    if (hasStickyColumns || hadStickyColumns) {\n      this.updateScroll(props);\n      this.updateCellOffsets(props);\n      this.set(() => ({\n        cellState: this.generateCellStyles(props),\n        wrapperState: {\n          scrollPaddingLeft: this.cellOffsets.stickyWidthLeft,\n          scrollPaddingRight: this.cellOffsets.stickyWidthRight,\n        },\n      }));\n    }\n  }\n\n  private updateScroll(props: UpdateCellStylesProps) {\n    const wrapperScrollLeft = props.wrapper.scrollLeft;\n    const wrapperScrollWidth = props.wrapper.scrollWidth;\n    const wrapperClientWidth = props.wrapper.clientWidth;\n    const tablePaddingLeft = parseFloat(getComputedStyle(props.table).paddingLeft) || 0;\n    const tablePaddingRight = parseFloat(getComputedStyle(props.table).paddingRight) || 0;\n\n    this.isStuckToTheLeft = wrapperScrollLeft > tablePaddingLeft;\n\n    // Math.ceil() is used here to address an edge-case in certain browsers, where they return non-integer wrapperScrollLeft values\n    // which are lower than expected (sub-pixel difference), resulting in the table always being in the \"stuck to the right\" state\n    this.isStuckToTheRight = Math.ceil(wrapperScrollLeft) < wrapperScrollWidth - wrapperClientWidth - tablePaddingRight;\n\n    this.padLeft = tablePaddingLeft !== 0 && this.isStuckToTheLeft;\n  }\n\n  private generateCellStyles = (props: UpdateCellStylesProps): Record<PropertyKey, null | StickyColumnsCellState> => {\n    const isEnabled = this.isEnabled(props);\n    const lastLeftStickyColumnIndex = props.stickyColumnsFirst - 1;\n    const lastRightStickyColumnIndex = props.visibleColumns.length - props.stickyColumnsLast;\n\n    return props.visibleColumns.reduce((acc, columnId, index) => {\n      let stickySide = 'non-sticky';\n      if (index < props.stickyColumnsFirst) {\n        stickySide = 'left';\n      } else if (index >= props.visibleColumns.length - props.stickyColumnsLast) {\n        stickySide = 'right';\n      }\n\n      if (!isEnabled || stickySide === 'non-sticky') {\n        acc[columnId] = null;\n        return acc;\n      }\n\n      // Determine the offset of the sticky column using the `cellOffsets` state object\n      const isFirstColumn = index === 0;\n      const stickyColumnOffsetLeft = this.cellOffsets.offsets.get(columnId)?.first ?? 0;\n      const stickyColumnOffsetRight = this.cellOffsets.offsets.get(columnId)?.last ?? 0;\n\n      acc[columnId] = {\n        padLeft: isFirstColumn && this.padLeft,\n        lastLeft: this.isStuckToTheLeft && lastLeftStickyColumnIndex === index,\n        lastRight: this.isStuckToTheRight && lastRightStickyColumnIndex === index,\n        offset: {\n          left: stickySide === 'left' ? stickyColumnOffsetLeft : undefined,\n          right: stickySide === 'right' ? stickyColumnOffsetRight : undefined,\n        },\n      };\n      return acc;\n    }, {} as Record<PropertyKey, null | StickyColumnsCellState>);\n  };\n\n  private updateCellOffsets = (props: UpdateCellStylesProps): void => {\n    this.cellOffsets = updateCellOffsets(props.cells, props);\n  };\n\n  private isEnabled = (props: UpdateCellStylesProps): boolean => {\n    const noStickyColumns = props.stickyColumnsFirst + props.stickyColumnsLast === 0;\n    if (noStickyColumns) {\n      return false;\n    }\n\n    const wrapperWidth = props.wrapper.getBoundingClientRect().width;\n    const tableWidth = props.table.getBoundingClientRect().width;\n    const isWrapperScrollable = tableWidth > wrapperWidth;\n    if (!isWrapperScrollable) {\n      return false;\n    }\n\n    const totalStickySpace = this.cellOffsets.stickyWidthLeft + this.cellOffsets.stickyWidthRight;\n    const tablePaddingLeft = parseFloat(getComputedStyle(props.table).paddingLeft) || 0;\n    const tablePaddingRight = parseFloat(getComputedStyle(props.table).paddingRight) || 0;\n    const hasEnoughScrollableSpace =\n      totalStickySpace + MINIMUM_SCROLLABLE_SPACE + tablePaddingLeft + tablePaddingRight < wrapperWidth;\n    if (!hasEnoughScrollableSpace) {\n      return false;\n    }\n\n    return true;\n  };\n}\n"]},"metadata":{},"sourceType":"module"}