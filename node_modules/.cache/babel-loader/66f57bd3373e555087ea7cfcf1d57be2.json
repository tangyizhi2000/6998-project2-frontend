{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { canUseDOM, subtract as getCoordinatesDelta } from '@dnd-kit/utilities';\nimport { KeyboardCode } from '@dnd-kit/core';\nfunction isDocumentScrollingElement(element) {\n  if (!canUseDOM || !element) {\n    return false;\n  }\n  return element === document.scrollingElement;\n}\nexport function getScrollPosition(scrollingContainer) {\n  const minScroll = {\n    x: 0,\n    y: 0\n  };\n  const dimensions = isDocumentScrollingElement(scrollingContainer) ? {\n    height: window.innerHeight,\n    width: window.innerWidth\n  } : {\n    height: scrollingContainer.clientHeight,\n    width: scrollingContainer.clientWidth\n  };\n  const maxScroll = {\n    x: scrollingContainer.scrollWidth - dimensions.width,\n    y: scrollingContainer.scrollHeight - dimensions.height\n  };\n  const isTop = scrollingContainer.scrollTop <= minScroll.y;\n  const isLeft = scrollingContainer.scrollLeft <= minScroll.x;\n  const isBottom = scrollingContainer.scrollTop >= maxScroll.y;\n  const isRight = scrollingContainer.scrollLeft >= maxScroll.x;\n  return {\n    isTop,\n    isLeft,\n    isBottom,\n    isRight,\n    maxScroll,\n    minScroll\n  };\n}\nexport function getScrollElementRect(element) {\n  if (element === document.scrollingElement) {\n    const {\n      innerWidth,\n      innerHeight\n    } = window;\n    return {\n      top: 0,\n      left: 0,\n      right: innerWidth,\n      bottom: innerHeight,\n      width: innerWidth,\n      height: innerHeight\n    };\n  }\n  const {\n    top,\n    left,\n    right,\n    bottom\n  } = element.getBoundingClientRect();\n  return {\n    top,\n    left,\n    right,\n    bottom,\n    width: element.clientWidth,\n    height: element.clientHeight\n  };\n}\nexport function applyScroll(_ref) {\n  let {\n    currentCoordinates,\n    direction,\n    newCoordinates,\n    scrollableAncestors\n  } = _ref;\n  for (const scrollContainer of scrollableAncestors) {\n    const coordinatesDelta = getCoordinatesDelta(newCoordinates, currentCoordinates);\n    const {\n      isTop,\n      isBottom,\n      maxScroll,\n      minScroll\n    } = getScrollPosition(scrollContainer);\n    const scrollElementRect = getScrollElementRect(scrollContainer);\n    const clampedCoordinates = {\n      y: Math.min(direction === KeyboardCode.Down ? scrollElementRect.bottom - scrollElementRect.height / 2 : scrollElementRect.bottom, Math.max(direction === KeyboardCode.Down ? scrollElementRect.top : scrollElementRect.top + scrollElementRect.height / 2, newCoordinates.y))\n    };\n    const canScrollY = direction === KeyboardCode.Down && !isBottom || direction === KeyboardCode.Up && !isTop;\n    if (canScrollY && clampedCoordinates.y !== newCoordinates.y) {\n      const newScrollCoordinates = scrollContainer.scrollTop + coordinatesDelta.y;\n      const canScrollToNewCoordinates = direction === KeyboardCode.Down && newScrollCoordinates <= maxScroll.y || direction === KeyboardCode.Up && newScrollCoordinates >= minScroll.y;\n      if (canScrollToNewCoordinates) {\n        // We don't need to update coordinates, the scroll adjustment alone will trigger\n        // logic to auto-detect the new container we are over\n        scrollContainer.scrollTo({\n          top: newScrollCoordinates,\n          behavior: 'smooth'\n        });\n        return true;\n      }\n      break;\n    }\n  }\n  return false;\n}","map":{"version":3,"mappings":"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","names":["canUseDOM","subtract","getCoordinatesDelta","KeyboardCode","isDocumentScrollingElement","element","document","scrollingElement","getScrollPosition","scrollingContainer","minScroll","x","y","dimensions","height","window","innerHeight","width","innerWidth","clientHeight","clientWidth","maxScroll","scrollWidth","scrollHeight","isTop","scrollTop","isLeft","scrollLeft","isBottom","isRight","getScrollElementRect","top","left","right","bottom","getBoundingClientRect","applyScroll","currentCoordinates","direction","newCoordinates","scrollableAncestors","scrollContainer","coordinatesDelta","scrollElementRect","clampedCoordinates","Math","min","Down","max","canScrollY","Up","newScrollCoordinates","canScrollToNewCoordinates","scrollTo","behavior"],"sources":["/Users/tangyizhi/Desktop/Assignment 2/frontend/node_modules/@cloudscape-design/components/collection-preferences/content-display/keyboard-sensor/utilities/lib/default/collection-preferences/content-display/keyboard-sensor/utilities/scroll.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { canUseDOM, Coordinates, subtract as getCoordinatesDelta } from '@dnd-kit/utilities';\nimport { KeyboardCode } from '@dnd-kit/core';\n\nfunction isDocumentScrollingElement(element: Element | null) {\n  if (!canUseDOM || !element) {\n    return false;\n  }\n\n  return element === document.scrollingElement;\n}\n\nexport function getScrollPosition(scrollingContainer: Element) {\n  const minScroll = {\n    x: 0,\n    y: 0,\n  };\n  const dimensions = isDocumentScrollingElement(scrollingContainer)\n    ? {\n        height: window.innerHeight,\n        width: window.innerWidth,\n      }\n    : {\n        height: scrollingContainer.clientHeight,\n        width: scrollingContainer.clientWidth,\n      };\n  const maxScroll = {\n    x: scrollingContainer.scrollWidth - dimensions.width,\n    y: scrollingContainer.scrollHeight - dimensions.height,\n  };\n\n  const isTop = scrollingContainer.scrollTop <= minScroll.y;\n  const isLeft = scrollingContainer.scrollLeft <= minScroll.x;\n  const isBottom = scrollingContainer.scrollTop >= maxScroll.y;\n  const isRight = scrollingContainer.scrollLeft >= maxScroll.x;\n\n  return {\n    isTop,\n    isLeft,\n    isBottom,\n    isRight,\n    maxScroll,\n    minScroll,\n  };\n}\n\nexport function getScrollElementRect(element: Element) {\n  if (element === document.scrollingElement) {\n    const { innerWidth, innerHeight } = window;\n\n    return {\n      top: 0,\n      left: 0,\n      right: innerWidth,\n      bottom: innerHeight,\n      width: innerWidth,\n      height: innerHeight,\n    };\n  }\n\n  const { top, left, right, bottom } = element.getBoundingClientRect();\n\n  return {\n    top,\n    left,\n    right,\n    bottom,\n    width: element.clientWidth,\n    height: element.clientHeight,\n  };\n}\n\nexport function applyScroll({\n  currentCoordinates,\n  direction,\n  newCoordinates,\n  scrollableAncestors,\n}: {\n  currentCoordinates: Coordinates;\n  direction: string;\n  newCoordinates: Coordinates;\n  scrollableAncestors: Element[];\n}) {\n  for (const scrollContainer of scrollableAncestors) {\n    const coordinatesDelta = getCoordinatesDelta(newCoordinates, currentCoordinates);\n    const { isTop, isBottom, maxScroll, minScroll } = getScrollPosition(scrollContainer);\n    const scrollElementRect = getScrollElementRect(scrollContainer);\n\n    const clampedCoordinates = {\n      y: Math.min(\n        direction === KeyboardCode.Down\n          ? scrollElementRect.bottom - scrollElementRect.height / 2\n          : scrollElementRect.bottom,\n        Math.max(\n          direction === KeyboardCode.Down\n            ? scrollElementRect.top\n            : scrollElementRect.top + scrollElementRect.height / 2,\n          newCoordinates.y\n        )\n      ),\n    };\n\n    const canScrollY = (direction === KeyboardCode.Down && !isBottom) || (direction === KeyboardCode.Up && !isTop);\n\n    if (canScrollY && clampedCoordinates.y !== newCoordinates.y) {\n      const newScrollCoordinates = scrollContainer.scrollTop + coordinatesDelta.y;\n      const canScrollToNewCoordinates =\n        (direction === KeyboardCode.Down && newScrollCoordinates <= maxScroll.y) ||\n        (direction === KeyboardCode.Up && newScrollCoordinates >= minScroll.y);\n\n      if (canScrollToNewCoordinates) {\n        // We don't need to update coordinates, the scroll adjustment alone will trigger\n        // logic to auto-detect the new container we are over\n        scrollContainer.scrollTo({\n          top: newScrollCoordinates,\n          behavior: 'smooth',\n        });\n        return true;\n      }\n\n      break;\n    }\n  }\n  return false;\n}\n"]},"metadata":{},"sourceType":"module"}