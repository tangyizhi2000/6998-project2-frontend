{"ast":null,"code":"import { __rest } from \"tslib\";\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport clsx from 'clsx';\nimport React, { useEffect, useMemo, useRef, useState } from 'react';\nimport { getBaseProps } from '../internal/base-component';\nimport { fireNonCancelableEvent } from '../internal/events';\nimport ChartStatusContainer, { getChartStatus } from '../internal/components/chart-status-container';\nimport { useControllable } from '../internal/hooks/use-controllable';\nimport { usePrevious } from '../internal/hooks/use-previous';\nimport { warnOnce } from '@cloudscape-design/component-toolkit/internal';\nimport InternalChartLegend from './chart-legend';\nimport ChartContainer from './chart-container';\nimport styles from './styles.css.js';\nimport { isDevelopment } from '../internal/is-development';\nimport createCategoryColorScale from '../internal/utils/create-category-color-scale';\nimport { useMergeRefs } from '../internal/hooks/use-merge-refs';\nimport { chartLegendMap, isXThreshold, isYThreshold } from './utils';\nimport { nodeBelongs } from '../internal/utils/node-belongs';\nimport Filter from '../internal/components/chart-filter';\nimport { ChartWrapper } from '../internal/components/chart-wrapper';\nexport default function InternalMixedLineBarChart(_a) {\n  var {\n      fitHeight,\n      height,\n      xScaleType,\n      yScaleType,\n      xDomain,\n      yDomain,\n      xTickFormatter,\n      yTickFormatter,\n      highlightedSeries: controlledHighlightedSeries,\n      visibleSeries: controlledVisibleSeries,\n      series: externalSeries,\n      onFilterChange,\n      onHighlightChange: controlledOnHighlightChange,\n      i18nStrings,\n      ariaLabel,\n      ariaLabelledby,\n      ariaDescription,\n      xTitle,\n      yTitle,\n      stackedBars,\n      horizontalBars,\n      hideFilter,\n      additionalFilters,\n      hideLegend,\n      legendTitle,\n      statusType,\n      detailPopoverSize,\n      detailPopoverFooter,\n      emphasizeBaselineAxis,\n      empty,\n      noMatch,\n      errorText,\n      loadingText,\n      recoveryText,\n      onRecoveryClick,\n      __internalRootRef = null\n    } = _a,\n    props = __rest(_a, [\"fitHeight\", \"height\", \"xScaleType\", \"yScaleType\", \"xDomain\", \"yDomain\", \"xTickFormatter\", \"yTickFormatter\", \"highlightedSeries\", \"visibleSeries\", \"series\", \"onFilterChange\", \"onHighlightChange\", \"i18nStrings\", \"ariaLabel\", \"ariaLabelledby\", \"ariaDescription\", \"xTitle\", \"yTitle\", \"stackedBars\", \"horizontalBars\", \"hideFilter\", \"additionalFilters\", \"hideLegend\", \"legendTitle\", \"statusType\", \"detailPopoverSize\", \"detailPopoverFooter\", \"emphasizeBaselineAxis\", \"empty\", \"noMatch\", \"errorText\", \"loadingText\", \"recoveryText\", \"onRecoveryClick\", \"__internalRootRef\"]);\n  const baseProps = getBaseProps(props);\n  const containerRef = useRef(null);\n  useEffect(() => {\n    const gotBarSeries = externalSeries.some(s => s.type === 'bar');\n    const gotLineSeries = externalSeries.some(s => s.type === 'line');\n    if (xScaleType !== 'categorical' && gotBarSeries) {\n      warnOnce('MixedLineBarChart', `Bar series cannot be used with a ${xScaleType} scale. Use a categorical x axis instead.`);\n    }\n    if (horizontalBars && gotLineSeries) {\n      warnOnce('MixedLineBarChart', `Property horizontalBars can only be used with charts that contain only bar or threshold series.`);\n    }\n    for (const s of externalSeries) {\n      if (s.type === 'threshold' && s.x !== undefined && s.y !== undefined) {\n        warnOnce('MixedLineBarChart', `Series of type \"threshold\" must contain either x or y property.`);\n      }\n      if (s.type === 'threshold' && s.x === undefined && s.y === undefined) {\n        warnOnce('MixedLineBarChart', `Series of type \"threshold\" must contain either x or y property.`);\n      }\n    }\n  }, [xScaleType, horizontalBars, externalSeries]);\n  const series = useMemo(() => {\n    // Generate series colors if not explicitly provided.\n    // The thresholds use a dedicated colour scale.\n    const colors = createCategoryColorScale(externalSeries, it => isYThreshold(it) || isXThreshold(it), it => it.color || null);\n    return externalSeries.map((s, i) => ({\n      index: i,\n      color: colors[i],\n      series: s\n    }));\n  }, [externalSeries]);\n  const [highlightedPoint, setHighlightedPoint] = useState(null);\n  const [highlightedGroupIndex, setHighlightedGroupIndex] = useState(null);\n  const [highlightedSeries = null, setHighlightedSeries] = useControllable(controlledHighlightedSeries, controlledOnHighlightChange, null, {\n    componentName: 'MixedLineBarChart',\n    controlledProp: 'highlightedSeries',\n    changeHandler: 'onHighlightChange'\n  });\n  const [legendSeries, setLegendSeries] = useState(highlightedSeries);\n  useEffect(() => {\n    setLegendSeries(controlledHighlightedSeries || null);\n  }, [controlledHighlightedSeries]);\n  const [externalVisibleSeries, setExternalVisibleSeries] = useControllable(controlledVisibleSeries, onFilterChange, externalSeries, {\n    componentName: 'MixedLineBarChart',\n    controlledProp: 'visibleSeries',\n    changeHandler: 'onFilterChange'\n  });\n  if (isDevelopment) {\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    const previousSeries = usePrevious(externalSeries);\n    const hasPrevious = !!(previousSeries && previousSeries.length);\n    const hasCurrent = !!externalSeries.length;\n    if (hasPrevious && hasCurrent && externalSeries !== previousSeries && !controlledVisibleSeries && !hideFilter) {\n      warnOnce('MixedLineBarChart', 'The `series` value passed into the component changed. ' + 'This may cause problems with filtering - we recommend that you make the `series` value constant, ' + 'or provide a `visibleSeries` value that derives from the current `series` value.');\n    }\n  }\n  const visibleSeries = useMemo(() => series.filter(s => (externalVisibleSeries === null || externalVisibleSeries === void 0 ? void 0 : externalVisibleSeries.indexOf(s.series)) !== -1), [series, externalVisibleSeries]);\n  const filterChange = selectedSeries => {\n    setExternalVisibleSeries(selectedSeries);\n    fireNonCancelableEvent(onFilterChange, {\n      visibleSeries: selectedSeries\n    });\n  };\n  const onHighlightChange = series => {\n    setHighlightedSeries(series);\n    fireNonCancelableEvent(controlledOnHighlightChange, {\n      highlightedSeries: series\n    });\n    setLegendSeries(series);\n  };\n  const onBlur = event => {\n    if (event.relatedTarget && !nodeBelongs(containerRef.current, event.relatedTarget)) {\n      highlightedSeries && onHighlightChange(highlightedSeries);\n      setHighlightedPoint(null);\n      setHighlightedGroupIndex(null);\n      setLegendSeries(null);\n    }\n  };\n  const {\n    isEmpty,\n    isNoMatch,\n    showChart\n  } = getChartStatus({\n    externalData: externalSeries,\n    visibleData: visibleSeries || [],\n    statusType\n  });\n  const showFilters = statusType === 'finished' && (!isEmpty || isNoMatch) && (additionalFilters || !hideFilter);\n  const showLegend = !hideLegend && !isEmpty && statusType === 'finished';\n  const reserveLegendSpace = !showChart && !hideLegend;\n  const reserveFilterSpace = !showChart && !isNoMatch && (!hideFilter || additionalFilters);\n  const mergedRef = useMergeRefs(containerRef, __internalRootRef);\n  const filterItems = series.map(_ref => {\n    let {\n      series,\n      color\n    } = _ref;\n    return {\n      label: series.title,\n      type: chartLegendMap[series.type],\n      color,\n      datum: series\n    };\n  });\n  return React.createElement(ChartWrapper, Object.assign({\n    ref: mergedRef\n  }, baseProps, {\n    className: clsx(baseProps.className, styles.root),\n    fitHeight: !!fitHeight,\n    contentMinHeight: height,\n    defaultFilter: showFilters && !hideFilter ? React.createElement(Filter, {\n      series: filterItems,\n      onChange: filterChange,\n      selectedSeries: externalVisibleSeries || [],\n      i18nStrings: i18nStrings\n    }) : null,\n    additionalFilters: showFilters ? additionalFilters : null,\n    reserveFilterSpace: !!reserveFilterSpace,\n    reserveLegendSpace: !!reserveLegendSpace,\n    chartStatus: React.createElement(ChartStatusContainer, {\n      isEmpty: isEmpty,\n      isNoMatch: isNoMatch,\n      showChart: showChart,\n      statusType: statusType,\n      empty: empty,\n      noMatch: noMatch,\n      loadingText: loadingText,\n      errorText: errorText,\n      recoveryText: recoveryText,\n      onRecoveryClick: onRecoveryClick\n    }),\n    chart: showChart ? React.createElement(ChartContainer, {\n      fitHeight: fitHeight,\n      height: height,\n      xScaleType: xScaleType,\n      yScaleType: yScaleType,\n      xDomain: xDomain,\n      yDomain: yDomain,\n      xTickFormatter: xTickFormatter !== null && xTickFormatter !== void 0 ? xTickFormatter : i18nStrings === null || i18nStrings === void 0 ? void 0 : i18nStrings.xTickFormatter,\n      yTickFormatter: yTickFormatter !== null && yTickFormatter !== void 0 ? yTickFormatter : i18nStrings === null || i18nStrings === void 0 ? void 0 : i18nStrings.yTickFormatter,\n      emphasizeBaselineAxis: emphasizeBaselineAxis,\n      stackedBars: stackedBars,\n      horizontalBars: horizontalBars,\n      series: series,\n      visibleSeries: visibleSeries,\n      highlightedSeries: highlightedSeries,\n      onHighlightChange: onHighlightChange,\n      highlightedPoint: highlightedPoint,\n      setHighlightedPoint: setHighlightedPoint,\n      highlightedGroupIndex: highlightedGroupIndex,\n      setHighlightedGroupIndex: setHighlightedGroupIndex,\n      detailPopoverSize: detailPopoverSize,\n      detailPopoverFooter: detailPopoverFooter,\n      xTitle: xTitle,\n      yTitle: yTitle,\n      ariaLabel: ariaLabel,\n      ariaLabelledby: ariaLabelledby,\n      ariaDescription: ariaDescription,\n      i18nStrings: i18nStrings,\n      plotContainerRef: containerRef\n    }) : null,\n    legend: showLegend ? React.createElement(InternalChartLegend, {\n      series: series,\n      visibleSeries: externalVisibleSeries || [],\n      highlightedSeries: legendSeries,\n      onHighlightChange: onHighlightChange,\n      legendTitle: legendTitle,\n      ariaLabel: i18nStrings === null || i18nStrings === void 0 ? void 0 : i18nStrings.legendAriaLabel,\n      plotContainerRef: containerRef\n    }) : null,\n    onBlur: onBlur\n  }));\n}","map":{"version":3,"mappings":"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","names":["clsx","React","useEffect","useMemo","useRef","useState","getBaseProps","fireNonCancelableEvent","ChartStatusContainer","getChartStatus","useControllable","usePrevious","warnOnce","InternalChartLegend","ChartContainer","styles","isDevelopment","createCategoryColorScale","useMergeRefs","chartLegendMap","isXThreshold","isYThreshold","nodeBelongs","Filter","ChartWrapper","InternalMixedLineBarChart","_a","fitHeight","height","xScaleType","yScaleType","xDomain","yDomain","xTickFormatter","yTickFormatter","highlightedSeries","controlledHighlightedSeries","visibleSeries","controlledVisibleSeries","series","externalSeries","onFilterChange","onHighlightChange","controlledOnHighlightChange","i18nStrings","ariaLabel","ariaLabelledby","ariaDescription","xTitle","yTitle","stackedBars","horizontalBars","hideFilter","additionalFilters","hideLegend","legendTitle","statusType","detailPopoverSize","detailPopoverFooter","emphasizeBaselineAxis","empty","noMatch","errorText","loadingText","recoveryText","onRecoveryClick","__internalRootRef","props","baseProps","containerRef","gotBarSeries","some","s","type","gotLineSeries","x","undefined","y","colors","it","color","map","i","index","highlightedPoint","setHighlightedPoint","highlightedGroupIndex","setHighlightedGroupIndex","setHighlightedSeries","componentName","controlledProp","changeHandler","legendSeries","setLegendSeries","externalVisibleSeries","setExternalVisibleSeries","previousSeries","hasPrevious","length","hasCurrent","filter","indexOf","filterChange","selectedSeries","onBlur","event","relatedTarget","current","isEmpty","isNoMatch","showChart","externalData","visibleData","showFilters","showLegend","reserveLegendSpace","reserveFilterSpace","mergedRef","filterItems","label","title","datum","ref","className","root","contentMinHeight","defaultFilter","onChange","chartStatus","chart","plotContainerRef","legend","legendAriaLabel"],"sources":["/Users/tangyizhi/Desktop/Assignment2/frontend/node_modules/@cloudscape-design/components/mixed-line-bar-chart/lib/default/mixed-line-bar-chart/internal.tsx"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport clsx from 'clsx';\nimport React, { useEffect, useMemo, useRef, useState } from 'react';\n\nimport { getBaseProps } from '../internal/base-component';\nimport { fireNonCancelableEvent } from '../internal/events';\nimport ChartStatusContainer, { getChartStatus } from '../internal/components/chart-status-container';\nimport { useControllable } from '../internal/hooks/use-controllable';\nimport { usePrevious } from '../internal/hooks/use-previous';\nimport { warnOnce } from '@cloudscape-design/component-toolkit/internal';\n\nimport { ChartDataTypes, MixedLineBarChartProps } from './interfaces';\nimport InternalChartLegend from './chart-legend';\nimport ChartContainer from './chart-container';\nimport styles from './styles.css.js';\nimport { InternalBaseComponentProps } from '../internal/hooks/use-base-component';\nimport { isDevelopment } from '../internal/is-development';\nimport createCategoryColorScale from '../internal/utils/create-category-color-scale';\nimport { ScaledPoint } from './make-scaled-series';\nimport { useMergeRefs } from '../internal/hooks/use-merge-refs';\nimport { SomeRequired } from '../internal/types';\nimport { chartLegendMap, isXThreshold, isYThreshold } from './utils';\nimport { nodeBelongs } from '../internal/utils/node-belongs';\nimport Filter from '../internal/components/chart-filter';\nimport { ChartWrapper } from '../internal/components/chart-wrapper';\n\ntype InternalMixedLineBarChartProps<T extends ChartDataTypes> = SomeRequired<\n  MixedLineBarChartProps<T>,\n  | 'series'\n  | 'height'\n  | 'xScaleType'\n  | 'yScaleType'\n  | 'stackedBars'\n  | 'horizontalBars'\n  | 'statusType'\n  | 'detailPopoverSize'\n  | 'emphasizeBaselineAxis'\n> &\n  InternalBaseComponentProps;\n\nexport default function InternalMixedLineBarChart<T extends number | string | Date>({\n  fitHeight,\n  height,\n  xScaleType,\n  yScaleType,\n  xDomain,\n  yDomain,\n  xTickFormatter,\n  yTickFormatter,\n  highlightedSeries: controlledHighlightedSeries,\n  visibleSeries: controlledVisibleSeries,\n  series: externalSeries,\n  onFilterChange,\n  onHighlightChange: controlledOnHighlightChange,\n  i18nStrings,\n  ariaLabel,\n  ariaLabelledby,\n  ariaDescription,\n  xTitle,\n  yTitle,\n  stackedBars,\n  horizontalBars,\n  hideFilter,\n  additionalFilters,\n  hideLegend,\n  legendTitle,\n  statusType,\n  detailPopoverSize,\n  detailPopoverFooter,\n  emphasizeBaselineAxis,\n  empty,\n  noMatch,\n  errorText,\n  loadingText,\n  recoveryText,\n  onRecoveryClick,\n  __internalRootRef = null,\n  ...props\n}: InternalMixedLineBarChartProps<T>) {\n  const baseProps = getBaseProps(props);\n  const containerRef = useRef<HTMLDivElement>(null);\n\n  useEffect(() => {\n    const gotBarSeries = externalSeries.some(s => s.type === 'bar');\n    const gotLineSeries = externalSeries.some(s => s.type === 'line');\n\n    if (xScaleType !== 'categorical' && gotBarSeries) {\n      warnOnce(\n        'MixedLineBarChart',\n        `Bar series cannot be used with a ${xScaleType} scale. Use a categorical x axis instead.`\n      );\n    }\n\n    if (horizontalBars && gotLineSeries) {\n      warnOnce(\n        'MixedLineBarChart',\n        `Property horizontalBars can only be used with charts that contain only bar or threshold series.`\n      );\n    }\n\n    for (const s of externalSeries) {\n      if (s.type === 'threshold' && s.x !== undefined && s.y !== undefined) {\n        warnOnce('MixedLineBarChart', `Series of type \"threshold\" must contain either x or y property.`);\n      }\n      if (s.type === 'threshold' && s.x === undefined && s.y === undefined) {\n        warnOnce('MixedLineBarChart', `Series of type \"threshold\" must contain either x or y property.`);\n      }\n    }\n  }, [xScaleType, horizontalBars, externalSeries]);\n\n  const series = useMemo(() => {\n    // Generate series colors if not explicitly provided.\n    // The thresholds use a dedicated colour scale.\n    const colors = createCategoryColorScale(\n      externalSeries,\n      it => isYThreshold(it) || isXThreshold(it),\n      it => it.color || null\n    );\n\n    return externalSeries.map((s, i) => ({ index: i, color: colors[i], series: s }));\n  }, [externalSeries]);\n\n  const [highlightedPoint, setHighlightedPoint] = useState<ScaledPoint<T> | null>(null);\n  const [highlightedGroupIndex, setHighlightedGroupIndex] = useState<number | null>(null);\n  const [highlightedSeries = null, setHighlightedSeries] = useControllable(\n    controlledHighlightedSeries,\n    controlledOnHighlightChange,\n    null,\n    {\n      componentName: 'MixedLineBarChart',\n      controlledProp: 'highlightedSeries',\n      changeHandler: 'onHighlightChange',\n    }\n  );\n  const [legendSeries, setLegendSeries] = useState<MixedLineBarChartProps.ChartSeries<T> | null>(highlightedSeries);\n  useEffect(() => {\n    setLegendSeries(controlledHighlightedSeries || null);\n  }, [controlledHighlightedSeries]);\n\n  const [externalVisibleSeries, setExternalVisibleSeries] = useControllable(\n    controlledVisibleSeries,\n    onFilterChange,\n    externalSeries,\n    {\n      componentName: 'MixedLineBarChart',\n      controlledProp: 'visibleSeries',\n      changeHandler: 'onFilterChange',\n    }\n  );\n\n  if (isDevelopment) {\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    const previousSeries = usePrevious(externalSeries);\n\n    const hasPrevious = !!(previousSeries && previousSeries.length);\n    const hasCurrent = !!externalSeries.length;\n\n    if (hasPrevious && hasCurrent && externalSeries !== previousSeries && !controlledVisibleSeries && !hideFilter) {\n      warnOnce(\n        'MixedLineBarChart',\n        'The `series` value passed into the component changed. ' +\n          'This may cause problems with filtering - we recommend that you make the `series` value constant, ' +\n          'or provide a `visibleSeries` value that derives from the current `series` value.'\n      );\n    }\n  }\n\n  const visibleSeries = useMemo(\n    () => series.filter(s => externalVisibleSeries?.indexOf(s.series) !== -1),\n    [series, externalVisibleSeries]\n  );\n\n  const filterChange = (selectedSeries: ReadonlyArray<MixedLineBarChartProps.ChartSeries<T>>) => {\n    setExternalVisibleSeries(selectedSeries);\n    fireNonCancelableEvent(onFilterChange, {\n      visibleSeries: selectedSeries,\n    });\n  };\n\n  const onHighlightChange = (series: MixedLineBarChartProps.ChartSeries<T> | null) => {\n    setHighlightedSeries(series);\n    fireNonCancelableEvent(controlledOnHighlightChange, {\n      highlightedSeries: series,\n    });\n    setLegendSeries(series);\n  };\n\n  const onBlur = (event: React.FocusEvent) => {\n    if (event.relatedTarget && !nodeBelongs(containerRef.current, event.relatedTarget)) {\n      highlightedSeries && onHighlightChange(highlightedSeries);\n      setHighlightedPoint(null);\n      setHighlightedGroupIndex(null);\n      setLegendSeries(null);\n    }\n  };\n\n  const { isEmpty, isNoMatch, showChart } = getChartStatus({\n    externalData: externalSeries,\n    visibleData: visibleSeries || [],\n    statusType,\n  });\n  const showFilters = statusType === 'finished' && (!isEmpty || isNoMatch) && (additionalFilters || !hideFilter);\n  const showLegend = !hideLegend && !isEmpty && statusType === 'finished';\n  const reserveLegendSpace = !showChart && !hideLegend;\n  const reserveFilterSpace = !showChart && !isNoMatch && (!hideFilter || additionalFilters);\n  const mergedRef = useMergeRefs(containerRef, __internalRootRef);\n\n  const filterItems = series.map(({ series, color }) => ({\n    label: series.title,\n    type: chartLegendMap[series.type],\n    color,\n    datum: series,\n  }));\n\n  return (\n    <ChartWrapper\n      ref={mergedRef}\n      {...baseProps}\n      className={clsx(baseProps.className, styles.root)}\n      fitHeight={!!fitHeight}\n      contentMinHeight={height}\n      defaultFilter={\n        showFilters && !hideFilter ? (\n          <Filter\n            series={filterItems}\n            onChange={filterChange}\n            selectedSeries={externalVisibleSeries || []}\n            i18nStrings={i18nStrings}\n          />\n        ) : null\n      }\n      additionalFilters={showFilters ? additionalFilters : null}\n      reserveFilterSpace={!!reserveFilterSpace}\n      reserveLegendSpace={!!reserveLegendSpace}\n      chartStatus={\n        <ChartStatusContainer\n          isEmpty={isEmpty}\n          isNoMatch={isNoMatch}\n          showChart={showChart}\n          statusType={statusType}\n          empty={empty}\n          noMatch={noMatch}\n          loadingText={loadingText}\n          errorText={errorText}\n          recoveryText={recoveryText}\n          onRecoveryClick={onRecoveryClick}\n        />\n      }\n      chart={\n        showChart ? (\n          <ChartContainer\n            fitHeight={fitHeight}\n            height={height}\n            xScaleType={xScaleType}\n            yScaleType={yScaleType}\n            xDomain={xDomain}\n            yDomain={yDomain}\n            xTickFormatter={xTickFormatter ?? i18nStrings?.xTickFormatter}\n            yTickFormatter={yTickFormatter ?? i18nStrings?.yTickFormatter}\n            emphasizeBaselineAxis={emphasizeBaselineAxis}\n            stackedBars={stackedBars}\n            horizontalBars={horizontalBars}\n            series={series}\n            visibleSeries={visibleSeries}\n            highlightedSeries={highlightedSeries}\n            onHighlightChange={onHighlightChange}\n            highlightedPoint={highlightedPoint}\n            setHighlightedPoint={setHighlightedPoint}\n            highlightedGroupIndex={highlightedGroupIndex}\n            setHighlightedGroupIndex={setHighlightedGroupIndex}\n            detailPopoverSize={detailPopoverSize}\n            detailPopoverFooter={detailPopoverFooter}\n            xTitle={xTitle}\n            yTitle={yTitle}\n            ariaLabel={ariaLabel}\n            ariaLabelledby={ariaLabelledby}\n            ariaDescription={ariaDescription}\n            i18nStrings={i18nStrings}\n            plotContainerRef={containerRef}\n          />\n        ) : null\n      }\n      legend={\n        showLegend ? (\n          <InternalChartLegend\n            series={series}\n            visibleSeries={externalVisibleSeries || []}\n            highlightedSeries={legendSeries}\n            onHighlightChange={onHighlightChange}\n            legendTitle={legendTitle}\n            ariaLabel={i18nStrings?.legendAriaLabel}\n            plotContainerRef={containerRef}\n          />\n        ) : null\n      }\n      onBlur={onBlur}\n    />\n  );\n}\n"]},"metadata":{},"sourceType":"module"}