{"ast":null,"code":"import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from \"react/jsx-runtime\";\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { memo, useEffect, useRef } from \"react\";\nimport ScreenreaderOnly from \"../screenreader-only\";\n/**\n * The live region is hidden in the layout, but visible for screen readers.\n * It's purpose it to announce changes e.g. when custom navigation logic is used.\n *\n * The way live region works differently in different browsers and screen readers and\n * it is recommended to manually test every new implementation.\n *\n * If you notice there are different words being merged together,\n * check if there are text nodes not being wrapped in elements, like:\n * <LiveRegion>\n *   {title}\n *   <span><Details /></span>\n * </LiveRegion>\n *\n * To fix, wrap \"title\" in an element:\n * <LiveRegion>\n *   <span>{title}</span>\n *   <span><Details /></span>\n * </LiveRegion>\n *\n * Or create a single text node if possible:\n * <LiveRegion>\n *   {`${title} ${details}`}\n * </LiveRegion>\n *\n * The live region is always atomic, because non-atomic regions can be treated by screen readers\n * differently and produce unexpected results. To imitate non-atomic announcements simply use\n * multiple live regions:\n * <>\n *   <LiveRegion>{title}</LiveRegion>\n *   <LiveRegion><Details /></LiveRegion>\n * </>\n */\nexport default memo(LiveRegion);\nfunction LiveRegion(_ref) {\n  let {\n    assertive = false,\n    delay = 10,\n    visible = false,\n    children,\n    ...restProps\n  } = _ref;\n  const sourceRef = useRef(null);\n  const targetRef = useRef(null);\n  /*\n    When React state changes, React often produces too many DOM updates, causing NVDA to\n    issue many announcements for the same logical event (See https://github.com/nvaccess/nvda/issues/7996).\n    The code below imitates a debouncing, scheduling a callback every time new React state\n    update is detected. When a callback resolves, it copies content from a muted element\n    to the live region, which is recognized by screen readers as an update.\n    If the use case requires no announcement to be ignored, use delay = 0, but ensure it\n    does not impact the performance. If it does, prefer using a string as children prop.\n  */\n  useEffect(() => {\n    function updateLiveRegion() {\n      if (targetRef.current && sourceRef.current) {\n        const sourceContent = extractInnerText(sourceRef.current);\n        const targetContent = extractInnerText(targetRef.current);\n        if (targetContent !== sourceContent) {\n          // The aria-atomic does not work properly in Voice Over, causing\n          // certain parts of the content to be ignored. To fix that,\n          // we assign the source text content as a single node.\n          targetRef.current.innerText = sourceContent;\n        }\n      }\n    }\n    let timeoutId;\n    if (delay) {\n      timeoutId = setTimeout(updateLiveRegion, delay);\n    } else {\n      updateLiveRegion();\n    }\n    return () => {\n      if (timeoutId) {\n        clearTimeout(timeoutId);\n      }\n    };\n  });\n  return _jsxs(_Fragment, {\n    children: [visible && _jsx(\"span\", {\n      ref: sourceRef,\n      children: children\n    }), _jsxs(ScreenreaderOnly, {\n      ...restProps,\n      className: restProps.className,\n      children: [!visible && _jsx(\"span\", {\n        ref: sourceRef,\n        \"aria-hidden\": \"true\",\n        children: children\n      }), _jsx(\"span\", {\n        ref: targetRef,\n        \"aria-atomic\": \"true\",\n        \"aria-live\": assertive ? \"assertive\" : \"polite\"\n      })]\n    })]\n  });\n}\n// This only extracts text content from the node including all its children which is enough for now.\n// To make it more powerful, it is possible to create a more sophisticated extractor with respect to\n// ARIA properties to ignore aria-hidden nodes and read ARIA labels from the live content.\nfunction extractInnerText(node) {\n  return (node.innerText || \"\").replace(/\\s+/g, \" \").trim();\n}","map":{"version":3,"names":["jsx","_jsx","jsxs","_jsxs","Fragment","_Fragment","memo","useEffect","useRef","ScreenreaderOnly","LiveRegion","assertive","delay","visible","children","restProps","sourceRef","targetRef","updateLiveRegion","current","sourceContent","extractInnerText","targetContent","innerText","timeoutId","setTimeout","clearTimeout","ref","className","node","replace","trim"],"sources":["/Users/tangyizhi/Desktop/Assignment 2/frontend/node_modules/@cloudscape-design/board-components/internal/live-region/index.js"],"sourcesContent":["import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from \"react/jsx-runtime\";\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { memo, useEffect, useRef } from \"react\";\nimport ScreenreaderOnly from \"../screenreader-only\";\n/**\n * The live region is hidden in the layout, but visible for screen readers.\n * It's purpose it to announce changes e.g. when custom navigation logic is used.\n *\n * The way live region works differently in different browsers and screen readers and\n * it is recommended to manually test every new implementation.\n *\n * If you notice there are different words being merged together,\n * check if there are text nodes not being wrapped in elements, like:\n * <LiveRegion>\n *   {title}\n *   <span><Details /></span>\n * </LiveRegion>\n *\n * To fix, wrap \"title\" in an element:\n * <LiveRegion>\n *   <span>{title}</span>\n *   <span><Details /></span>\n * </LiveRegion>\n *\n * Or create a single text node if possible:\n * <LiveRegion>\n *   {`${title} ${details}`}\n * </LiveRegion>\n *\n * The live region is always atomic, because non-atomic regions can be treated by screen readers\n * differently and produce unexpected results. To imitate non-atomic announcements simply use\n * multiple live regions:\n * <>\n *   <LiveRegion>{title}</LiveRegion>\n *   <LiveRegion><Details /></LiveRegion>\n * </>\n */\nexport default memo(LiveRegion);\nfunction LiveRegion({ assertive = false, delay = 10, visible = false, children, ...restProps }) {\n    const sourceRef = useRef(null);\n    const targetRef = useRef(null);\n    /*\n      When React state changes, React often produces too many DOM updates, causing NVDA to\n      issue many announcements for the same logical event (See https://github.com/nvaccess/nvda/issues/7996).\n      The code below imitates a debouncing, scheduling a callback every time new React state\n      update is detected. When a callback resolves, it copies content from a muted element\n      to the live region, which is recognized by screen readers as an update.\n      If the use case requires no announcement to be ignored, use delay = 0, but ensure it\n      does not impact the performance. If it does, prefer using a string as children prop.\n    */\n    useEffect(() => {\n        function updateLiveRegion() {\n            if (targetRef.current && sourceRef.current) {\n                const sourceContent = extractInnerText(sourceRef.current);\n                const targetContent = extractInnerText(targetRef.current);\n                if (targetContent !== sourceContent) {\n                    // The aria-atomic does not work properly in Voice Over, causing\n                    // certain parts of the content to be ignored. To fix that,\n                    // we assign the source text content as a single node.\n                    targetRef.current.innerText = sourceContent;\n                }\n            }\n        }\n        let timeoutId;\n        if (delay) {\n            timeoutId = setTimeout(updateLiveRegion, delay);\n        }\n        else {\n            updateLiveRegion();\n        }\n        return () => {\n            if (timeoutId) {\n                clearTimeout(timeoutId);\n            }\n        };\n    });\n    return (_jsxs(_Fragment, { children: [visible && _jsx(\"span\", { ref: sourceRef, children: children }), _jsxs(ScreenreaderOnly, { ...restProps, className: restProps.className, children: [!visible && (_jsx(\"span\", { ref: sourceRef, \"aria-hidden\": \"true\", children: children })), _jsx(\"span\", { ref: targetRef, \"aria-atomic\": \"true\", \"aria-live\": assertive ? \"assertive\" : \"polite\" })] })] }));\n}\n// This only extracts text content from the node including all its children which is enough for now.\n// To make it more powerful, it is possible to create a more sophisticated extractor with respect to\n// ARIA properties to ignore aria-hidden nodes and read ARIA labels from the live content.\nfunction extractInnerText(node) {\n    return (node.innerText || \"\").replace(/\\s+/g, \" \").trim();\n}\n"],"mappings":"AAAA,SAASA,GAAG,IAAIC,IAAI,EAAEC,IAAI,IAAIC,KAAK,EAAEC,QAAQ,IAAIC,SAAS,QAAQ,mBAAmB;AACrF;AACA;AACA,SAASC,IAAI,EAAEC,SAAS,EAAEC,MAAM,QAAQ,OAAO;AAC/C,OAAOC,gBAAgB,MAAM,sBAAsB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAeH,IAAI,CAACI,UAAU,CAAC;AAC/B,SAASA,UAAU,OAA6E;EAAA,IAA5E;IAAEC,SAAS,GAAG,KAAK;IAAEC,KAAK,GAAG,EAAE;IAAEC,OAAO,GAAG,KAAK;IAAEC,QAAQ;IAAE,GAAGC;EAAU,CAAC;EAC1F,MAAMC,SAAS,GAAGR,MAAM,CAAC,IAAI,CAAC;EAC9B,MAAMS,SAAS,GAAGT,MAAM,CAAC,IAAI,CAAC;EAC9B;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACID,SAAS,CAAC,MAAM;IACZ,SAASW,gBAAgB,GAAG;MACxB,IAAID,SAAS,CAACE,OAAO,IAAIH,SAAS,CAACG,OAAO,EAAE;QACxC,MAAMC,aAAa,GAAGC,gBAAgB,CAACL,SAAS,CAACG,OAAO,CAAC;QACzD,MAAMG,aAAa,GAAGD,gBAAgB,CAACJ,SAAS,CAACE,OAAO,CAAC;QACzD,IAAIG,aAAa,KAAKF,aAAa,EAAE;UACjC;UACA;UACA;UACAH,SAAS,CAACE,OAAO,CAACI,SAAS,GAAGH,aAAa;QAC/C;MACJ;IACJ;IACA,IAAII,SAAS;IACb,IAAIZ,KAAK,EAAE;MACPY,SAAS,GAAGC,UAAU,CAACP,gBAAgB,EAAEN,KAAK,CAAC;IACnD,CAAC,MACI;MACDM,gBAAgB,EAAE;IACtB;IACA,OAAO,MAAM;MACT,IAAIM,SAAS,EAAE;QACXE,YAAY,CAACF,SAAS,CAAC;MAC3B;IACJ,CAAC;EACL,CAAC,CAAC;EACF,OAAQrB,KAAK,CAACE,SAAS,EAAE;IAAES,QAAQ,EAAE,CAACD,OAAO,IAAIZ,IAAI,CAAC,MAAM,EAAE;MAAE0B,GAAG,EAAEX,SAAS;MAAEF,QAAQ,EAAEA;IAAS,CAAC,CAAC,EAAEX,KAAK,CAACM,gBAAgB,EAAE;MAAE,GAAGM,SAAS;MAAEa,SAAS,EAAEb,SAAS,CAACa,SAAS;MAAEd,QAAQ,EAAE,CAAC,CAACD,OAAO,IAAKZ,IAAI,CAAC,MAAM,EAAE;QAAE0B,GAAG,EAAEX,SAAS;QAAE,aAAa,EAAE,MAAM;QAAEF,QAAQ,EAAEA;MAAS,CAAC,CAAE,EAAEb,IAAI,CAAC,MAAM,EAAE;QAAE0B,GAAG,EAAEV,SAAS;QAAE,aAAa,EAAE,MAAM;QAAE,WAAW,EAAEN,SAAS,GAAG,WAAW,GAAG;MAAS,CAAC,CAAC;IAAE,CAAC,CAAC;EAAE,CAAC,CAAC;AACzY;AACA;AACA;AACA;AACA,SAASU,gBAAgB,CAACQ,IAAI,EAAE;EAC5B,OAAO,CAACA,IAAI,CAACN,SAAS,IAAI,EAAE,EAAEO,OAAO,CAAC,MAAM,EAAE,GAAG,CAAC,CAACC,IAAI,EAAE;AAC7D"},"metadata":{},"sourceType":"module"}