{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { useEffect, useMemo } from 'react';\nimport { defaultIsSuppressed, findFocusinCell, moveFocusBy, muteElementFocusables, restoreElementFocusables, ensureSingleFocusable, getFirstFocusable } from './utils';\nimport { KeyCode } from '../../internal/keycode';\nimport { nodeContains } from '@cloudscape-design/component-toolkit/dom';\nimport { useStableCallback } from '@cloudscape-design/component-toolkit/internal';\n/**\n * Makes table navigable with keyboard commands.\n * See https://www.w3.org/WAI/ARIA/apg/patterns/grid\n *\n * The hook attaches the GridNavigationHelper helper when active=true.\n * See GridNavigationHelper for more details.\n */\nexport function useGridNavigation(_ref) {\n  let {\n    active,\n    pageSize,\n    getTable,\n    isSuppressed\n  } = _ref;\n  const gridNavigation = useMemo(() => new GridNavigationHelper(), []);\n  const getTableStable = useStableCallback(getTable);\n  const isSuppressedStable = useStableCallback(element => {\n    var _a;\n    return (_a = isSuppressed === null || isSuppressed === void 0 ? void 0 : isSuppressed(element)) !== null && _a !== void 0 ? _a : false;\n  });\n  // Initialize the model with the table container assuming it is mounted synchronously and only once.\n  useEffect(() => {\n    if (active) {\n      const table = getTableStable();\n      table && gridNavigation.init(table, isSuppressedStable);\n    }\n    return () => gridNavigation.cleanup();\n  }, [active, gridNavigation, getTableStable, isSuppressedStable]);\n  // Notify the model of the props change.\n  useEffect(() => {\n    gridNavigation.update({\n      pageSize\n    });\n  }, [gridNavigation, pageSize]);\n}\n/**\n * This helper encapsulates the grid navigation behaviors which are:\n * 1. Responding to keyboard commands and moving the focus accordingly;\n * 2. Muting table interactive elements for only one to be user-focusable at a time;\n * 3. Suppressing the above behaviors when focusing an element inside a dialog or when instructed by the isSuppressed callback.\n *\n * All behaviors are attached upon initialization and are re-evaluated with every focusin, focusout, and keydown events,\n * and also when a node removal inside the table is observed to ensure consistency at any given moment.\n *\n * When the navigation is suppressed the keyboard commands are no longer intercepted and all table interactive elements are made\n * user-focusable to unblock the Tab navigation. The suppression should only be used for interactive elements inside the table that would\n * otherwise conflict with the navigation. Once the interactive element is deactivated or lose focus the table navigation becomes active again.\n */\nclass GridNavigationHelper {\n  constructor() {\n    // Props\n    this._pageSize = 0;\n    this._table = null;\n    this._isSuppressed = () => false;\n    // State\n    this.prevFocusedCell = null;\n    this.focusedCell = null;\n    this.onFocusin = event => {\n      var _a;\n      const cell = findFocusinCell(event);\n      if (!cell) {\n        return;\n      }\n      this.prevFocusedCell = cell;\n      this.focusedCell = cell;\n      muteElementFocusables(this.table, this.isSuppressed(cell.element));\n      ensureSingleFocusable(this.table, cell);\n      // Focusing on cell is not eligible when it contains focusable elements in the content.\n      // If content focusables are available - move the focus to the first one.\n      if (cell.element === cell.cellElement) {\n        (_a = getFirstFocusable(cell.cellElement)) === null || _a === void 0 ? void 0 : _a.focus();\n      }\n    };\n    this.onFocusout = () => {\n      this.focusedCell = null;\n    };\n    this.onKeydown = event => {\n      if (!this.focusedCell) {\n        return;\n      }\n      const ctrlKey = event.ctrlKey ? 1 : 0;\n      const altKey = event.altKey ? 1 : 0;\n      const shiftKey = event.shiftKey ? 1 : 0;\n      const metaKey = event.metaKey ? 1 : 0;\n      const numModifiersPressed = ctrlKey + altKey + shiftKey + metaKey;\n      let key = event.keyCode;\n      if (numModifiersPressed === 1 && event.ctrlKey) {\n        key = -key;\n      } else if (numModifiersPressed) {\n        return;\n      }\n      const from = this.focusedCell;\n      const minExtreme = Number.NEGATIVE_INFINITY;\n      const maxExtreme = Number.POSITIVE_INFINITY;\n      // Do not intercept any keys when the navigation is suppressed.\n      if (this.isSuppressed(from.element)) {\n        return;\n      }\n      switch (key) {\n        case KeyCode.up:\n          event.preventDefault();\n          return moveFocusBy(this.table, from, {\n            y: -1,\n            x: 0\n          });\n        case KeyCode.down:\n          event.preventDefault();\n          return moveFocusBy(this.table, from, {\n            y: 1,\n            x: 0\n          });\n        case KeyCode.left:\n          event.preventDefault();\n          return moveFocusBy(this.table, from, {\n            y: 0,\n            x: -1\n          });\n        case KeyCode.right:\n          event.preventDefault();\n          return moveFocusBy(this.table, from, {\n            y: 0,\n            x: 1\n          });\n        case KeyCode.pageUp:\n          event.preventDefault();\n          return moveFocusBy(this.table, from, {\n            y: -this.pageSize,\n            x: 0\n          });\n        case KeyCode.pageDown:\n          event.preventDefault();\n          return moveFocusBy(this.table, from, {\n            y: this.pageSize,\n            x: 0\n          });\n        case KeyCode.home:\n          event.preventDefault();\n          return moveFocusBy(this.table, from, {\n            y: 0,\n            x: minExtreme\n          });\n        case KeyCode.end:\n          event.preventDefault();\n          return moveFocusBy(this.table, from, {\n            y: 0,\n            x: maxExtreme\n          });\n        case -KeyCode.home:\n          event.preventDefault();\n          return moveFocusBy(this.table, from, {\n            y: minExtreme,\n            x: minExtreme\n          });\n        case -KeyCode.end:\n          event.preventDefault();\n          return moveFocusBy(this.table, from, {\n            y: maxExtreme,\n            x: maxExtreme\n          });\n        default:\n          return;\n      }\n    };\n    this.onTableNodeMutation = mutationRecords => {\n      var _a;\n      // When focused cell is un-mounted the focusout event handler removes this.cell,\n      // while this.prevFocusedCell is retained until the next focusin event.\n      const cell = (_a = this.focusedCell) !== null && _a !== void 0 ? _a : this.prevFocusedCell;\n      const cellSuppressed = cell ? this.isSuppressed(cell.element) : false;\n      // Update table elements focus if new nodes were added.\n      if (mutationRecords.some(record => record.addedNodes.length > 0)) {\n        muteElementFocusables(this.table, cellSuppressed);\n        ensureSingleFocusable(this.table, cell);\n      }\n      if (cell) {\n        for (const record of mutationRecords) {\n          if (record.type === 'childList') {\n            // The lost focus in an unmount event is reapplied to the table using the previous cell position.\n            // The moveFocusBy takes care of finding the closest position if the previous one no longer exists.\n            for (const removedNode of Array.from(record.removedNodes)) {\n              if (removedNode === cell.element || nodeContains(removedNode, cell.element)) {\n                ensureSingleFocusable(this.table, cell);\n                moveFocusBy(this.table, cell, {\n                  y: 0,\n                  x: 0\n                });\n              }\n            }\n          }\n        }\n      }\n    };\n  }\n  init(table, isSuppressed) {\n    this._table = table;\n    this._isSuppressed = isSuppressed;\n    this.table.addEventListener('focusin', this.onFocusin);\n    this.table.addEventListener('focusout', this.onFocusout);\n    this.table.addEventListener('keydown', this.onKeydown);\n    const tableNodesObserver = new MutationObserver(this.onTableNodeMutation);\n    tableNodesObserver.observe(table, {\n      childList: true,\n      subtree: true\n    });\n    muteElementFocusables(this.table, false);\n    ensureSingleFocusable(this.table, null);\n    this.cleanup = () => {\n      this.table.removeEventListener('focusin', this.onFocusin);\n      this.table.removeEventListener('focusout', this.onFocusout);\n      this.table.removeEventListener('keydown', this.onKeydown);\n      tableNodesObserver.disconnect();\n      restoreElementFocusables(this.table);\n    };\n  }\n  cleanup() {\n    // Do nothing before initialized.\n  }\n  update(_ref2) {\n    let {\n      pageSize\n    } = _ref2;\n    this._pageSize = pageSize;\n  }\n  get pageSize() {\n    return this._pageSize;\n  }\n  get table() {\n    if (!this._table) {\n      throw new Error('Invariant violation: GridNavigationHelper is used before initialization.');\n    }\n    return this._table;\n  }\n  isSuppressed(focusedElement) {\n    return defaultIsSuppressed(focusedElement) || this._isSuppressed(focusedElement);\n  }\n}","map":{"version":3,"mappings":"AAAA;AACA;AAEA,SAASA,SAAS,EAAEC,OAAO,QAAQ,OAAO;AAC1C,SACEC,mBAAmB,EACnBC,eAAe,EACfC,WAAW,EACXC,qBAAqB,EACrBC,wBAAwB,EACxBC,qBAAqB,EACrBC,iBAAiB,QACZ,SAAS;AAEhB,SAASC,OAAO,QAAQ,wBAAwB;AAChD,SAASC,YAAY,QAAQ,0CAA0C;AACvE,SAASC,iBAAiB,QAAQ,+CAA+C;AAEjF;;;;;;;AAOA,OAAM,SAAUC,iBAAiB,OAAkE;EAAA,IAAjE;IAAEC,MAAM;IAAEC,QAAQ;IAAEC,QAAQ;IAAEC;EAAY,CAAuB;EACjG,MAAMC,cAAc,GAAGhB,OAAO,CAAC,MAAM,IAAIiB,oBAAoB,EAAE,EAAE,EAAE,CAAC;EAEpE,MAAMC,cAAc,GAAGR,iBAAiB,CAACI,QAAQ,CAAC;EAClD,MAAMK,kBAAkB,GAAGT,iBAAiB,CAAEU,OAAoB,IAAI;IAAA;IAAC,yBAAY,aAAZL,YAAY,uBAAZA,YAAY,CAAGK,OAAO,CAAC,mCAAI,KAAK;EAAA,EAAC;EAExG;EACArB,SAAS,CAAC,MAAK;IACb,IAAIa,MAAM,EAAE;MACV,MAAMS,KAAK,GAAGH,cAAc,EAAE;MAC9BG,KAAK,IAAIL,cAAc,CAACM,IAAI,CAACD,KAAK,EAAEF,kBAAkB,CAAC;;IAEzD,OAAO,MAAMH,cAAc,CAACO,OAAO,EAAE;EACvC,CAAC,EAAE,CAACX,MAAM,EAAEI,cAAc,EAAEE,cAAc,EAAEC,kBAAkB,CAAC,CAAC;EAEhE;EACApB,SAAS,CAAC,MAAK;IACbiB,cAAc,CAACQ,MAAM,CAAC;MAAEX;IAAQ,CAAE,CAAC;EACrC,CAAC,EAAE,CAACG,cAAc,EAAEH,QAAQ,CAAC,CAAC;AAChC;AAEA;;;;;;;;;;;;;AAaA,MAAMI,oBAAoB;EAA1BQ;IACE;IACQ,cAAS,GAAG,CAAC;IACb,WAAM,GAA4B,IAAI;IACtC,kBAAa,GAA6C,MAAM,KAAK;IAE7E;IACQ,oBAAe,GAAuB,IAAI;IAC1C,gBAAW,GAAuB,IAAI;IAkDtC,cAAS,GAAIC,KAAiB,IAAI;;MACxC,MAAMC,IAAI,GAAGzB,eAAe,CAACwB,KAAK,CAAC;MACnC,IAAI,CAACC,IAAI,EAAE;QACT;;MAGF,IAAI,CAACC,eAAe,GAAGD,IAAI;MAC3B,IAAI,CAACE,WAAW,GAAGF,IAAI;MAEvBvB,qBAAqB,CAAC,IAAI,CAACiB,KAAK,EAAE,IAAI,CAACN,YAAY,CAACY,IAAI,CAACP,OAAO,CAAC,CAAC;MAClEd,qBAAqB,CAAC,IAAI,CAACe,KAAK,EAAEM,IAAI,CAAC;MAEvC;MACA;MACA,IAAIA,IAAI,CAACP,OAAO,KAAKO,IAAI,CAACG,WAAW,EAAE;QACrC,uBAAiB,CAACH,IAAI,CAACG,WAAW,CAAC,0CAAEC,KAAK,EAAE;;IAEhD,CAAC;IAEO,eAAU,GAAG,MAAK;MACxB,IAAI,CAACF,WAAW,GAAG,IAAI;IACzB,CAAC;IAEO,cAAS,GAAIH,KAAoB,IAAI;MAC3C,IAAI,CAAC,IAAI,CAACG,WAAW,EAAE;QACrB;;MAGF,MAAMG,OAAO,GAAGN,KAAK,CAACM,OAAO,GAAG,CAAC,GAAG,CAAC;MACrC,MAAMC,MAAM,GAAGP,KAAK,CAACO,MAAM,GAAG,CAAC,GAAG,CAAC;MACnC,MAAMC,QAAQ,GAAGR,KAAK,CAACQ,QAAQ,GAAG,CAAC,GAAG,CAAC;MACvC,MAAMC,OAAO,GAAGT,KAAK,CAACS,OAAO,GAAG,CAAC,GAAG,CAAC;MACrC,MAAMC,mBAAmB,GAAGJ,OAAO,GAAGC,MAAM,GAAGC,QAAQ,GAAGC,OAAO;MAEjE,IAAIE,GAAG,GAAGX,KAAK,CAACY,OAAO;MACvB,IAAIF,mBAAmB,KAAK,CAAC,IAAIV,KAAK,CAACM,OAAO,EAAE;QAC9CK,GAAG,GAAG,CAACA,GAAG;OACX,MAAM,IAAID,mBAAmB,EAAE;QAC9B;;MAGF,MAAMG,IAAI,GAAG,IAAI,CAACV,WAAW;MAC7B,MAAMW,UAAU,GAAGC,MAAM,CAACC,iBAAiB;MAC3C,MAAMC,UAAU,GAAGF,MAAM,CAACG,iBAAiB;MAE3C;MACA,IAAI,IAAI,CAAC7B,YAAY,CAACwB,IAAI,CAACnB,OAAO,CAAC,EAAE;QACnC;;MAGF,QAAQiB,GAAG;QACT,KAAK7B,OAAO,CAACqC,EAAE;UACbnB,KAAK,CAACoB,cAAc,EAAE;UACtB,OAAO3C,WAAW,CAAC,IAAI,CAACkB,KAAK,EAAEkB,IAAI,EAAE;YAAEQ,CAAC,EAAE,CAAC,CAAC;YAAEC,CAAC,EAAE;UAAC,CAAE,CAAC;QAEvD,KAAKxC,OAAO,CAACyC,IAAI;UACfvB,KAAK,CAACoB,cAAc,EAAE;UACtB,OAAO3C,WAAW,CAAC,IAAI,CAACkB,KAAK,EAAEkB,IAAI,EAAE;YAAEQ,CAAC,EAAE,CAAC;YAAEC,CAAC,EAAE;UAAC,CAAE,CAAC;QAEtD,KAAKxC,OAAO,CAAC0C,IAAI;UACfxB,KAAK,CAACoB,cAAc,EAAE;UACtB,OAAO3C,WAAW,CAAC,IAAI,CAACkB,KAAK,EAAEkB,IAAI,EAAE;YAAEQ,CAAC,EAAE,CAAC;YAAEC,CAAC,EAAE,CAAC;UAAC,CAAE,CAAC;QAEvD,KAAKxC,OAAO,CAAC2C,KAAK;UAChBzB,KAAK,CAACoB,cAAc,EAAE;UACtB,OAAO3C,WAAW,CAAC,IAAI,CAACkB,KAAK,EAAEkB,IAAI,EAAE;YAAEQ,CAAC,EAAE,CAAC;YAAEC,CAAC,EAAE;UAAC,CAAE,CAAC;QAEtD,KAAKxC,OAAO,CAAC4C,MAAM;UACjB1B,KAAK,CAACoB,cAAc,EAAE;UACtB,OAAO3C,WAAW,CAAC,IAAI,CAACkB,KAAK,EAAEkB,IAAI,EAAE;YAAEQ,CAAC,EAAE,CAAC,IAAI,CAAClC,QAAQ;YAAEmC,CAAC,EAAE;UAAC,CAAE,CAAC;QAEnE,KAAKxC,OAAO,CAAC6C,QAAQ;UACnB3B,KAAK,CAACoB,cAAc,EAAE;UACtB,OAAO3C,WAAW,CAAC,IAAI,CAACkB,KAAK,EAAEkB,IAAI,EAAE;YAAEQ,CAAC,EAAE,IAAI,CAAClC,QAAQ;YAAEmC,CAAC,EAAE;UAAC,CAAE,CAAC;QAElE,KAAKxC,OAAO,CAAC8C,IAAI;UACf5B,KAAK,CAACoB,cAAc,EAAE;UACtB,OAAO3C,WAAW,CAAC,IAAI,CAACkB,KAAK,EAAEkB,IAAI,EAAE;YAAEQ,CAAC,EAAE,CAAC;YAAEC,CAAC,EAAER;UAAU,CAAE,CAAC;QAE/D,KAAKhC,OAAO,CAAC+C,GAAG;UACd7B,KAAK,CAACoB,cAAc,EAAE;UACtB,OAAO3C,WAAW,CAAC,IAAI,CAACkB,KAAK,EAAEkB,IAAI,EAAE;YAAEQ,CAAC,EAAE,CAAC;YAAEC,CAAC,EAAEL;UAAU,CAAE,CAAC;QAE/D,KAAK,CAACnC,OAAO,CAAC8C,IAAI;UAChB5B,KAAK,CAACoB,cAAc,EAAE;UACtB,OAAO3C,WAAW,CAAC,IAAI,CAACkB,KAAK,EAAEkB,IAAI,EAAE;YAAEQ,CAAC,EAAEP,UAAU;YAAEQ,CAAC,EAAER;UAAU,CAAE,CAAC;QAExE,KAAK,CAAChC,OAAO,CAAC+C,GAAG;UACf7B,KAAK,CAACoB,cAAc,EAAE;UACtB,OAAO3C,WAAW,CAAC,IAAI,CAACkB,KAAK,EAAEkB,IAAI,EAAE;YAAEQ,CAAC,EAAEJ,UAAU;YAAEK,CAAC,EAAEL;UAAU,CAAE,CAAC;QAExE;UACE;MAAO;IAEb,CAAC;IAEO,wBAAmB,GAAIa,eAAiC,IAAI;;MAClE;MACA;MACA,MAAM7B,IAAI,GAAG,UAAI,CAACE,WAAW,mCAAI,IAAI,CAACD,eAAe;MACrD,MAAM6B,cAAc,GAAG9B,IAAI,GAAG,IAAI,CAACZ,YAAY,CAACY,IAAI,CAACP,OAAO,CAAC,GAAG,KAAK;MAErE;MACA,IAAIoC,eAAe,CAACE,IAAI,CAACC,MAAM,IAAIA,MAAM,CAACC,UAAU,CAACC,MAAM,GAAG,CAAC,CAAC,EAAE;QAChEzD,qBAAqB,CAAC,IAAI,CAACiB,KAAK,EAAEoC,cAAc,CAAC;QACjDnD,qBAAqB,CAAC,IAAI,CAACe,KAAK,EAAEM,IAAI,CAAC;;MAGzC,IAAIA,IAAI,EAAE;QACR,KAAK,MAAMgC,MAAM,IAAIH,eAAe,EAAE;UACpC,IAAIG,MAAM,CAACG,IAAI,KAAK,WAAW,EAAE;YAC/B;YACA;YACA,KAAK,MAAMC,WAAW,IAAIC,KAAK,CAACzB,IAAI,CAACoB,MAAM,CAACM,YAAY,CAAC,EAAE;cACzD,IAAIF,WAAW,KAAKpC,IAAI,CAACP,OAAO,IAAIX,YAAY,CAACsD,WAAW,EAAEpC,IAAI,CAACP,OAAO,CAAC,EAAE;gBAC3Ed,qBAAqB,CAAC,IAAI,CAACe,KAAK,EAAEM,IAAI,CAAC;gBACvCxB,WAAW,CAAC,IAAI,CAACkB,KAAK,EAAEM,IAAI,EAAE;kBAAEoB,CAAC,EAAE,CAAC;kBAAEC,CAAC,EAAE;gBAAC,CAAE,CAAC;;;;;;IAMzD,CAAC;EACH;EA3KS1B,IAAI,CAACD,KAAuB,EAAEN,YAAsD;IACzF,IAAI,CAACmD,MAAM,GAAG7C,KAAK;IACnB,IAAI,CAAC8C,aAAa,GAAGpD,YAAY;IAEjC,IAAI,CAACM,KAAK,CAAC+C,gBAAgB,CAAC,SAAS,EAAE,IAAI,CAACC,SAAS,CAAC;IACtD,IAAI,CAAChD,KAAK,CAAC+C,gBAAgB,CAAC,UAAU,EAAE,IAAI,CAACE,UAAU,CAAC;IACxD,IAAI,CAACjD,KAAK,CAAC+C,gBAAgB,CAAC,SAAS,EAAE,IAAI,CAACG,SAAS,CAAC;IAEtD,MAAMC,kBAAkB,GAAG,IAAIC,gBAAgB,CAAC,IAAI,CAACC,mBAAmB,CAAC;IACzEF,kBAAkB,CAACG,OAAO,CAACtD,KAAK,EAAE;MAAEuD,SAAS,EAAE,IAAI;MAAEC,OAAO,EAAE;IAAI,CAAE,CAAC;IAErEzE,qBAAqB,CAAC,IAAI,CAACiB,KAAK,EAAE,KAAK,CAAC;IACxCf,qBAAqB,CAAC,IAAI,CAACe,KAAK,EAAE,IAAI,CAAC;IAEvC,IAAI,CAACE,OAAO,GAAG,MAAK;MAClB,IAAI,CAACF,KAAK,CAACyD,mBAAmB,CAAC,SAAS,EAAE,IAAI,CAACT,SAAS,CAAC;MACzD,IAAI,CAAChD,KAAK,CAACyD,mBAAmB,CAAC,UAAU,EAAE,IAAI,CAACR,UAAU,CAAC;MAC3D,IAAI,CAACjD,KAAK,CAACyD,mBAAmB,CAAC,SAAS,EAAE,IAAI,CAACP,SAAS,CAAC;MAEzDC,kBAAkB,CAACO,UAAU,EAAE;MAE/B1E,wBAAwB,CAAC,IAAI,CAACgB,KAAK,CAAC;IACtC,CAAC;EACH;EAEOE,OAAO;IACZ;EAAA;EAGKC,MAAM,QAAmC;IAAA,IAAlC;MAAEX;IAAQ,CAAwB;IAC9C,IAAI,CAACmE,SAAS,GAAGnE,QAAQ;EAC3B;EAEA,IAAYA,QAAQ;IAClB,OAAO,IAAI,CAACmE,SAAS;EACvB;EAEA,IAAY3D,KAAK;IACf,IAAI,CAAC,IAAI,CAAC6C,MAAM,EAAE;MAChB,MAAM,IAAIe,KAAK,CAAC,0EAA0E,CAAC;;IAE7F,OAAO,IAAI,CAACf,MAAM;EACpB;EAEQnD,YAAY,CAACmE,cAA2B;IAC9C,OAAOjF,mBAAmB,CAACiF,cAAc,CAAC,IAAI,IAAI,CAACf,aAAa,CAACe,cAAc,CAAC;EAClF","names":["useEffect","useMemo","defaultIsSuppressed","findFocusinCell","moveFocusBy","muteElementFocusables","restoreElementFocusables","ensureSingleFocusable","getFirstFocusable","KeyCode","nodeContains","useStableCallback","useGridNavigation","active","pageSize","getTable","isSuppressed","gridNavigation","GridNavigationHelper","getTableStable","isSuppressedStable","element","table","init","cleanup","update","constructor","event","cell","prevFocusedCell","focusedCell","cellElement","focus","ctrlKey","altKey","shiftKey","metaKey","numModifiersPressed","key","keyCode","from","minExtreme","Number","NEGATIVE_INFINITY","maxExtreme","POSITIVE_INFINITY","up","preventDefault","y","x","down","left","right","pageUp","pageDown","home","end","mutationRecords","cellSuppressed","some","record","addedNodes","length","type","removedNode","Array","removedNodes","_table","_isSuppressed","addEventListener","onFocusin","onFocusout","onKeydown","tableNodesObserver","MutationObserver","onTableNodeMutation","observe","childList","subtree","removeEventListener","disconnect","_pageSize","Error","focusedElement"],"sources":["/Users/tangyizhi/Desktop/Assignment2/frontend/node_modules/@cloudscape-design/components/table/table-role/lib/default/table/table-role/use-grid-navigation.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { useEffect, useMemo } from 'react';\nimport {\n  defaultIsSuppressed,\n  findFocusinCell,\n  moveFocusBy,\n  muteElementFocusables,\n  restoreElementFocusables,\n  ensureSingleFocusable,\n  getFirstFocusable,\n} from './utils';\nimport { FocusedCell, GridNavigationProps } from './interfaces';\nimport { KeyCode } from '../../internal/keycode';\nimport { nodeContains } from '@cloudscape-design/component-toolkit/dom';\nimport { useStableCallback } from '@cloudscape-design/component-toolkit/internal';\n\n/**\n * Makes table navigable with keyboard commands.\n * See https://www.w3.org/WAI/ARIA/apg/patterns/grid\n *\n * The hook attaches the GridNavigationHelper helper when active=true.\n * See GridNavigationHelper for more details.\n */\nexport function useGridNavigation({ active, pageSize, getTable, isSuppressed }: GridNavigationProps) {\n  const gridNavigation = useMemo(() => new GridNavigationHelper(), []);\n\n  const getTableStable = useStableCallback(getTable);\n  const isSuppressedStable = useStableCallback((element: HTMLElement) => isSuppressed?.(element) ?? false);\n\n  // Initialize the model with the table container assuming it is mounted synchronously and only once.\n  useEffect(() => {\n    if (active) {\n      const table = getTableStable();\n      table && gridNavigation.init(table, isSuppressedStable);\n    }\n    return () => gridNavigation.cleanup();\n  }, [active, gridNavigation, getTableStable, isSuppressedStable]);\n\n  // Notify the model of the props change.\n  useEffect(() => {\n    gridNavigation.update({ pageSize });\n  }, [gridNavigation, pageSize]);\n}\n\n/**\n * This helper encapsulates the grid navigation behaviors which are:\n * 1. Responding to keyboard commands and moving the focus accordingly;\n * 2. Muting table interactive elements for only one to be user-focusable at a time;\n * 3. Suppressing the above behaviors when focusing an element inside a dialog or when instructed by the isSuppressed callback.\n *\n * All behaviors are attached upon initialization and are re-evaluated with every focusin, focusout, and keydown events,\n * and also when a node removal inside the table is observed to ensure consistency at any given moment.\n *\n * When the navigation is suppressed the keyboard commands are no longer intercepted and all table interactive elements are made\n * user-focusable to unblock the Tab navigation. The suppression should only be used for interactive elements inside the table that would\n * otherwise conflict with the navigation. Once the interactive element is deactivated or lose focus the table navigation becomes active again.\n */\nclass GridNavigationHelper {\n  // Props\n  private _pageSize = 0;\n  private _table: null | HTMLTableElement = null;\n  private _isSuppressed: (focusedElement: HTMLElement) => boolean = () => false;\n\n  // State\n  private prevFocusedCell: null | FocusedCell = null;\n  private focusedCell: null | FocusedCell = null;\n\n  public init(table: HTMLTableElement, isSuppressed: (focusedElement: HTMLElement) => boolean) {\n    this._table = table;\n    this._isSuppressed = isSuppressed;\n\n    this.table.addEventListener('focusin', this.onFocusin);\n    this.table.addEventListener('focusout', this.onFocusout);\n    this.table.addEventListener('keydown', this.onKeydown);\n\n    const tableNodesObserver = new MutationObserver(this.onTableNodeMutation);\n    tableNodesObserver.observe(table, { childList: true, subtree: true });\n\n    muteElementFocusables(this.table, false);\n    ensureSingleFocusable(this.table, null);\n\n    this.cleanup = () => {\n      this.table.removeEventListener('focusin', this.onFocusin);\n      this.table.removeEventListener('focusout', this.onFocusout);\n      this.table.removeEventListener('keydown', this.onKeydown);\n\n      tableNodesObserver.disconnect();\n\n      restoreElementFocusables(this.table);\n    };\n  }\n\n  public cleanup() {\n    // Do nothing before initialized.\n  }\n\n  public update({ pageSize }: { pageSize: number }) {\n    this._pageSize = pageSize;\n  }\n\n  private get pageSize() {\n    return this._pageSize;\n  }\n\n  private get table(): HTMLTableElement {\n    if (!this._table) {\n      throw new Error('Invariant violation: GridNavigationHelper is used before initialization.');\n    }\n    return this._table;\n  }\n\n  private isSuppressed(focusedElement: HTMLElement): boolean {\n    return defaultIsSuppressed(focusedElement) || this._isSuppressed(focusedElement);\n  }\n\n  private onFocusin = (event: FocusEvent) => {\n    const cell = findFocusinCell(event);\n    if (!cell) {\n      return;\n    }\n\n    this.prevFocusedCell = cell;\n    this.focusedCell = cell;\n\n    muteElementFocusables(this.table, this.isSuppressed(cell.element));\n    ensureSingleFocusable(this.table, cell);\n\n    // Focusing on cell is not eligible when it contains focusable elements in the content.\n    // If content focusables are available - move the focus to the first one.\n    if (cell.element === cell.cellElement) {\n      getFirstFocusable(cell.cellElement)?.focus();\n    }\n  };\n\n  private onFocusout = () => {\n    this.focusedCell = null;\n  };\n\n  private onKeydown = (event: KeyboardEvent) => {\n    if (!this.focusedCell) {\n      return;\n    }\n\n    const ctrlKey = event.ctrlKey ? 1 : 0;\n    const altKey = event.altKey ? 1 : 0;\n    const shiftKey = event.shiftKey ? 1 : 0;\n    const metaKey = event.metaKey ? 1 : 0;\n    const numModifiersPressed = ctrlKey + altKey + shiftKey + metaKey;\n\n    let key = event.keyCode;\n    if (numModifiersPressed === 1 && event.ctrlKey) {\n      key = -key;\n    } else if (numModifiersPressed) {\n      return;\n    }\n\n    const from = this.focusedCell;\n    const minExtreme = Number.NEGATIVE_INFINITY;\n    const maxExtreme = Number.POSITIVE_INFINITY;\n\n    // Do not intercept any keys when the navigation is suppressed.\n    if (this.isSuppressed(from.element)) {\n      return;\n    }\n\n    switch (key) {\n      case KeyCode.up:\n        event.preventDefault();\n        return moveFocusBy(this.table, from, { y: -1, x: 0 });\n\n      case KeyCode.down:\n        event.preventDefault();\n        return moveFocusBy(this.table, from, { y: 1, x: 0 });\n\n      case KeyCode.left:\n        event.preventDefault();\n        return moveFocusBy(this.table, from, { y: 0, x: -1 });\n\n      case KeyCode.right:\n        event.preventDefault();\n        return moveFocusBy(this.table, from, { y: 0, x: 1 });\n\n      case KeyCode.pageUp:\n        event.preventDefault();\n        return moveFocusBy(this.table, from, { y: -this.pageSize, x: 0 });\n\n      case KeyCode.pageDown:\n        event.preventDefault();\n        return moveFocusBy(this.table, from, { y: this.pageSize, x: 0 });\n\n      case KeyCode.home:\n        event.preventDefault();\n        return moveFocusBy(this.table, from, { y: 0, x: minExtreme });\n\n      case KeyCode.end:\n        event.preventDefault();\n        return moveFocusBy(this.table, from, { y: 0, x: maxExtreme });\n\n      case -KeyCode.home:\n        event.preventDefault();\n        return moveFocusBy(this.table, from, { y: minExtreme, x: minExtreme });\n\n      case -KeyCode.end:\n        event.preventDefault();\n        return moveFocusBy(this.table, from, { y: maxExtreme, x: maxExtreme });\n\n      default:\n        return;\n    }\n  };\n\n  private onTableNodeMutation = (mutationRecords: MutationRecord[]) => {\n    // When focused cell is un-mounted the focusout event handler removes this.cell,\n    // while this.prevFocusedCell is retained until the next focusin event.\n    const cell = this.focusedCell ?? this.prevFocusedCell;\n    const cellSuppressed = cell ? this.isSuppressed(cell.element) : false;\n\n    // Update table elements focus if new nodes were added.\n    if (mutationRecords.some(record => record.addedNodes.length > 0)) {\n      muteElementFocusables(this.table, cellSuppressed);\n      ensureSingleFocusable(this.table, cell);\n    }\n\n    if (cell) {\n      for (const record of mutationRecords) {\n        if (record.type === 'childList') {\n          // The lost focus in an unmount event is reapplied to the table using the previous cell position.\n          // The moveFocusBy takes care of finding the closest position if the previous one no longer exists.\n          for (const removedNode of Array.from(record.removedNodes)) {\n            if (removedNode === cell.element || nodeContains(removedNode, cell.element)) {\n              ensureSingleFocusable(this.table, cell);\n              moveFocusBy(this.table, cell, { y: 0, x: 0 });\n            }\n          }\n        }\n      }\n    }\n  };\n}\n"]},"metadata":{},"sourceType":"module"}