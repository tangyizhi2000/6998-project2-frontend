{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { useStableCallback } from \"@cloudscape-design/component-toolkit/internal\";\nimport { useEffect } from \"react\";\nimport { Coordinates } from \"../utils/coordinates\";\nimport { EventEmitter } from \"./event-emitter\";\nimport { getHoveredDroppables } from \"./get-hovered-droppables\";\nclass DragAndDropController extends EventEmitter {\n  constructor() {\n    super(...arguments);\n    this.droppables = new Map();\n    this.transition = null;\n  }\n  /**\n   * Inits a drag transition and issues a \"start\" event.\n   *\n   * The method overrides the previous transition if exists (w/o a cancellation event)!\n   */\n  start(transition) {\n    this.transition = {\n      ...transition\n    };\n    this.emit(\"start\", this.getDragAndDropData(transition.startCoordinates));\n  }\n  /**\n   * Updates current transition with given coordinates and issues an \"update\" event.\n   */\n  update(coordinates) {\n    this.emit(\"update\", this.getDragAndDropData(coordinates));\n  }\n  /**\n   * Removes transition and issues a \"submit\" event.\n   */\n  submit() {\n    this.emit(\"submit\");\n    this.transition = null;\n  }\n  /**\n   * Removes transition and issues a \"discard\" event.\n   */\n  discard() {\n    this.emit(\"discard\");\n    this.transition = null;\n  }\n  /**\n   * Issues an \"acquire\" event to notify the current transition draggable is acquired by the given droppable.\n   */\n  acquire(droppableId, renderAcquiredItem) {\n    if (!this.transition) {\n      throw new Error(\"Invariant violation: no transition present for acquire.\");\n    }\n    this.emit(\"acquire\", {\n      droppableId,\n      draggableItem: this.transition.draggableItem,\n      renderAcquiredItem\n    });\n  }\n  /**\n   * Registers a droppable used for collisions check, acquire, and dropTarget provision.\n   */\n  addDroppable(id, context, element) {\n    this.droppables.set(id, {\n      element,\n      context\n    });\n  }\n  /**\n   * Un-registers the droppable - use it when component unmounts.\n   */\n  removeDroppable(id) {\n    this.droppables.delete(id);\n  }\n  /**\n   * Retrieves all registered droppables to run a manual match against.\n   */\n  getDroppables() {\n    return [...this.droppables.entries()];\n  }\n  getDragAndDropData(coordinates) {\n    if (!this.transition) {\n      throw new Error(\"Invariant violation: no transition present for interaction.\");\n    }\n    const positionOffset = Coordinates.cursorOffset(coordinates, this.transition.startCoordinates);\n    const collisionRect = this.getCollisionRect(this.transition, coordinates);\n    const {\n      collisionIds,\n      dropTarget\n    } = this.getCollisions(collisionRect);\n    return {\n      ...this.transition,\n      positionOffset,\n      coordinates,\n      collisionRect,\n      collisionIds,\n      dropTarget\n    };\n  }\n  getCollisionRect(transition, coordinates) {\n    const originalCollisionRect = transition.getCollisionRect(transition.operation, coordinates, null);\n    const {\n      dropTarget\n    } = this.getCollisions(originalCollisionRect);\n    return transition.getCollisionRect(transition.operation, coordinates, dropTarget);\n  }\n  getCollisions(collisionRect) {\n    const droppableEntries = [...this.droppables.entries()];\n    const droppableElements = droppableEntries.map(_ref => {\n      let [id, entry] = _ref;\n      return [id, entry.element];\n    });\n    const collisionIds = getHoveredDroppables(collisionRect, droppableElements);\n    if (collisionIds.length === 0) {\n      return {\n        collisionIds,\n        dropTarget: null\n      };\n    }\n    const matchedDroppable = droppableEntries.find(_ref2 => {\n      let [id] = _ref2;\n      return id === collisionIds[0];\n    });\n    if (!matchedDroppable) {\n      throw new Error(\"Invariant violation: no droppable matches collision.\");\n    }\n    return {\n      collisionIds,\n      dropTarget: matchedDroppable[1].context\n    };\n  }\n}\n// Controller is a singleton and is shared between all d&d elements.\nconst controller = new DragAndDropController();\nexport function useDragSubscription(event, handler) {\n  const stableHandler = useStableCallback(handler);\n  useEffect(() => controller.on(event, stableHandler), [event, stableHandler]);\n}\nexport function useDraggable(_ref3) {\n  let {\n    draggableItem,\n    getCollisionRect\n  } = _ref3;\n  return {\n    start(operation, interactionType, startCoordinates) {\n      controller.start({\n        operation,\n        interactionType,\n        draggableItem,\n        getCollisionRect,\n        startCoordinates\n      });\n    },\n    updateTransition(coordinates) {\n      controller.update(coordinates);\n    },\n    submitTransition() {\n      controller.submit();\n    },\n    discardTransition() {\n      controller.discard();\n    },\n    acquire(droppableId, renderAcquiredItem) {\n      controller.acquire(droppableId, renderAcquiredItem);\n    },\n    getDroppables() {\n      return controller.getDroppables();\n    }\n  };\n}\nexport function useDroppable(_ref4) {\n  let {\n    itemId,\n    context,\n    getElement\n  } = _ref4;\n  useEffect(() => {\n    controller.addDroppable(itemId, context, getElement());\n    return () => controller.removeDroppable(itemId);\n  }, [itemId, context, getElement]);\n}","map":{"version":3,"names":["useStableCallback","useEffect","Coordinates","EventEmitter","getHoveredDroppables","DragAndDropController","constructor","arguments","droppables","Map","transition","start","emit","getDragAndDropData","startCoordinates","update","coordinates","submit","discard","acquire","droppableId","renderAcquiredItem","Error","draggableItem","addDroppable","id","context","element","set","removeDroppable","delete","getDroppables","entries","positionOffset","cursorOffset","collisionRect","getCollisionRect","collisionIds","dropTarget","getCollisions","originalCollisionRect","operation","droppableEntries","droppableElements","map","entry","length","matchedDroppable","find","controller","useDragSubscription","event","handler","stableHandler","on","useDraggable","interactionType","updateTransition","submitTransition","discardTransition","useDroppable","itemId","getElement"],"sources":["/Users/tangyizhi/Desktop/Assignment 2/frontend/node_modules/@cloudscape-design/board-components/internal/dnd-controller/controller.js"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { useStableCallback } from \"@cloudscape-design/component-toolkit/internal\";\nimport { useEffect } from \"react\";\nimport { Coordinates } from \"../utils/coordinates\";\nimport { EventEmitter } from \"./event-emitter\";\nimport { getHoveredDroppables } from \"./get-hovered-droppables\";\nclass DragAndDropController extends EventEmitter {\n    constructor() {\n        super(...arguments);\n        this.droppables = new Map();\n        this.transition = null;\n    }\n    /**\n     * Inits a drag transition and issues a \"start\" event.\n     *\n     * The method overrides the previous transition if exists (w/o a cancellation event)!\n     */\n    start(transition) {\n        this.transition = { ...transition };\n        this.emit(\"start\", this.getDragAndDropData(transition.startCoordinates));\n    }\n    /**\n     * Updates current transition with given coordinates and issues an \"update\" event.\n     */\n    update(coordinates) {\n        this.emit(\"update\", this.getDragAndDropData(coordinates));\n    }\n    /**\n     * Removes transition and issues a \"submit\" event.\n     */\n    submit() {\n        this.emit(\"submit\");\n        this.transition = null;\n    }\n    /**\n     * Removes transition and issues a \"discard\" event.\n     */\n    discard() {\n        this.emit(\"discard\");\n        this.transition = null;\n    }\n    /**\n     * Issues an \"acquire\" event to notify the current transition draggable is acquired by the given droppable.\n     */\n    acquire(droppableId, renderAcquiredItem) {\n        if (!this.transition) {\n            throw new Error(\"Invariant violation: no transition present for acquire.\");\n        }\n        this.emit(\"acquire\", { droppableId, draggableItem: this.transition.draggableItem, renderAcquiredItem });\n    }\n    /**\n     * Registers a droppable used for collisions check, acquire, and dropTarget provision.\n     */\n    addDroppable(id, context, element) {\n        this.droppables.set(id, { element, context });\n    }\n    /**\n     * Un-registers the droppable - use it when component unmounts.\n     */\n    removeDroppable(id) {\n        this.droppables.delete(id);\n    }\n    /**\n     * Retrieves all registered droppables to run a manual match against.\n     */\n    getDroppables() {\n        return [...this.droppables.entries()];\n    }\n    getDragAndDropData(coordinates) {\n        if (!this.transition) {\n            throw new Error(\"Invariant violation: no transition present for interaction.\");\n        }\n        const positionOffset = Coordinates.cursorOffset(coordinates, this.transition.startCoordinates);\n        const collisionRect = this.getCollisionRect(this.transition, coordinates);\n        const { collisionIds, dropTarget } = this.getCollisions(collisionRect);\n        return { ...this.transition, positionOffset, coordinates, collisionRect, collisionIds, dropTarget };\n    }\n    getCollisionRect(transition, coordinates) {\n        const originalCollisionRect = transition.getCollisionRect(transition.operation, coordinates, null);\n        const { dropTarget } = this.getCollisions(originalCollisionRect);\n        return transition.getCollisionRect(transition.operation, coordinates, dropTarget);\n    }\n    getCollisions(collisionRect) {\n        const droppableEntries = [...this.droppables.entries()];\n        const droppableElements = droppableEntries.map(([id, entry]) => [id, entry.element]);\n        const collisionIds = getHoveredDroppables(collisionRect, droppableElements);\n        if (collisionIds.length === 0) {\n            return { collisionIds, dropTarget: null };\n        }\n        const matchedDroppable = droppableEntries.find(([id]) => id === collisionIds[0]);\n        if (!matchedDroppable) {\n            throw new Error(\"Invariant violation: no droppable matches collision.\");\n        }\n        return { collisionIds, dropTarget: matchedDroppable[1].context };\n    }\n}\n// Controller is a singleton and is shared between all d&d elements.\nconst controller = new DragAndDropController();\nexport function useDragSubscription(event, handler) {\n    const stableHandler = useStableCallback(handler);\n    useEffect(() => controller.on(event, stableHandler), [event, stableHandler]);\n}\nexport function useDraggable({ draggableItem, getCollisionRect, }) {\n    return {\n        start(operation, interactionType, startCoordinates) {\n            controller.start({ operation, interactionType, draggableItem, getCollisionRect, startCoordinates });\n        },\n        updateTransition(coordinates) {\n            controller.update(coordinates);\n        },\n        submitTransition() {\n            controller.submit();\n        },\n        discardTransition() {\n            controller.discard();\n        },\n        acquire(droppableId, renderAcquiredItem) {\n            controller.acquire(droppableId, renderAcquiredItem);\n        },\n        getDroppables() {\n            return controller.getDroppables();\n        },\n    };\n}\nexport function useDroppable({ itemId, context, getElement, }) {\n    useEffect(() => {\n        controller.addDroppable(itemId, context, getElement());\n        return () => controller.removeDroppable(itemId);\n    }, [itemId, context, getElement]);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}