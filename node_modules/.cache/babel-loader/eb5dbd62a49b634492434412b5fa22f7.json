{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/tangyizhi/Desktop/Assignment2/frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport { isXThreshold, isYThreshold } from './utils';\n/** Combine all line series into an array of scaled data points with the given scales. */\nexport default function makeScaledSeries(allSeries, xScale, yScale) {\n  var xOffset = xScale.isCategorical() ? Math.max(0, xScale.d3Scale.bandwidth() - 1) / 2 : 0;\n  var scaleX = function scaleX(x) {\n    return (xScale.d3Scale(x) || 0) + xOffset;\n  };\n  var scaleY = function scaleY(y) {\n    return yScale.d3Scale(y) || 0;\n  };\n  var allX = getAllX(allSeries);\n  function mergeLineSeriesPointsWithXThresholds(scaledPoints, xThresholdSeries, xThresholdSeriesColor) {\n    var _a, _b;\n    var x = scaleX(xThresholdSeries.x);\n    // Locate a point the x-threshold can be inserted after (if such exists).\n    var bisectIndex = -1;\n    for (var i = 0; i < scaledPoints.length - 1; i++) {\n      if (scaledPoints[i].x < x && x < scaledPoints[i + 1].x) {\n        bisectIndex = i;\n        break;\n      }\n    }\n    // Insert x-threshold point into the given series using extrapolated Y value.\n    // The extrapolated value is only used to render highlighted point on the chart plot.\n    if (bisectIndex !== -1) {\n      var prevY = ((_a = scaledPoints[bisectIndex].datum) === null || _a === void 0 ? void 0 : _a.y) || 0;\n      var nextY = ((_b = scaledPoints[bisectIndex + 1].datum) === null || _b === void 0 ? void 0 : _b.y) || 0;\n      var averageY = (prevY + nextY) / 2;\n      scaledPoints.push({\n        x: x,\n        y: scaleY(averageY),\n        datum: {\n          x: xThresholdSeries.x,\n          y: NaN\n        },\n        series: scaledPoints[bisectIndex].series,\n        color: xThresholdSeriesColor\n      });\n    }\n  }\n  var scaledSeriesX = allSeries.map(function (_ref) {\n    var series = _ref.series,\n      color = _ref.color;\n    var scaledPoints = [];\n    // Scale and add all line series data points.\n    if (series.type === 'line') {\n      var _iterator = _createForOfIteratorHelper(series.data),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var datum = _step.value;\n          scaledPoints.push({\n            x: scaleX(datum.x),\n            y: scaleY(datum.y),\n            datum: datum,\n            series: series,\n            color: color\n          });\n        }\n        // Sort scaled points to ensure correct x-thresholds insertion.\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      scaledPoints.sort(function (s1, s2) {\n        return s1.x - s2.x;\n      });\n      // Merge x-thresholds into series if they don't have a shared coordinate.\n      var _iterator2 = _createForOfIteratorHelper(allSeries),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var otherSeries = _step2.value;\n          if (isXThreshold(otherSeries.series)) {\n            mergeLineSeriesPointsWithXThresholds(scaledPoints, otherSeries.series, otherSeries.color);\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n    // Y-thresholds only have Y. To make thresholds navigable they are mapped to all defined X values.\n    else if (isYThreshold(series)) {\n      var _iterator3 = _createForOfIteratorHelper(allX),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var x = _step3.value;\n          scaledPoints.push({\n            x: scaleX(x),\n            y: scaleY(series.y),\n            datum: {\n              x: x,\n              y: series.y\n            },\n            series: series,\n            color: color\n          });\n        }\n        // Support threshold-only setup.\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n      if (allX.length === 0) {\n        scaledPoints.push({\n          x: NaN,\n          y: scaleY(series.y),\n          series: series,\n          color: color\n        });\n      }\n    }\n    // X-thresholds only have X. The y value is taken as NaN which means there is no associated point - only vertical marker.\n    else if (isXThreshold(series)) {\n      scaledPoints.push({\n        x: scaleX(series.x),\n        y: NaN,\n        datum: {\n          x: series.x,\n          y: NaN\n        },\n        series: series,\n        color: color\n      });\n    }\n    // Bar series are handled separately.\n    return scaledPoints;\n  });\n  // Sort scaled points by x to ensure their order matches visual order in the chart to support navigation.\n  return flatten(scaledSeriesX).sort(function (s1, s2) {\n    return s1.x - s2.x;\n  });\n}\n/** Collect unique x values from all data series. */\nfunction getAllX(series) {\n  var addDataXSet = new Set();\n  var _iterator4 = _createForOfIteratorHelper(series),\n    _step4;\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var s = _step4.value.series;\n      switch (s.type) {\n        // Add all X values from data series.\n        case 'bar':\n        case 'line':\n          var _iterator5 = _createForOfIteratorHelper(s.data),\n            _step5;\n          try {\n            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n              var d = _step5.value;\n              addDataXSet.add(d.x);\n            }\n          } catch (err) {\n            _iterator5.e(err);\n          } finally {\n            _iterator5.f();\n          }\n          break;\n        case 'threshold':\n          // X-thresholds have a single X value.\n          if (isXThreshold(s)) {\n            addDataXSet.add(s.x);\n          }\n          // Thresholds don't have X values.\n          break;\n      }\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n  var allDataX = [];\n  addDataXSet.forEach(function (x) {\n    return allDataX.push(x);\n  });\n  return allDataX;\n}\nfunction flatten(arrays) {\n  var merged = [];\n  var _iterator6 = _createForOfIteratorHelper(arrays),\n    _step6;\n  try {\n    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n      var array = _step6.value;\n      var _iterator7 = _createForOfIteratorHelper(array),\n        _step7;\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var item = _step7.value;\n          merged.push(item);\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n    }\n  } catch (err) {\n    _iterator6.e(err);\n  } finally {\n    _iterator6.f();\n  }\n  return merged;\n}","map":{"version":3,"mappings":"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","names":["isXThreshold","isYThreshold","makeScaledSeries","allSeries","xScale","yScale","xOffset","isCategorical","Math","max","d3Scale","bandwidth","scaleX","x","scaleY","y","allX","getAllX","mergeLineSeriesPointsWithXThresholds","scaledPoints","xThresholdSeries","xThresholdSeriesColor","bisectIndex","i","length","prevY","datum","nextY","averageY","push","NaN","series","color","scaledSeriesX","map","type","data","sort","s1","s2","otherSeries","flatten","addDataXSet","Set","s","d","add","allDataX","forEach","arrays","merged","array","item"],"sources":["/Users/tangyizhi/Desktop/Assignment2/frontend/node_modules/@cloudscape-design/components/mixed-line-bar-chart/lib/default/mixed-line-bar-chart/make-scaled-series.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { ChartDataTypes, InternalChartSeries, MixedLineBarChartProps } from './interfaces';\nimport { ChartScale, NumericChartScale } from '../internal/components/cartesian-chart/scales';\nimport { isXThreshold, isYThreshold } from './utils';\n\nexport interface ScaledPoint<T> {\n  x: number;\n  y: number;\n  color: string;\n  datum?: MixedLineBarChartProps.Datum<T> | undefined;\n  series: MixedLineBarChartProps.ChartSeries<T>;\n}\n\n/** Combine all line series into an array of scaled data points with the given scales. */\nexport default function makeScaledSeries<T extends ChartDataTypes>(\n  allSeries: ReadonlyArray<InternalChartSeries<T>>,\n  xScale: ChartScale,\n  yScale: NumericChartScale\n): readonly ScaledPoint<T>[] {\n  const xOffset = xScale.isCategorical() ? Math.max(0, xScale.d3Scale.bandwidth() - 1) / 2 : 0;\n  const scaleX = (x: T) => (xScale.d3Scale(x as any) || 0) + xOffset;\n  const scaleY = (y: number) => yScale.d3Scale(y) || 0;\n  const allX = getAllX(allSeries);\n\n  function mergeLineSeriesPointsWithXThresholds(\n    scaledPoints: ScaledPoint<T>[],\n    xThresholdSeries: MixedLineBarChartProps.ThresholdSeries<T> & { x: T },\n    xThresholdSeriesColor: string\n  ) {\n    const x = scaleX(xThresholdSeries.x);\n\n    // Locate a point the x-threshold can be inserted after (if such exists).\n    let bisectIndex = -1;\n    for (let i = 0; i < scaledPoints.length - 1; i++) {\n      if (scaledPoints[i].x < x && x < scaledPoints[i + 1].x) {\n        bisectIndex = i;\n        break;\n      }\n    }\n\n    // Insert x-threshold point into the given series using extrapolated Y value.\n    // The extrapolated value is only used to render highlighted point on the chart plot.\n    if (bisectIndex !== -1) {\n      const prevY = scaledPoints[bisectIndex].datum?.y || 0;\n      const nextY = scaledPoints[bisectIndex + 1].datum?.y || 0;\n      const averageY = (prevY + nextY) / 2;\n      scaledPoints.push({\n        x: x,\n        y: scaleY(averageY),\n        datum: { x: xThresholdSeries.x, y: NaN },\n        series: scaledPoints[bisectIndex].series,\n        color: xThresholdSeriesColor,\n      });\n    }\n  }\n\n  const scaledSeriesX = allSeries.map(({ series, color }) => {\n    const scaledPoints: ScaledPoint<T>[] = [];\n\n    // Scale and add all line series data points.\n    if (series.type === 'line') {\n      for (const datum of series.data as MixedLineBarChartProps.Datum<T>[]) {\n        scaledPoints.push({ x: scaleX(datum.x), y: scaleY(datum.y), datum, series, color });\n      }\n\n      // Sort scaled points to ensure correct x-thresholds insertion.\n      scaledPoints.sort((s1, s2) => s1.x - s2.x);\n\n      // Merge x-thresholds into series if they don't have a shared coordinate.\n      for (const otherSeries of allSeries) {\n        if (isXThreshold(otherSeries.series)) {\n          mergeLineSeriesPointsWithXThresholds(scaledPoints, otherSeries.series, otherSeries.color);\n        }\n      }\n    }\n    // Y-thresholds only have Y. To make thresholds navigable they are mapped to all defined X values.\n    else if (isYThreshold(series)) {\n      for (const x of allX) {\n        scaledPoints.push({ x: scaleX(x), y: scaleY(series.y), datum: { x, y: series.y }, series, color });\n      }\n      // Support threshold-only setup.\n      if (allX.length === 0) {\n        scaledPoints.push({ x: NaN, y: scaleY(series.y), series, color });\n      }\n    }\n    // X-thresholds only have X. The y value is taken as NaN which means there is no associated point - only vertical marker.\n    else if (isXThreshold(series)) {\n      scaledPoints.push({ x: scaleX(series.x), y: NaN, datum: { x: series.x, y: NaN }, series, color });\n    }\n    // Bar series are handled separately.\n    return scaledPoints;\n  });\n\n  // Sort scaled points by x to ensure their order matches visual order in the chart to support navigation.\n  return flatten(scaledSeriesX).sort((s1, s2) => s1.x - s2.x);\n}\n\n/** Collect unique x values from all data series. */\nfunction getAllX<T>(series: ReadonlyArray<InternalChartSeries<T>>) {\n  const addDataXSet = new Set<T>();\n  for (const { series: s } of series) {\n    switch (s.type) {\n      // Add all X values from data series.\n      case 'bar':\n      case 'line':\n        for (const d of s.data) {\n          addDataXSet.add(d.x);\n        }\n        break;\n\n      case 'threshold':\n        // X-thresholds have a single X value.\n        if (isXThreshold(s)) {\n          addDataXSet.add(s.x);\n        }\n        // Thresholds don't have X values.\n        break;\n    }\n  }\n  const allDataX: T[] = [];\n  addDataXSet.forEach(x => allDataX.push(x));\n\n  return allDataX;\n}\n\nfunction flatten<T>(arrays: T[][]): T[] {\n  const merged: T[] = [];\n  for (const array of arrays) {\n    for (const item of array) {\n      merged.push(item);\n    }\n  }\n  return merged;\n}\n"]},"metadata":{},"sourceType":"module"}