{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/tangyizhi/Desktop/Assignment2/frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _slicedToArray from \"/Users/tangyizhi/Desktop/Assignment2/frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nvar BREAKPOINT_MAPPING = [['xl', 1840], ['l', 1320], ['m', 1120], ['s', 912], ['xs', 688], ['xxs', 465], ['default', -1]];\nexport var mobileBreakpoint = BREAKPOINT_MAPPING.filter(function (b) {\n  return b[0] === 'xs';\n})[0][1];\nvar BREAKPOINTS_DESCENDING = BREAKPOINT_MAPPING.map(function (_ref) {\n  var _ref2 = _slicedToArray(_ref, 1),\n    bp = _ref2[0];\n  return bp;\n});\n/**\n * Take a breakpoint mapping and return the breakpoint value that most closely matches the actual breakpoint.\n */\nexport function matchBreakpointMapping(subset, actual) {\n  var qualifyingBreakpoints = BREAKPOINT_MAPPING.slice(BREAKPOINTS_DESCENDING.indexOf(actual));\n  var _iterator = _createForOfIteratorHelper(qualifyingBreakpoints),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _step$value = _slicedToArray(_step.value, 1),\n        breakpoint = _step$value[0];\n      var breakpointValue = subset[breakpoint];\n      if (breakpointValue !== undefined) {\n        return breakpointValue;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return null;\n}\n/**\n * Get the named breakpoint for a provided width, optionally filtering to a subset of breakpoints.\n */\nexport function getMatchingBreakpoint(width, breakpointFilter) {\n  var _iterator2 = _createForOfIteratorHelper(BREAKPOINT_MAPPING),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var _step2$value = _slicedToArray(_step2.value, 2),\n        breakpoint = _step2$value[0],\n        breakpointWidth = _step2$value[1];\n      if (width > breakpointWidth && (!breakpointFilter || breakpointFilter.indexOf(breakpoint) !== -1)) {\n        return breakpoint;\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  return 'default';\n}\nexport function getBreakpointValue(breakpoint) {\n  return BREAKPOINT_MAPPING.find(function (bp) {\n    return bp[0] === breakpoint;\n  })[1];\n}","map":{"version":3,"mappings":";;AAIA,IAAMA,kBAAkB,GAA2B,CACjD,CAAC,IAAI,EAAE,IAAI,CAAC,EACZ,CAAC,GAAG,EAAE,IAAI,CAAC,EACX,CAAC,GAAG,EAAE,IAAI,CAAC,EACX,CAAC,GAAG,EAAE,GAAG,CAAC,EACV,CAAC,IAAI,EAAE,GAAG,CAAC,EACX,CAAC,KAAK,EAAE,GAAG,CAAC,EACZ,CAAC,SAAS,EAAE,CAAC,CAAC,CAAC,CAChB;AAED,OAAO,IAAMC,gBAAgB,GAAGD,kBAAkB,CAACE,MAAM,CAAC,WAAC;EAAA,OAAIC,CAAC,CAAC,CAAC,CAAC,KAAK,IAAI;AAAA,EAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAEnF,IAAMC,sBAAsB,GAAGJ,kBAAkB,CAACK,GAAG,CAAC;EAAA;IAAEC,EAAE;EAAA,OAAMA,EAAE;AAAA,EAAC;AAEnE;;;AAGA,OAAM,SAAUC,sBAAsB,CAAIC,MAAsC,EAAEC,MAAkB;EAClG,IAAMC,qBAAqB,GAAGV,kBAAkB,CAACW,KAAK,CAACP,sBAAsB,CAACQ,OAAO,CAACH,MAAM,CAAC,CAAC;EAAC,2CACpEC,qBAAqB;IAAA;EAAA;IAAhD,oDAAkD;MAAA;QAAtCG,UAAU;MACpB,IAAMC,eAAe,GAAGN,MAAM,CAACK,UAAU,CAAC;MAC1C,IAAIC,eAAe,KAAKC,SAAS,EAAE;QACjC,OAAOD,eAAe;;;EAEzB;IAAA;EAAA;IAAA;EAAA;EACD,OAAO,IAAI;AACb;AAEA;;;AAGA,OAAM,SAAUE,qBAAqB,CAACC,KAAa,EAAEC,gBAAwC;EAAA,4CAC/ClB,kBAAkB;IAAA;EAAA;IAA9D,uDAAgE;MAAA;QAApDa,UAAU;QAAEM,eAAe;MACrC,IAAIF,KAAK,GAAGE,eAAe,KAAK,CAACD,gBAAgB,IAAIA,gBAAgB,CAACN,OAAO,CAACC,UAAU,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE;QACjG,OAAOA,UAAU;;;EAEpB;IAAA;EAAA;IAAA;EAAA;EACD,OAAO,SAAS;AAClB;AAEA,OAAM,SAAUO,kBAAkB,CAACP,UAAsB;EACvD,OAAOb,kBAAkB,CAACqB,IAAI,CAAC,YAAE;IAAA,OAAIf,EAAE,CAAC,CAAC,CAAC,KAAKO,UAAU;EAAA,EAAE,CAAC,CAAC,CAAC;AAChE","names":["BREAKPOINT_MAPPING","mobileBreakpoint","filter","b","BREAKPOINTS_DESCENDING","map","bp","matchBreakpointMapping","subset","actual","qualifyingBreakpoints","slice","indexOf","breakpoint","breakpointValue","undefined","getMatchingBreakpoint","width","breakpointFilter","breakpointWidth","getBreakpointValue","find"],"sources":["/Users/tangyizhi/Desktop/Assignment2/frontend/node_modules/@cloudscape-design/components/internal/lib/default/internal/breakpoints.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nexport type Breakpoint = 'default' | 'xxs' | 'xs' | 's' | 'm' | 'l' | 'xl';\n\nconst BREAKPOINT_MAPPING: [Breakpoint, number][] = [\n  ['xl', 1840],\n  ['l', 1320],\n  ['m', 1120],\n  ['s', 912],\n  ['xs', 688],\n  ['xxs', 465],\n  ['default', -1],\n];\n\nexport const mobileBreakpoint = BREAKPOINT_MAPPING.filter(b => b[0] === 'xs')[0][1];\n\nconst BREAKPOINTS_DESCENDING = BREAKPOINT_MAPPING.map(([bp]) => bp);\n\n/**\n * Take a breakpoint mapping and return the breakpoint value that most closely matches the actual breakpoint.\n */\nexport function matchBreakpointMapping<T>(subset: Partial<Record<Breakpoint, T>>, actual: Breakpoint): T | null {\n  const qualifyingBreakpoints = BREAKPOINT_MAPPING.slice(BREAKPOINTS_DESCENDING.indexOf(actual));\n  for (const [breakpoint] of qualifyingBreakpoints) {\n    const breakpointValue = subset[breakpoint];\n    if (breakpointValue !== undefined) {\n      return breakpointValue;\n    }\n  }\n  return null;\n}\n\n/**\n * Get the named breakpoint for a provided width, optionally filtering to a subset of breakpoints.\n */\nexport function getMatchingBreakpoint(width: number, breakpointFilter?: readonly Breakpoint[]): Breakpoint {\n  for (const [breakpoint, breakpointWidth] of BREAKPOINT_MAPPING) {\n    if (width > breakpointWidth && (!breakpointFilter || breakpointFilter.indexOf(breakpoint) !== -1)) {\n      return breakpoint;\n    }\n  }\n  return 'default';\n}\n\nexport function getBreakpointValue(breakpoint: Breakpoint): number {\n  return BREAKPOINT_MAPPING.find(bp => bp[0] === breakpoint)![1];\n}\n"]},"metadata":{},"sourceType":"module"}