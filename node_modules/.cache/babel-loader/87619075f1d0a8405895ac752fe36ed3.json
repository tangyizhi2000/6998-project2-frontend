{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/tangyizhi/Desktop/Assignment2/frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { getFocusables as getActualFocusables } from '../../internal/components/focus-lock/utils';\n// For the grid to have a single Tab stop all interactive element indices are updated to be -999.\n// The elements having tab index -999 are eligible for keyboard navigation but not for Tab navigation.\nvar PSEUDO_FOCUSABLE_TAB_INDEX = -999;\nvar FOCUSABLES_SELECTOR = \"[tabIndex=\\\"0\\\"],[tabIndex=\\\"\".concat(PSEUDO_FOCUSABLE_TAB_INDEX, \"\\\"]\");\n/**\n * Finds focused cell props corresponding the focused element inside the table.\n * The function relies on ARIA colindex/rowindex attributes being correctly applied.\n */\nexport function findFocusinCell(event) {\n  var _a, _b;\n  if (!(event.target instanceof HTMLElement)) {\n    return null;\n  }\n  var element = event.target;\n  var cellElement = element.closest('td,th');\n  var rowElement = cellElement === null || cellElement === void 0 ? void 0 : cellElement.closest('tr');\n  if (!cellElement || !rowElement) {\n    return null;\n  }\n  var colIndex = parseInt((_a = cellElement.getAttribute('aria-colindex')) !== null && _a !== void 0 ? _a : '');\n  var rowIndex = parseInt((_b = rowElement.getAttribute('aria-rowindex')) !== null && _b !== void 0 ? _b : '');\n  if (isNaN(colIndex) || isNaN(rowIndex)) {\n    return null;\n  }\n  var cellFocusables = getFocusables(cellElement);\n  var elementIndex = cellFocusables.indexOf(element);\n  return {\n    rowIndex: rowIndex,\n    colIndex: colIndex,\n    rowElement: rowElement,\n    cellElement: cellElement,\n    element: element,\n    elementIndex: elementIndex\n  };\n}\n/**\n * Moves table focus in the provided direction. The focus can transition between cells or interactive elements inside cells.\n */\nexport function moveFocusBy(table, from, delta) {\n  var _a;\n  // Find next row to move focus into (can be null if the top/bottom is reached).\n  var targetAriaRowIndex = from.rowIndex + delta.y;\n  var targetRow = findTableRowByAriaRowIndex(table, targetAriaRowIndex, delta.y);\n  if (!targetRow) {\n    return;\n  }\n  // Move focus to the next interactive cell content element if available.\n  var cellFocusables = getFocusables(from.cellElement);\n  var nextElementIndex = from.elementIndex + delta.x;\n  if (delta.x && from.elementIndex !== -1 && 0 <= nextElementIndex && nextElementIndex < cellFocusables.length) {\n    focus(cellFocusables[nextElementIndex]);\n    return;\n  }\n  // Find next cell to focus or move focus into (can be null if the left/right edge is reached).\n  var targetAriaColIndex = from.colIndex + delta.x;\n  var targetCell = findTableRowCellByAriaColIndex(targetRow, targetAriaColIndex, delta.x);\n  if (!targetCell) {\n    return;\n  }\n  // Move focus on the cell interactive content or the cell itself.\n  var targetCellFocusables = getFocusables(targetCell);\n  var focusIndex = delta.x < 0 ? targetCellFocusables.length - 1 : delta.x > 0 ? 0 : from.elementIndex;\n  var focusTarget = (_a = targetCellFocusables[focusIndex]) !== null && _a !== void 0 ? _a : targetCell;\n  focus(focusTarget);\n}\n/**\n * Makes the cell element, the first interactive element or the first cell of the table user-focusable.\n */\nexport function ensureSingleFocusable(table, cell) {\n  var _a;\n  var firstTableCell = table.querySelector('td,th');\n  // A single element of the table is made user-focusable.\n  // It defaults to the first interactive element of the first cell or the first cell itself otherwise.\n  var focusTarget = (_a = firstTableCell && getFocusables(firstTableCell)[0]) !== null && _a !== void 0 ? _a : firstTableCell;\n  // When a navigation-focused element is present in the table it is used for user-navigation instead.\n  if (cell && table.contains(cell.element)) {\n    focusTarget = cell.element;\n  }\n  setTabIndex(focusTarget, 0);\n}\n/**\n * Makes all element focusable children pseudo-focusable unless the grid navigation is suppressed.\n */\nexport function muteElementFocusables(element, suppressed) {\n  // When grid navigation is suppressed all interactive elements and all cells focus is unmuted to unblock Tab navigation.\n  // Leaving the interactive widget using Tab navigation moves the focus to the current or adjacent cell and un-suppresses\n  // the navigation when implemented correctly.\n  if (suppressed) {\n    var _iterator = _createForOfIteratorHelper(getFocusables(element)),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var focusable = _step.value;\n        setTabIndex(focusable, 0);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    return;\n  }\n  // Assigning pseudo-focusable tab index to all cells and all interactive elements makes them focusable with grid navigation.\n  var _iterator2 = _createForOfIteratorHelper(getActualFocusables(element)),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var _focusable = _step2.value;\n      if (_focusable !== document.activeElement) {\n        setTabIndex(_focusable, PSEUDO_FOCUSABLE_TAB_INDEX);\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n}\n/**\n * This cleanup code ensures all cells are no longer focusable but the interactive elements are.\n * Currently there are no use cases for it as we don't expect the navigation to be used conditionally.\n */\nexport function restoreElementFocusables(element) {\n  var _iterator3 = _createForOfIteratorHelper(getFocusables(element)),\n    _step3;\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var focusable = _step3.value;\n      if (focusable instanceof HTMLTableCellElement) {\n        setTabIndex(focusable, -1);\n      } else {\n        setTabIndex(focusable, 0);\n      }\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n}\n/**\n * Returns true if the target element or one of its parents is a dialog or is marked with data-awsui-table-suppress-navigation attribute.\n * This is used to suppress navigation for interactive content without a need to use a custom suppression check.\n */\nexport function defaultIsSuppressed(target) {\n  var current = target;\n  while (current) {\n    // Stop checking for parents upon reaching the cell element as the function only aims at the cell content.\n    var tagName = current.tagName.toLowerCase();\n    if (tagName === 'td' || tagName === 'th') {\n      return false;\n    }\n    if (current.getAttribute('role') === 'dialog' || current.getAttribute('data-awsui-table-suppress-navigation') === 'true') {\n      return true;\n    }\n    current = current.parentElement;\n  }\n  return false;\n}\n/**\n * Returns actually focusable or pseudo-focusable elements to find navigation targets.\n */\nexport function getFocusables(element) {\n  return Array.from(element.querySelectorAll(FOCUSABLES_SELECTOR));\n}\nexport function getFirstFocusable(element) {\n  return element.querySelector(FOCUSABLES_SELECTOR);\n}\n/**\n * Finds the closest row to the targetAriaRowIndex+delta in the direction of delta.\n */\nfunction findTableRowByAriaRowIndex(table, targetAriaRowIndex, delta) {\n  var _a;\n  var targetRow = null;\n  var rowElements = Array.from(table.querySelectorAll('tr[aria-rowindex]'));\n  if (delta < 0) {\n    rowElements.reverse();\n  }\n  for (var _i = 0, _rowElements = rowElements; _i < _rowElements.length; _i++) {\n    var element = _rowElements[_i];\n    var rowIndex = parseInt((_a = element.getAttribute('aria-rowindex')) !== null && _a !== void 0 ? _a : '');\n    targetRow = element;\n    if (rowIndex === targetAriaRowIndex) {\n      break;\n    }\n    if (delta >= 0 && rowIndex > targetAriaRowIndex) {\n      break;\n    }\n    if (delta < 0 && rowIndex < targetAriaRowIndex) {\n      break;\n    }\n  }\n  return targetRow;\n}\n/**\n * Finds the closest column to the targetAriaColIndex+delta in the direction of delta.\n */\nfunction findTableRowCellByAriaColIndex(tableRow, targetAriaColIndex, delta) {\n  var _a;\n  var targetCell = null;\n  var cellElements = Array.from(tableRow.querySelectorAll('td[aria-colindex],th[aria-colindex]'));\n  if (delta < 0) {\n    cellElements.reverse();\n  }\n  for (var _i2 = 0, _cellElements = cellElements; _i2 < _cellElements.length; _i2++) {\n    var element = _cellElements[_i2];\n    var columnIndex = parseInt((_a = element.getAttribute('aria-colindex')) !== null && _a !== void 0 ? _a : '');\n    targetCell = element;\n    if (columnIndex === targetAriaColIndex) {\n      break;\n    }\n    if (delta >= 0 && columnIndex > targetAriaColIndex) {\n      break;\n    }\n    if (delta < 0 && columnIndex < targetAriaColIndex) {\n      break;\n    }\n  }\n  return targetCell;\n}\nfunction focus(element) {\n  setTabIndex(element, 0);\n  element === null || element === void 0 ? void 0 : element.focus();\n}\nfunction setTabIndex(element, tabIndex) {\n  if (element && element.tabIndex !== tabIndex) {\n    element.tabIndex = tabIndex;\n  }\n}","map":{"version":3,"mappings":"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","names":["getFocusables","getActualFocusables","PSEUDO_FOCUSABLE_TAB_INDEX","FOCUSABLES_SELECTOR","findFocusinCell","event","target","HTMLElement","element","cellElement","closest","rowElement","colIndex","parseInt","getAttribute","rowIndex","isNaN","cellFocusables","elementIndex","indexOf","moveFocusBy","table","from","delta","targetAriaRowIndex","y","targetRow","findTableRowByAriaRowIndex","nextElementIndex","x","length","focus","targetAriaColIndex","targetCell","findTableRowCellByAriaColIndex","targetCellFocusables","focusIndex","focusTarget","ensureSingleFocusable","cell","firstTableCell","querySelector","contains","setTabIndex","muteElementFocusables","suppressed","focusable","document","activeElement","restoreElementFocusables","HTMLTableCellElement","defaultIsSuppressed","current","tagName","toLowerCase","parentElement","Array","querySelectorAll","getFirstFocusable","rowElements","reverse","tableRow","cellElements","columnIndex","tabIndex"],"sources":["/Users/tangyizhi/Desktop/Assignment2/frontend/node_modules/@cloudscape-design/components/table/table-role/lib/default/table/table-role/utils.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { getFocusables as getActualFocusables } from '../../internal/components/focus-lock/utils';\nimport { FocusedCell } from './interfaces';\n\n// For the grid to have a single Tab stop all interactive element indices are updated to be -999.\n// The elements having tab index -999 are eligible for keyboard navigation but not for Tab navigation.\nconst PSEUDO_FOCUSABLE_TAB_INDEX = -999;\nconst FOCUSABLES_SELECTOR = `[tabIndex=\"0\"],[tabIndex=\"${PSEUDO_FOCUSABLE_TAB_INDEX}\"]`;\n\n/**\n * Finds focused cell props corresponding the focused element inside the table.\n * The function relies on ARIA colindex/rowindex attributes being correctly applied.\n */\nexport function findFocusinCell(event: FocusEvent): null | FocusedCell {\n  if (!(event.target instanceof HTMLElement)) {\n    return null;\n  }\n  const element = event.target;\n\n  const cellElement = element.closest('td,th') as null | HTMLTableCellElement;\n  const rowElement = cellElement?.closest('tr');\n\n  if (!cellElement || !rowElement) {\n    return null;\n  }\n\n  const colIndex = parseInt(cellElement.getAttribute('aria-colindex') ?? '');\n  const rowIndex = parseInt(rowElement.getAttribute('aria-rowindex') ?? '');\n  if (isNaN(colIndex) || isNaN(rowIndex)) {\n    return null;\n  }\n\n  const cellFocusables = getFocusables(cellElement);\n  const elementIndex = cellFocusables.indexOf(element);\n\n  return { rowIndex, colIndex, rowElement, cellElement, element, elementIndex };\n}\n\n/**\n * Moves table focus in the provided direction. The focus can transition between cells or interactive elements inside cells.\n */\nexport function moveFocusBy(table: HTMLTableElement, from: FocusedCell, delta: { y: number; x: number }) {\n  // Find next row to move focus into (can be null if the top/bottom is reached).\n  const targetAriaRowIndex = from.rowIndex + delta.y;\n  const targetRow = findTableRowByAriaRowIndex(table, targetAriaRowIndex, delta.y);\n  if (!targetRow) {\n    return;\n  }\n\n  // Move focus to the next interactive cell content element if available.\n  const cellFocusables = getFocusables(from.cellElement);\n  const nextElementIndex = from.elementIndex + delta.x;\n  if (delta.x && from.elementIndex !== -1 && 0 <= nextElementIndex && nextElementIndex < cellFocusables.length) {\n    focus(cellFocusables[nextElementIndex]);\n    return;\n  }\n\n  // Find next cell to focus or move focus into (can be null if the left/right edge is reached).\n  const targetAriaColIndex = from.colIndex + delta.x;\n  const targetCell = findTableRowCellByAriaColIndex(targetRow, targetAriaColIndex, delta.x);\n  if (!targetCell) {\n    return;\n  }\n\n  // Move focus on the cell interactive content or the cell itself.\n  const targetCellFocusables = getFocusables(targetCell);\n  const focusIndex = delta.x < 0 ? targetCellFocusables.length - 1 : delta.x > 0 ? 0 : from.elementIndex;\n  const focusTarget = targetCellFocusables[focusIndex] ?? targetCell;\n  focus(focusTarget);\n}\n\n/**\n * Makes the cell element, the first interactive element or the first cell of the table user-focusable.\n */\nexport function ensureSingleFocusable(table: HTMLElement, cell: null | FocusedCell) {\n  const firstTableCell = table.querySelector('td,th') as null | HTMLTableCellElement;\n\n  // A single element of the table is made user-focusable.\n  // It defaults to the first interactive element of the first cell or the first cell itself otherwise.\n  let focusTarget: null | HTMLElement = (firstTableCell && getFocusables(firstTableCell)[0]) ?? firstTableCell;\n\n  // When a navigation-focused element is present in the table it is used for user-navigation instead.\n  if (cell && table.contains(cell.element)) {\n    focusTarget = cell.element;\n  }\n\n  setTabIndex(focusTarget, 0);\n}\n\n/**\n * Makes all element focusable children pseudo-focusable unless the grid navigation is suppressed.\n */\nexport function muteElementFocusables(element: HTMLElement, suppressed: boolean) {\n  // When grid navigation is suppressed all interactive elements and all cells focus is unmuted to unblock Tab navigation.\n  // Leaving the interactive widget using Tab navigation moves the focus to the current or adjacent cell and un-suppresses\n  // the navigation when implemented correctly.\n  if (suppressed) {\n    for (const focusable of getFocusables(element)) {\n      setTabIndex(focusable, 0);\n    }\n    return;\n  }\n\n  // Assigning pseudo-focusable tab index to all cells and all interactive elements makes them focusable with grid navigation.\n  for (const focusable of getActualFocusables(element)) {\n    if (focusable !== document.activeElement) {\n      setTabIndex(focusable, PSEUDO_FOCUSABLE_TAB_INDEX);\n    }\n  }\n}\n\n/**\n * This cleanup code ensures all cells are no longer focusable but the interactive elements are.\n * Currently there are no use cases for it as we don't expect the navigation to be used conditionally.\n */\nexport function restoreElementFocusables(element: HTMLTableElement) {\n  for (const focusable of getFocusables(element)) {\n    if (focusable instanceof HTMLTableCellElement) {\n      setTabIndex(focusable, -1);\n    } else {\n      setTabIndex(focusable, 0);\n    }\n  }\n}\n\n/**\n * Returns true if the target element or one of its parents is a dialog or is marked with data-awsui-table-suppress-navigation attribute.\n * This is used to suppress navigation for interactive content without a need to use a custom suppression check.\n */\nexport function defaultIsSuppressed(target: HTMLElement) {\n  let current: null | HTMLElement = target;\n  while (current) {\n    // Stop checking for parents upon reaching the cell element as the function only aims at the cell content.\n    const tagName = current.tagName.toLowerCase();\n    if (tagName === 'td' || tagName === 'th') {\n      return false;\n    }\n    if (\n      current.getAttribute('role') === 'dialog' ||\n      current.getAttribute('data-awsui-table-suppress-navigation') === 'true'\n    ) {\n      return true;\n    }\n    current = current.parentElement;\n  }\n  return false;\n}\n\n/**\n * Returns actually focusable or pseudo-focusable elements to find navigation targets.\n */\nexport function getFocusables(element: HTMLElement) {\n  return Array.from(element.querySelectorAll(FOCUSABLES_SELECTOR)) as HTMLElement[];\n}\n\nexport function getFirstFocusable(element: HTMLElement) {\n  return element.querySelector(FOCUSABLES_SELECTOR) as null | HTMLElement;\n}\n\n/**\n * Finds the closest row to the targetAriaRowIndex+delta in the direction of delta.\n */\nfunction findTableRowByAriaRowIndex(table: HTMLTableElement, targetAriaRowIndex: number, delta: number) {\n  let targetRow: null | HTMLTableRowElement = null;\n  const rowElements = Array.from(table.querySelectorAll('tr[aria-rowindex]'));\n  if (delta < 0) {\n    rowElements.reverse();\n  }\n  for (const element of rowElements) {\n    const rowIndex = parseInt(element.getAttribute('aria-rowindex') ?? '');\n    targetRow = element as HTMLTableRowElement;\n\n    if (rowIndex === targetAriaRowIndex) {\n      break;\n    }\n    if (delta >= 0 && rowIndex > targetAriaRowIndex) {\n      break;\n    }\n    if (delta < 0 && rowIndex < targetAriaRowIndex) {\n      break;\n    }\n  }\n  return targetRow;\n}\n\n/**\n * Finds the closest column to the targetAriaColIndex+delta in the direction of delta.\n */\nfunction findTableRowCellByAriaColIndex(tableRow: HTMLTableRowElement, targetAriaColIndex: number, delta: number) {\n  let targetCell: null | HTMLTableCellElement = null;\n  const cellElements = Array.from(tableRow.querySelectorAll('td[aria-colindex],th[aria-colindex]'));\n  if (delta < 0) {\n    cellElements.reverse();\n  }\n  for (const element of cellElements) {\n    const columnIndex = parseInt(element.getAttribute('aria-colindex') ?? '');\n    targetCell = element as HTMLTableCellElement;\n\n    if (columnIndex === targetAriaColIndex) {\n      break;\n    }\n    if (delta >= 0 && columnIndex > targetAriaColIndex) {\n      break;\n    }\n    if (delta < 0 && columnIndex < targetAriaColIndex) {\n      break;\n    }\n  }\n  return targetCell;\n}\n\nfunction focus(element: null | HTMLElement) {\n  setTabIndex(element, 0);\n  element?.focus();\n}\n\nfunction setTabIndex(element: null | HTMLElement, tabIndex: number) {\n  if (element && element.tabIndex !== tabIndex) {\n    element.tabIndex = tabIndex;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}