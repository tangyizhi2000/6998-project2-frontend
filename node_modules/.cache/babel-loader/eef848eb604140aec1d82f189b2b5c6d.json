{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nexport function getDOMRects(elements) {\n  const rects = {};\n  for (const id in elements) {\n    const element = elements[id];\n    if (element) {\n      rects[id] = element.getBoundingClientRect();\n    }\n  }\n  return rects;\n}\n/*\n  Animate DOM elements based on the FLIP technique\n  - https://aerotwist.com/blog/flip-your-animations/\n  - https://css-tricks.com/animating-layouts-with-the-flip-technique/\n\n  This can be useful when the initial dimensions or position of the element is not known,\n  so the initial offset or scaling needs to be retrieved via JS.\n\n  Caveat: this currently does not support elements having CSS transforms in the end state.\n  These would be overridden in the animation instead of combined.\n */\nexport function animate(_ref) {\n  let {\n    oldState,\n    elements,\n    onTransitionsEnd,\n    newElementInitialState\n  } = _ref;\n  // First, apply the transform that will make the elements \"look like\" in the start position\n  for (const id in elements) {\n    const element = elements[id];\n    const oldRect = oldState[id];\n    if (element) {\n      const newRect = element.getBoundingClientRect();\n      const noOpTransform = {\n        scale: 1,\n        x: 0,\n        y: 0\n      };\n      // Calculate initial position.\n      // If the element didn't exist previously, use the newElementInitialState function if provided.\n      // If not, default to no transitions (scale: 1, y: 0)\n      const calculatedInverseTransform = oldRect ? {\n        scale: oldRect.width / newRect.width,\n        x: (oldRect.left + oldRect.right) / 2 - (newRect.left + newRect.right) / 2,\n        y: (oldRect.top + oldRect.bottom) / 2 - (newRect.top + newRect.bottom) / 2\n      } : newElementInitialState ? newElementInitialState(newRect) : {};\n      const inverseTransform = Object.assign(Object.assign({}, noOpTransform), calculatedInverseTransform);\n      // Apply this initial change, without animating\n      element.style.transitionProperty = 'none';\n      element.style.transform = `scale(${inverseTransform.scale}) translate(${inverseTransform.x}px, ${inverseTransform.y}px)`;\n      if (!oldRect) {\n        // If the element didn't exist, then fade it in\n        // (besides any other possibly defined transitions based on `newElementInitialState`)\n        element.style.opacity = '0';\n      }\n    }\n  }\n  // Animate from the initial state to the end state\n  requestAnimationFrame(() => {\n    const ongoingAnimations = new Set();\n    for (const id in elements) {\n      const element = elements[id];\n      if (element) {\n        const oldRect = oldState[id];\n        if (oldRect) {\n          // Animate from here on\n          element.style.transitionProperty = `transform`;\n          // Unset inline CSS transforms so that the final state is applied\n          element.style.transform = '';\n        } else {\n          // If the element didn't exist previously, fade in as well\n          element.style.transitionProperty = `transform, opacity`;\n          element.style.transform = '';\n          element.style.opacity = '';\n        }\n        const onTransitionStart = event => {\n          if (event.target === element) {\n            ongoingAnimations.add(id);\n            element.removeEventListener('transitionstart', onTransitionStart);\n          }\n        };\n        const onTransitionEnd = event => {\n          if (event.target === element) {\n            // Clean up remaining inline styles\n            element.style.transitionProperty = '';\n            element.removeEventListener('transitionstart', onTransitionEnd);\n            if (onTransitionsEnd) {\n              ongoingAnimations.delete(id);\n              if (ongoingAnimations.size === 0) {\n                onTransitionsEnd();\n              }\n            }\n          }\n        };\n        element.addEventListener('transitionstart', onTransitionStart);\n        element.addEventListener('transitionend', onTransitionEnd);\n      }\n    }\n  });\n}","map":{"version":3,"mappings":"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","names":["getDOMRects","elements","rects","id","element","getBoundingClientRect","animate","oldState","onTransitionsEnd","newElementInitialState","oldRect","newRect","noOpTransform","scale","x","y","calculatedInverseTransform","width","left","right","top","bottom","inverseTransform","style","transitionProperty","transform","opacity","requestAnimationFrame","ongoingAnimations","Set","onTransitionStart","event","target","add","removeEventListener","onTransitionEnd","delete","size","addEventListener"],"sources":["/Users/tangyizhi/Desktop/Assignment 2/frontend/node_modules/@cloudscape-design/components/internal/lib/default/internal/animate.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nexport function getDOMRects(elements: Record<string | number, HTMLElement | null>) {\n  const rects: Record<string, DOMRect> = {};\n  for (const id in elements) {\n    const element = elements[id];\n    if (element) {\n      rects[id] = element.getBoundingClientRect();\n    }\n  }\n  return rects;\n}\n\n/*\n  Animate DOM elements based on the FLIP technique\n  - https://aerotwist.com/blog/flip-your-animations/\n  - https://css-tricks.com/animating-layouts-with-the-flip-technique/\n\n  This can be useful when the initial dimensions or position of the element is not known,\n  so the initial offset or scaling needs to be retrieved via JS.\n\n  Caveat: this currently does not support elements having CSS transforms in the end state.\n  These would be overridden in the animation instead of combined.\n */\nexport function animate({\n  oldState,\n  elements,\n  onTransitionsEnd,\n  newElementInitialState,\n}: {\n  elements: Record<string | number, HTMLElement | null>;\n  oldState: Record<string | number, DOMRect>;\n  onTransitionsEnd?: () => void;\n  newElementInitialState?: (newRect: DOMRect) => { scale?: number; y?: number };\n}) {\n  // First, apply the transform that will make the elements \"look like\" in the start position\n  for (const id in elements) {\n    const element = elements[id];\n    const oldRect = oldState[id];\n    if (element) {\n      const newRect = element.getBoundingClientRect();\n      const noOpTransform = { scale: 1, x: 0, y: 0 };\n      // Calculate initial position.\n      // If the element didn't exist previously, use the newElementInitialState function if provided.\n      // If not, default to no transitions (scale: 1, y: 0)\n      const calculatedInverseTransform = oldRect\n        ? {\n            scale: oldRect.width / newRect.width,\n            x: (oldRect.left + oldRect.right) / 2 - (newRect.left + newRect.right) / 2,\n            y: (oldRect.top + oldRect.bottom) / 2 - (newRect.top + newRect.bottom) / 2,\n          }\n        : newElementInitialState\n        ? newElementInitialState(newRect)\n        : {};\n      const inverseTransform = { ...noOpTransform, ...calculatedInverseTransform };\n      // Apply this initial change, without animating\n      element.style.transitionProperty = 'none';\n      element.style.transform = `scale(${inverseTransform.scale}) translate(${inverseTransform.x}px, ${inverseTransform.y}px)`;\n      if (!oldRect) {\n        // If the element didn't exist, then fade it in\n        // (besides any other possibly defined transitions based on `newElementInitialState`)\n        element.style.opacity = '0';\n      }\n    }\n  }\n\n  // Animate from the initial state to the end state\n  requestAnimationFrame(() => {\n    const ongoingAnimations = new Set();\n    for (const id in elements) {\n      const element = elements[id];\n      if (element) {\n        const oldRect = oldState[id];\n        if (oldRect) {\n          // Animate from here on\n          element.style.transitionProperty = `transform`;\n          // Unset inline CSS transforms so that the final state is applied\n          element.style.transform = '';\n        } else {\n          // If the element didn't exist previously, fade in as well\n          element.style.transitionProperty = `transform, opacity`;\n          element.style.transform = '';\n          element.style.opacity = '';\n        }\n        const onTransitionStart = (event: TransitionEvent) => {\n          if (event.target === element) {\n            ongoingAnimations.add(id);\n            element.removeEventListener('transitionstart', onTransitionStart);\n          }\n        };\n        const onTransitionEnd = (event: TransitionEvent) => {\n          if (event.target === element) {\n            // Clean up remaining inline styles\n            element.style.transitionProperty = '';\n            element.removeEventListener('transitionstart', onTransitionEnd);\n            if (onTransitionsEnd) {\n              ongoingAnimations.delete(id);\n              if (ongoingAnimations.size === 0) {\n                onTransitionsEnd();\n              }\n            }\n          }\n        };\n        element.addEventListener('transitionstart', onTransitionStart);\n        element.addEventListener('transitionend', onTransitionEnd);\n      }\n    }\n  });\n}\n"]},"metadata":{},"sourceType":"module"}