{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { useCallback, useEffect, useState } from 'react';\nconst isBrowser = typeof window !== 'undefined';\n/**\n * Hook to implement scroll-spy functionality.\n *\n * @param hrefs An array of href strings that correspond to the IDs of the target elements on the page.\n * The hrefs should be sorted in the order they appear on the page for accurate scroll-spy behavior.\n * @param scrollSpyOffset The number of pixels to offset from the top of the document when activating anchors.\n * Useful for accommodating fixed or sticky headers.\n * @param activeHref The currently active href. If provided, the hook will operate in a controlled manner,\n * and the scroll-spy logic will be disabled.\n *\n * @returns {string | undefined} - The href of the currently active element as per scroll position, or undefined if none is active.\n */\nexport default function useScrollSpy(_ref) {\n  let {\n    hrefs,\n    scrollSpyOffset,\n    activeHref\n  } = _ref;\n  const [currentHref, setCurrentHref] = useState(activeHref);\n  const [lastAnchorExists, setLastAnchorExists] = useState(false);\n  useEffect(() => {\n    setCurrentHref(activeHref);\n  }, [activeHref]);\n  useEffect(() => {\n    var _a;\n    setLastAnchorExists(isBrowser && !!document.getElementById((_a = hrefs[hrefs.length - 1]) === null || _a === void 0 ? void 0 : _a.slice(1)));\n  }, [hrefs]);\n  // Get the bounding rectangle of an element by href\n  const getRectByHref = useCallback(href => {\n    var _a;\n    return (_a = document.getElementById(href.slice(1))) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect();\n  }, []);\n  // Check if we're scrolled to the bottom of the page\n  const isPageBottom = useCallback(() => {\n    return lastAnchorExists && Math.ceil(window.scrollY) >= Math.floor(document.body.scrollHeight - window.innerHeight);\n  }, [lastAnchorExists]);\n  // Find the first href for which the element is within the viewport\n  const findHrefInView = useCallback(() => {\n    return hrefs.find(href => {\n      const rect = getRectByHref(href);\n      return rect && rect.bottom <= window.innerHeight && rect.top >= scrollSpyOffset;\n    });\n  }, [getRectByHref, scrollSpyOffset, hrefs]);\n  // Find the last href where its element is above or within the viewport\n  const findLastHrefInView = useCallback(() => {\n    return [...hrefs].reverse().find(href => {\n      const rect = getRectByHref(href);\n      return rect && rect.bottom <= window.innerHeight;\n    });\n  }, [getRectByHref, hrefs]);\n  // Scroll event handler\n  const handleScroll = useCallback(() => {\n    if (activeHref || !isBrowser) {\n      return;\n    }\n    const {\n      scrollY\n    } = window;\n    if (document.body.scrollHeight > window.innerHeight && isPageBottom()) {\n      setCurrentHref(hrefs[hrefs.length - 1]);\n    } else {\n      setCurrentHref(findHrefInView() || (scrollY > 0 ? findLastHrefInView() : undefined));\n    }\n  }, [activeHref, isPageBottom, findHrefInView, findLastHrefInView, hrefs]);\n  useEffect(() => {\n    if (isBrowser) {\n      handleScroll();\n      window.addEventListener('scroll', handleScroll, {\n        passive: true\n      });\n      return () => {\n        window.removeEventListener('scroll', handleScroll);\n      };\n    }\n  }, [handleScroll]);\n  return currentHref;\n}","map":{"version":3,"mappings":"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","names":["useCallback","useEffect","useState","isBrowser","window","useScrollSpy","hrefs","scrollSpyOffset","activeHref","currentHref","setCurrentHref","lastAnchorExists","setLastAnchorExists","document","getElementById","length","slice","getRectByHref","href","getBoundingClientRect","isPageBottom","Math","ceil","scrollY","floor","body","scrollHeight","innerHeight","findHrefInView","find","rect","bottom","top","findLastHrefInView","reverse","handleScroll","undefined","addEventListener","passive","removeEventListener"],"sources":["/Users/tangyizhi/Desktop/Assignment 2/frontend/node_modules/@cloudscape-design/components/anchor-navigation/lib/default/anchor-navigation/use-scroll-spy.tsx"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { useCallback, useEffect, useState } from 'react';\n\nconst isBrowser = typeof window !== 'undefined';\n\n/**\n * Hook to implement scroll-spy functionality.\n *\n * @param hrefs An array of href strings that correspond to the IDs of the target elements on the page.\n * The hrefs should be sorted in the order they appear on the page for accurate scroll-spy behavior.\n * @param scrollSpyOffset The number of pixels to offset from the top of the document when activating anchors.\n * Useful for accommodating fixed or sticky headers.\n * @param activeHref The currently active href. If provided, the hook will operate in a controlled manner,\n * and the scroll-spy logic will be disabled.\n *\n * @returns {string | undefined} - The href of the currently active element as per scroll position, or undefined if none is active.\n */\nexport default function useScrollSpy({\n  hrefs,\n  scrollSpyOffset,\n  activeHref,\n}: {\n  hrefs: string[];\n  scrollSpyOffset: number;\n  activeHref?: string;\n}): string | undefined {\n  const [currentHref, setCurrentHref] = useState<string | undefined>(activeHref);\n  const [lastAnchorExists, setLastAnchorExists] = useState(false);\n\n  useEffect(() => {\n    setCurrentHref(activeHref);\n  }, [activeHref]);\n\n  useEffect(() => {\n    setLastAnchorExists(isBrowser && !!document.getElementById(hrefs[hrefs.length - 1]?.slice(1)));\n  }, [hrefs]);\n\n  // Get the bounding rectangle of an element by href\n  const getRectByHref = useCallback(href => {\n    return document.getElementById(href.slice(1))?.getBoundingClientRect();\n  }, []);\n\n  // Check if we're scrolled to the bottom of the page\n  const isPageBottom = useCallback(() => {\n    return lastAnchorExists && Math.ceil(window.scrollY) >= Math.floor(document.body.scrollHeight - window.innerHeight);\n  }, [lastAnchorExists]);\n\n  // Find the first href for which the element is within the viewport\n  const findHrefInView = useCallback(() => {\n    return hrefs.find(href => {\n      const rect = getRectByHref(href);\n      return rect && rect.bottom <= window.innerHeight && rect.top >= scrollSpyOffset;\n    });\n  }, [getRectByHref, scrollSpyOffset, hrefs]);\n\n  // Find the last href where its element is above or within the viewport\n  const findLastHrefInView = useCallback(() => {\n    return [...hrefs].reverse().find(href => {\n      const rect = getRectByHref(href);\n      return rect && rect.bottom <= window.innerHeight;\n    });\n  }, [getRectByHref, hrefs]);\n\n  // Scroll event handler\n  const handleScroll = useCallback(() => {\n    if (activeHref || !isBrowser) {\n      return;\n    }\n\n    const { scrollY } = window;\n\n    if (document.body.scrollHeight > window.innerHeight && isPageBottom()) {\n      setCurrentHref(hrefs[hrefs.length - 1]);\n    } else {\n      setCurrentHref(findHrefInView() || (scrollY > 0 ? findLastHrefInView() : undefined));\n    }\n  }, [activeHref, isPageBottom, findHrefInView, findLastHrefInView, hrefs]);\n\n  useEffect(() => {\n    if (isBrowser) {\n      handleScroll();\n      window.addEventListener('scroll', handleScroll, { passive: true });\n      return () => {\n        window.removeEventListener('scroll', handleScroll);\n      };\n    }\n  }, [handleScroll]);\n\n  return currentHref;\n}\n"]},"metadata":{},"sourceType":"module"}