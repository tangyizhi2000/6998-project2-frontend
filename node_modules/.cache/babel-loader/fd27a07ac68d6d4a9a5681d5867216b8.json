{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport React, { useEffect, useRef, useState } from 'react';\nimport styles from './styles.css.js';\nimport { isModifierKey } from '../../hooks/focus-visible';\nfunction useFocusVisibleState() {\n  const [focusVisible, setFocusVisible] = useState(false);\n  useEffect(() => {\n    function handleMousedown() {\n      return setFocusVisible(false);\n    }\n    function handleKeydown(event) {\n      // we do not want to highlight focused element\n      // when special keys are pressed\n      if (!isModifierKey(event)) {\n        setFocusVisible(true);\n      }\n    }\n    document.addEventListener('mousedown', handleMousedown);\n    document.addEventListener('keydown', handleKeydown);\n    return () => {\n      document.removeEventListener('mousedown', handleMousedown);\n      document.removeEventListener('keydown', handleKeydown);\n    };\n  });\n  return focusVisible;\n}\nexport default function FocusOutline(_ref) {\n  let {\n    elementKey,\n    elementRef,\n    offset = 0\n  } = _ref;\n  const ref = useRef(null);\n  const focusVisible = useFocusVisibleState();\n  useEffect(() => {\n    if (!ref.current) {\n      return;\n    }\n    if (focusVisible && elementKey && elementRef && elementRef.current && elementRef.current.getBBox) {\n      const element = elementRef.current.getBBox();\n      showOutline(ref.current, element, offset);\n    } else {\n      hideOutline(ref.current);\n    }\n  }, [focusVisible, elementKey, elementRef, offset]);\n  return React.createElement(\"rect\", {\n    ref: ref,\n    \"aria-hidden\": \"true\",\n    className: styles['focus-outline'],\n    rx: \"2\"\n  });\n}\nfunction showOutline(el, position, offset) {\n  const offsetX = typeof offset === 'number' ? offset : offset.x;\n  const offsetY = typeof offset === 'number' ? offset : offset.y;\n  el.setAttribute('x', (position.x - offsetX).toString());\n  el.setAttribute('y', (position.y - offsetY).toString());\n  el.setAttribute('width', (position.width + 2 * offsetX).toString());\n  el.setAttribute('height', (position.height + 2 * offsetY).toString());\n  el.style.visibility = 'visible';\n}\nfunction hideOutline(el) {\n  el.style.visibility = 'hidden';\n  el.removeAttribute('x');\n  el.removeAttribute('y');\n  el.removeAttribute('width');\n  el.removeAttribute('height');\n}","map":{"version":3,"mappings":"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","names":["React","useEffect","useRef","useState","styles","isModifierKey","useFocusVisibleState","focusVisible","setFocusVisible","handleMousedown","handleKeydown","event","document","addEventListener","removeEventListener","FocusOutline","elementKey","elementRef","offset","ref","current","getBBox","element","showOutline","hideOutline","className","rx","el","position","offsetX","x","offsetY","y","setAttribute","toString","width","height","style","visibility","removeAttribute"],"sources":["/Users/tangyizhi/Desktop/Assignment2/frontend/node_modules/@cloudscape-design/components/internal/components/chart-plot/lib/default/internal/components/chart-plot/focus-outline.tsx"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport React, { useEffect, useRef, useState } from 'react';\n\nimport styles from './styles.css.js';\nimport { Offset } from '../interfaces';\nimport { isModifierKey } from '../../hooks/focus-visible';\n\nexport interface FocusOutlineProps {\n  elementKey?: null | string | number | boolean;\n  elementRef?: React.RefObject<SVGSVGElement | SVGGElement>;\n  offset?: Offset;\n}\n\nfunction useFocusVisibleState() {\n  const [focusVisible, setFocusVisible] = useState(false);\n  useEffect(() => {\n    function handleMousedown() {\n      return setFocusVisible(false);\n    }\n\n    function handleKeydown(event: KeyboardEvent) {\n      // we do not want to highlight focused element\n      // when special keys are pressed\n      if (!isModifierKey(event)) {\n        setFocusVisible(true);\n      }\n    }\n\n    document.addEventListener('mousedown', handleMousedown);\n    document.addEventListener('keydown', handleKeydown);\n    return () => {\n      document.removeEventListener('mousedown', handleMousedown);\n      document.removeEventListener('keydown', handleKeydown);\n    };\n  });\n\n  return focusVisible;\n}\n\nexport default function FocusOutline({ elementKey, elementRef, offset = 0 }: FocusOutlineProps) {\n  const ref = useRef<SVGRectElement>(null);\n  const focusVisible = useFocusVisibleState();\n\n  useEffect(() => {\n    if (!ref.current) {\n      return;\n    }\n\n    if (focusVisible && elementKey && elementRef && elementRef.current && elementRef.current.getBBox) {\n      const element = elementRef.current.getBBox();\n      showOutline(ref.current, element, offset);\n    } else {\n      hideOutline(ref.current);\n    }\n  }, [focusVisible, elementKey, elementRef, offset]);\n\n  return <rect ref={ref} aria-hidden=\"true\" className={styles['focus-outline']} rx=\"2\" />;\n}\n\nfunction showOutline(\n  el: SVGRectElement,\n  position: { x: number; y: number; width: number; height: number },\n  offset: Offset\n) {\n  const offsetX = typeof offset === 'number' ? offset : offset.x;\n  const offsetY = typeof offset === 'number' ? offset : offset.y;\n  el.setAttribute('x', (position.x - offsetX).toString());\n  el.setAttribute('y', (position.y - offsetY).toString());\n  el.setAttribute('width', (position.width + 2 * offsetX).toString());\n  el.setAttribute('height', (position.height + 2 * offsetY).toString());\n  el.style.visibility = 'visible';\n}\n\nfunction hideOutline(el: SVGRectElement) {\n  el.style.visibility = 'hidden';\n  el.removeAttribute('x');\n  el.removeAttribute('y');\n  el.removeAttribute('width');\n  el.removeAttribute('height');\n}\n"]},"metadata":{},"sourceType":"module"}