{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/tangyizhi/Desktop/Assignment2/frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _toArray from \"/Users/tangyizhi/Desktop/Assignment2/frontend/node_modules/@babel/runtime/helpers/esm/toArray.js\";\nimport _toConsumableArray from \"/Users/tangyizhi/Desktop/Assignment2/frontend/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _classCallCheck from \"/Users/tangyizhi/Desktop/Assignment2/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/tangyizhi/Desktop/Assignment2/frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { padLeftZeros } from '../../../utils/strings';\nimport { insertAt } from './strings';\nvar MaskFormat = /*#__PURE__*/function () {\n  function MaskFormat(_ref) {\n    var separator = _ref.separator,\n      _ref$inputSeparators = _ref.inputSeparators,\n      inputSeparators = _ref$inputSeparators === void 0 ? [] : _ref$inputSeparators,\n      segments = _ref.segments;\n    _classCallCheck(this, MaskFormat);\n    this.positionFormats = {};\n    this.segments = [];\n    this.separator = separator;\n    this.inputSeparators = [].concat(_toConsumableArray(inputSeparators), [separator]);\n    this.enrichSegmentDefinitions(segments);\n  }\n  _createClass(MaskFormat, [{\n    key: \"tryAppendSeparator\",\n    value: function tryAppendSeparator(value) {\n      var withSeparator = \"\".concat(value).concat(this.separator);\n      return this.isValid(withSeparator) ? withSeparator : value;\n    }\n  }, {\n    key: \"isSeparator\",\n    value: function isSeparator(key) {\n      return this.inputSeparators.indexOf(key) !== -1;\n    }\n  }, {\n    key: \"isValid\",\n    value: function isValid(value) {\n      var _this = this;\n      var inputSegments = value.split(this.separator);\n      if (inputSegments.length > this.segments.length) {\n        return false;\n      }\n      return inputSegments.every(function (segmentValue, i) {\n        var segment = _this.segments[i];\n        // disallow empty segments\n        if (segmentValue === '') {\n          // except empty last segment (e.g. trailing separator \"12:\")\n          if (i === inputSegments.length - 1) {\n            return true;\n          } else {\n            return false;\n          }\n        }\n        // only allow numerals\n        if (!segmentValue.match(/^\\d+$/)) {\n          return false;\n        }\n        // disallow incomplete segments, except at end\n        if (segmentValue.length < segment.length && i !== inputSegments.length - 1) {\n          return false;\n        }\n        // limit numerical value\n        var intValue = parseInt(segmentValue, 10);\n        // Handles values padded with 0s that are lost during parsing\n        if (segmentValue.length > segment.length) {\n          return false;\n        }\n        if (intValue < segment.min || intValue > segment.max(value)) {\n          // allow incomplete segments in final position\n          if (i === inputSegments.length - 1 && segmentValue.length < segment.length) {\n            return true;\n          }\n          return false;\n        }\n        return true;\n      });\n    }\n  }, {\n    key: \"getValidValue\",\n    value: function getValidValue(value) {\n      var validValue = value;\n      do {\n        if (this.isValid(validValue)) {\n          return this.tryAppendSeparator(validValue);\n        }\n        validValue = validValue.substring(0, validValue.length - 1);\n      } while (validValue.length > 0);\n      return '';\n    }\n  }, {\n    key: \"autoComplete\",\n    value: function autoComplete(value) {\n      // aka [...completeSegments, lastSegment] = value.split(':')\n      // but that's not valid :/\n      var _value$split$reverse = value.split(this.separator).reverse(),\n        _value$split$reverse2 = _toArray(_value$split$reverse),\n        lastSegmentValue = _value$split$reverse2[0],\n        completeSegmentValues = _value$split$reverse2.slice(1);\n      var lastSegment = this.segments[completeSegmentValues.length];\n      // if the last segment isn't complete, pad it with a preceding 0\n      // e.g. 10:1 -> 10:01\n      var paddedLastSegmentValue = this.padWithDefaultValue(lastSegmentValue, lastSegment);\n      // recombine, and pad with extra segments for the full format\n      var partial = [].concat(_toConsumableArray(completeSegmentValues.reverse()), [paddedLastSegmentValue]);\n      while (partial.length < this.segments.length) {\n        var nextSegment = this.segments[partial.length];\n        var segmentValue = this.padWithDefaultValue('', nextSegment);\n        partial.push(segmentValue);\n      }\n      value = partial.join(this.separator);\n      value = this.correctMinMaxValues(value);\n      return value;\n    }\n  }, {\n    key: \"getSegmentValueWithAddition\",\n    value: function getSegmentValueWithAddition(position, value, enteredDigit) {\n      var segment = this.positionFormats[position];\n      var segmentValue = value.substr(segment.start, segment.length);\n      var segmentPosition = position - segment.start;\n      var newValue = insertAt(segmentValue, enteredDigit, segmentPosition, segmentPosition + 1);\n      return parseInt(newValue, 10);\n    }\n  }, {\n    key: \"replaceDigitsWithZeroes\",\n    value: function replaceDigitsWithZeroes(value, cursorStart, cursorEnd) {\n      var position = this.isCursorAtSeparator(cursorStart) ? cursorStart + 1 : cursorStart;\n      // move selection forwards if it starts with a separator\n      if (this.isCursorAtSeparator(cursorStart)) {\n        cursorStart++;\n      }\n      // first, insert zeros in a partial segment at beginning of selection\n      if (!this.isSegmentStart(cursorStart)) {\n        var segment = this.positionFormats[cursorStart];\n        value = insertAt(value, padLeftZeros('', segment.end - cursorStart), cursorStart, segment.end);\n        cursorStart = segment.end + 1;\n      }\n      // then loop through remaining segments, filling with zeros\n      var currentSegment;\n      while (cursorStart < cursorEnd && (currentSegment = this.positionFormats[cursorStart + 1])) {\n        var insertionEnd = Math.min(cursorEnd, currentSegment.end);\n        value = insertAt(value, padLeftZeros('', insertionEnd - currentSegment.start), currentSegment.start, insertionEnd);\n        cursorStart = insertionEnd + 1;\n      }\n      value = this.correctMinMaxValues(value);\n      return {\n        value: value,\n        position: position\n      };\n    }\n  }, {\n    key: \"handleSeparatorInput\",\n    value: function handleSeparatorInput(value, position) {\n      if (position === value.length && !this.isSegmentStart(position)) {\n        var segment = this.positionFormats[position];\n        var segmentValue = value.substr(segment.start, segment.length);\n        segmentValue = this.padWithDefaultValue(segmentValue, segment);\n        value = insertAt(value, segmentValue, segment.start, segment.end);\n        value = this.correctMinMaxValues(value);\n        return {\n          value: value,\n          position: value.length\n        };\n      }\n    }\n  }, {\n    key: \"isCursorAtSeparator\",\n    value: function isCursorAtSeparator(position) {\n      return 0 < position && position < this.getMaxLength() && this.positionFormats[position] === undefined;\n    }\n  }, {\n    key: \"isSegmentStart\",\n    value: function isSegmentStart(position) {\n      return position === 0 || this.isCursorAtSeparator(position - 1);\n    }\n  }, {\n    key: \"getSegmentMaxValue\",\n    value: function getSegmentMaxValue(value, position) {\n      return this.positionFormats[position].max(value);\n    }\n  }, {\n    key: \"getSegmentMinValue\",\n    value: function getSegmentMinValue(value, position) {\n      return this.positionFormats[position].min;\n    }\n  }, {\n    key: \"getMaxLength\",\n    value: function getMaxLength() {\n      var last = this.segments[this.segments.length - 1];\n      return last.start + last.length;\n    }\n  }, {\n    key: \"deleteSeparator\",\n    value: function deleteSeparator(value, position) {\n      value = insertAt(value, '0', position - 2, position - 1);\n      return {\n        value: this.correctMinMaxValues(value),\n        position: position - 2\n      };\n    }\n  }, {\n    key: \"deleteDigit\",\n    value: function deleteDigit(value, position) {\n      value = insertAt(value, '0', position - 1, position);\n      // 23:59|: => backspace => 23:5|\n      var length = value.length;\n      if (value.slice(length - 2) === '0:') {\n        value = value.slice(0, length - 2);\n      }\n      return {\n        value: this.correctMinMaxValues(value),\n        position: position - 1\n      };\n    }\n  }, {\n    key: \"correctMinMaxValues\",\n    value: function correctMinMaxValues(value) {\n      var segment = this.positionFormats[0];\n      while (segment && value.length >= segment.end) {\n        var segmentValue = parseInt(value.substr(segment.start, segment.length), 10);\n        var segmentMax = segment.max(value);\n        if (segmentValue < segment.min) {\n          var toInsert = segment.min.toFixed();\n          toInsert = padLeftZeros(toInsert, segment.length);\n          value = insertAt(value, toInsert, segment.start, segment.end);\n        }\n        if (segmentValue > segmentMax) {\n          value = insertAt(value, segmentMax.toFixed(), segment.start, segment.end);\n        }\n        segment = this.positionFormats[segment.end + 1];\n      }\n      return value.substr(0, this.segments[this.segments.length - 1].end);\n    }\n  }, {\n    key: \"formatPastedText\",\n    value: function formatPastedText(text, value, cursorStart, cursorEnd) {\n      var keyArr = text.trim().split('');\n      var position = cursorStart;\n      var formattedValue = value;\n      // if a selection range captures the end of the current value\n      // we replace it with the value in buffer even if the value in buffer is shorter\n      if (cursorEnd > cursorStart && cursorEnd === value.length) {\n        formattedValue = value.slice(0, cursorStart);\n      }\n      var _iterator = _createForOfIteratorHelper(keyArr),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var key = _step.value;\n          if (position >= this.getMaxLength()) {\n            break;\n          }\n          var result = this.processKey(formattedValue, key, position);\n          formattedValue = result.value;\n          position = result.position;\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return this.tryAppendSeparator(formattedValue);\n    }\n  }, {\n    key: \"processKey\",\n    value: function processKey(initialValue, key, initialPosition) {\n      var value = initialValue;\n      var position = initialPosition;\n      if (this.isSeparator(key)) {\n        var result = this.handleSeparatorInput(value, position);\n        if (result) {\n          value = result.value;\n          position = result.position;\n        }\n      } else {\n        var isCursorAtEnd = position === value.length;\n        var segmentValue = this.getSegmentValueWithAddition(position, value, key);\n        var segmentMaxValue = this.getSegmentMaxValue(value, position);\n        var segmentMinValue = this.getSegmentMinValue(value, position);\n        var firstDigitGreater = parseInt(key, 10) > parseInt(segmentMaxValue.toFixed()[0], 10);\n        var isValidPosition = isCursorAtEnd || segmentValue.toFixed().length === 1;\n        var exceedsMaxAtSegmentStart = this.isSegmentStart(position) && isValidPosition && firstDigitGreater;\n        if (exceedsMaxAtSegmentStart) {\n          // 22:| => Enter '9' => 22:09|\n          // |1 => Enter '9' => 09|\n          value = insertAt(value, \"0\".concat(key), position, position + 2);\n          position += 2;\n        } else if (segmentValue > segmentMaxValue && this.isSegmentStart(position)) {\n          // 22:|22 => Enter '9' => 22:59|\n          value = insertAt(value, segmentMaxValue.toFixed(), position, position + segmentMaxValue.toFixed().length);\n          position += segmentMaxValue.toFixed().length;\n        } else if (segmentValue > segmentMaxValue) {\n          // 2|2:22 => Enter '9' => 23:|22\n          value = insertAt(value, segmentMaxValue.toFixed(), position - 1, position + 1);\n          position += 1;\n        } else if (segmentValue < segmentMinValue && !this.isSegmentStart(position)) {\n          // 0| => enter '0' => 01:\n          value = insertAt(value, segmentMinValue.toFixed(), position, position + 1);\n          position += 1;\n        } else {\n          // 22:| => Enter '5' => 23:5|\n          value = insertAt(value, key, position, position + 1);\n          position += 1;\n        }\n      }\n      value = this.tryAppendSeparator(value);\n      // Move cursor in front of separator if behind after overwriting a character\n      if (this.isCursorAtSeparator(position)) {\n        position++;\n      }\n      return {\n        value: value,\n        position: position\n      };\n    }\n  }, {\n    key: \"padWithDefaultValue\",\n    value: function padWithDefaultValue(segmentValue, segment) {\n      var defaultValue = (segment.default || segment.min).toFixed();\n      defaultValue = padLeftZeros(defaultValue, segment.length);\n      return insertAt(defaultValue, segmentValue, segment.length - segmentValue.length, segment.length);\n    }\n  }, {\n    key: \"enrichSegmentDefinitions\",\n    value: function enrichSegmentDefinitions(segments) {\n      var _this2 = this;\n      this.positionFormats = {};\n      this.segments = [];\n      var position = 0;\n      var _iterator2 = _createForOfIteratorHelper(segments),\n        _step2;\n      try {\n        var _loop = function _loop() {\n          var segment = _step2.value;\n          var max = segment.max;\n          var fullSegment = Object.assign(Object.assign({}, segment), {\n            max: typeof max === 'number' ? function () {\n              return max;\n            } : max,\n            start: position,\n            end: position + segment.length\n          });\n          _this2.segments.push(fullSegment);\n          // insert this format segment for every char in the max value\n          for (var j = 0; j < fullSegment.length; j++) {\n            _this2.positionFormats[position++] = fullSegment;\n          }\n          // skip a position for separator\n          position++;\n        };\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          _loop();\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n  }]);\n  return MaskFormat;\n}();\nexport default MaskFormat;","map":{"version":3,"mappings":"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","names":["padLeftZeros","insertAt","MaskFormat","separator","inputSeparators","segments","positionFormats","enrichSegmentDefinitions","value","withSeparator","isValid","key","indexOf","inputSegments","split","length","every","segmentValue","i","segment","match","intValue","parseInt","min","max","validValue","tryAppendSeparator","substring","reverse","lastSegmentValue","completeSegmentValues","lastSegment","paddedLastSegmentValue","padWithDefaultValue","partial","nextSegment","push","join","correctMinMaxValues","position","enteredDigit","substr","start","segmentPosition","newValue","cursorStart","cursorEnd","isCursorAtSeparator","isSegmentStart","end","currentSegment","insertionEnd","Math","getMaxLength","undefined","last","slice","segmentMax","toInsert","toFixed","text","keyArr","trim","formattedValue","result","processKey","initialValue","initialPosition","isSeparator","handleSeparatorInput","isCursorAtEnd","getSegmentValueWithAddition","segmentMaxValue","getSegmentMaxValue","segmentMinValue","getSegmentMinValue","firstDigitGreater","isValidPosition","exceedsMaxAtSegmentStart","defaultValue","default","fullSegment","j"],"sources":["/Users/tangyizhi/Desktop/Assignment2/frontend/node_modules/@cloudscape-design/components/internal/components/masked-input/utils/lib/default/internal/components/masked-input/utils/mask-format.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { padLeftZeros } from '../../../utils/strings';\nimport { insertAt } from './strings';\n\ninterface FormatSegment {\n  min: number;\n  max: number | ((value: string) => number);\n  length: number;\n  default?: number;\n}\n\ninterface FormatSegmentFull extends FormatSegment {\n  start: number;\n  max(value: string): number;\n  end: number;\n}\n\nexport interface MaskArgs {\n  separator: string;\n  inputSeparators?: Array<string>;\n  segments: Array<FormatSegment>;\n}\n\nexport interface ChangeResult {\n  value: string;\n  position: number;\n}\n\nclass MaskFormat {\n  separator: string;\n  private inputSeparators: Array<string>;\n  private segments: Array<FormatSegmentFull>;\n  private positionFormats: { [x: number]: FormatSegmentFull };\n\n  constructor({ separator, inputSeparators = [], segments }: MaskArgs) {\n    this.positionFormats = {};\n    this.segments = [];\n    this.separator = separator;\n\n    this.inputSeparators = [...inputSeparators, separator];\n    this.enrichSegmentDefinitions(segments);\n  }\n\n  tryAppendSeparator(value: string) {\n    const withSeparator = `${value}${this.separator}`;\n    return this.isValid(withSeparator) ? withSeparator : value;\n  }\n\n  isSeparator(key: string): boolean {\n    return this.inputSeparators.indexOf(key) !== -1;\n  }\n\n  isValid(value: string): boolean {\n    const inputSegments = value.split(this.separator);\n\n    if (inputSegments.length > this.segments.length) {\n      return false;\n    }\n\n    return inputSegments.every((segmentValue, i) => {\n      const segment = this.segments[i];\n\n      // disallow empty segments\n      if (segmentValue === '') {\n        // except empty last segment (e.g. trailing separator \"12:\")\n        if (i === inputSegments.length - 1) {\n          return true;\n        } else {\n          return false;\n        }\n      }\n      // only allow numerals\n      if (!segmentValue.match(/^\\d+$/)) {\n        return false;\n      }\n      // disallow incomplete segments, except at end\n      if (segmentValue.length < segment.length && i !== inputSegments.length - 1) {\n        return false;\n      }\n      // limit numerical value\n      const intValue = parseInt(segmentValue, 10);\n\n      // Handles values padded with 0s that are lost during parsing\n      if (segmentValue.length > segment.length) {\n        return false;\n      }\n\n      if (intValue < segment.min || intValue > segment.max(value)) {\n        // allow incomplete segments in final position\n        if (i === inputSegments.length - 1 && segmentValue.length < segment.length) {\n          return true;\n        }\n        return false;\n      }\n      return true;\n    });\n  }\n\n  getValidValue(value: string): string {\n    let validValue = value;\n\n    do {\n      if (this.isValid(validValue)) {\n        return this.tryAppendSeparator(validValue);\n      }\n\n      validValue = validValue.substring(0, validValue.length - 1);\n    } while (validValue.length > 0);\n\n    return '';\n  }\n\n  autoComplete(value: string): string {\n    // aka [...completeSegments, lastSegment] = value.split(':')\n    // but that's not valid :/\n    const [lastSegmentValue, ...completeSegmentValues] = value.split(this.separator).reverse();\n    const lastSegment = this.segments[completeSegmentValues.length];\n\n    // if the last segment isn't complete, pad it with a preceding 0\n    // e.g. 10:1 -> 10:01\n    const paddedLastSegmentValue = this.padWithDefaultValue(lastSegmentValue, lastSegment);\n\n    // recombine, and pad with extra segments for the full format\n    const partial = [...completeSegmentValues.reverse(), paddedLastSegmentValue];\n    while (partial.length < this.segments.length) {\n      const nextSegment = this.segments[partial.length];\n      const segmentValue = this.padWithDefaultValue('', nextSegment);\n      partial.push(segmentValue);\n    }\n    value = partial.join(this.separator);\n    value = this.correctMinMaxValues(value);\n    return value;\n  }\n\n  getSegmentValueWithAddition(position: number, value: string, enteredDigit: string) {\n    const segment = this.positionFormats[position];\n    const segmentValue = value.substr(segment.start, segment.length);\n    const segmentPosition = position - segment.start;\n    const newValue = insertAt(segmentValue, enteredDigit, segmentPosition, segmentPosition + 1);\n    return parseInt(newValue, 10);\n  }\n\n  replaceDigitsWithZeroes(value: string, cursorStart: number, cursorEnd: number): ChangeResult {\n    const position = this.isCursorAtSeparator(cursorStart) ? cursorStart + 1 : cursorStart;\n\n    // move selection forwards if it starts with a separator\n    if (this.isCursorAtSeparator(cursorStart)) {\n      cursorStart++;\n    }\n\n    // first, insert zeros in a partial segment at beginning of selection\n    if (!this.isSegmentStart(cursorStart)) {\n      const segment = this.positionFormats[cursorStart];\n      value = insertAt(value, padLeftZeros('', segment.end - cursorStart), cursorStart, segment.end);\n      cursorStart = segment.end + 1;\n    }\n\n    // then loop through remaining segments, filling with zeros\n    let currentSegment: FormatSegmentFull;\n    while (cursorStart < cursorEnd && (currentSegment = this.positionFormats[cursorStart + 1])) {\n      const insertionEnd = Math.min(cursorEnd, currentSegment.end);\n      value = insertAt(\n        value,\n        padLeftZeros('', insertionEnd - currentSegment.start),\n        currentSegment.start,\n        insertionEnd\n      );\n      cursorStart = insertionEnd + 1;\n    }\n\n    value = this.correctMinMaxValues(value);\n\n    return {\n      value,\n      position,\n    };\n  }\n\n  handleSeparatorInput(value: string, position: number): ChangeResult | void {\n    if (position === value.length && !this.isSegmentStart(position)) {\n      const segment = this.positionFormats[position];\n      let segmentValue = value.substr(segment.start, segment.length);\n      segmentValue = this.padWithDefaultValue(segmentValue, segment);\n      value = insertAt(value, segmentValue, segment.start, segment.end);\n      value = this.correctMinMaxValues(value);\n      return {\n        value,\n        position: value.length,\n      };\n    }\n  }\n\n  isCursorAtSeparator(position: number) {\n    return 0 < position && position < this.getMaxLength() && this.positionFormats[position] === undefined;\n  }\n\n  isSegmentStart(position: number) {\n    return position === 0 || this.isCursorAtSeparator(position - 1);\n  }\n\n  getSegmentMaxValue(value: string, position: number): number {\n    return this.positionFormats[position].max(value);\n  }\n\n  getSegmentMinValue(value: string, position: number): number {\n    return this.positionFormats[position].min;\n  }\n\n  getMaxLength() {\n    const last = this.segments[this.segments.length - 1];\n    return last.start + last.length;\n  }\n\n  deleteSeparator(value: string, position: number): ChangeResult {\n    value = insertAt(value, '0', position - 2, position - 1);\n\n    return {\n      value: this.correctMinMaxValues(value),\n      position: position - 2,\n    };\n  }\n\n  deleteDigit(value: string, position: number): ChangeResult {\n    value = insertAt(value, '0', position - 1, position);\n\n    // 23:59|: => backspace => 23:5|\n    const length = value.length;\n    if (value.slice(length - 2) === '0:') {\n      value = value.slice(0, length - 2);\n    }\n\n    return {\n      value: this.correctMinMaxValues(value),\n      position: position - 1,\n    };\n  }\n\n  correctMinMaxValues(value: string): string {\n    let segment = this.positionFormats[0];\n    while (segment && value.length >= segment.end) {\n      const segmentValue = parseInt(value.substr(segment.start, segment.length), 10);\n      const segmentMax = segment.max(value);\n      if (segmentValue < segment.min) {\n        let toInsert = segment.min.toFixed();\n        toInsert = padLeftZeros(toInsert, segment.length);\n        value = insertAt(value, toInsert, segment.start, segment.end);\n      }\n      if (segmentValue > segmentMax) {\n        value = insertAt(value, segmentMax.toFixed(), segment.start, segment.end);\n      }\n      segment = this.positionFormats[segment.end + 1];\n    }\n    return value.substr(0, this.segments[this.segments.length - 1].end);\n  }\n\n  formatPastedText(text: string, value: string, cursorStart: number, cursorEnd: number): string {\n    const keyArr = text.trim().split('');\n\n    let position = cursorStart;\n\n    let formattedValue = value;\n    // if a selection range captures the end of the current value\n    // we replace it with the value in buffer even if the value in buffer is shorter\n    if (cursorEnd > cursorStart && cursorEnd === value.length) {\n      formattedValue = value.slice(0, cursorStart);\n    }\n\n    for (const key of keyArr) {\n      if (position >= this.getMaxLength()) {\n        break;\n      }\n\n      const result = this.processKey(formattedValue, key, position);\n      formattedValue = result.value;\n      position = result.position;\n    }\n\n    return this.tryAppendSeparator(formattedValue);\n  }\n\n  processKey(initialValue: string, key: string, initialPosition: number) {\n    let value = initialValue;\n    let position = initialPosition;\n\n    if (this.isSeparator(key)) {\n      const result = this.handleSeparatorInput(value, position);\n      if (result) {\n        value = result.value;\n        position = result.position;\n      }\n    } else {\n      const isCursorAtEnd = position === value.length;\n      const segmentValue = this.getSegmentValueWithAddition(position, value, key);\n      const segmentMaxValue = this.getSegmentMaxValue(value, position);\n      const segmentMinValue = this.getSegmentMinValue(value, position);\n      const firstDigitGreater = parseInt(key, 10) > parseInt(segmentMaxValue.toFixed()[0], 10);\n      const isValidPosition = isCursorAtEnd || segmentValue.toFixed().length === 1;\n      const exceedsMaxAtSegmentStart = this.isSegmentStart(position) && isValidPosition && firstDigitGreater;\n\n      if (exceedsMaxAtSegmentStart) {\n        // 22:| => Enter '9' => 22:09|\n        // |1 => Enter '9' => 09|\n        value = insertAt(value, `0${key}`, position, position + 2);\n        position += 2;\n      } else if (segmentValue > segmentMaxValue && this.isSegmentStart(position)) {\n        // 22:|22 => Enter '9' => 22:59|\n        value = insertAt(value, segmentMaxValue.toFixed(), position, position + segmentMaxValue.toFixed().length);\n        position += segmentMaxValue.toFixed().length;\n      } else if (segmentValue > segmentMaxValue) {\n        // 2|2:22 => Enter '9' => 23:|22\n        value = insertAt(value, segmentMaxValue.toFixed(), position - 1, position + 1);\n        position += 1;\n      } else if (segmentValue < segmentMinValue && !this.isSegmentStart(position)) {\n        // 0| => enter '0' => 01:\n        value = insertAt(value, segmentMinValue.toFixed(), position, position + 1);\n        position += 1;\n      } else {\n        // 22:| => Enter '5' => 23:5|\n        value = insertAt(value, key, position, position + 1);\n        position += 1;\n      }\n    }\n\n    value = this.tryAppendSeparator(value);\n\n    // Move cursor in front of separator if behind after overwriting a character\n    if (this.isCursorAtSeparator(position)) {\n      position++;\n    }\n\n    return { value, position };\n  }\n\n  private padWithDefaultValue(segmentValue: string, segment: FormatSegmentFull) {\n    let defaultValue = (segment.default || segment.min).toFixed();\n    defaultValue = padLeftZeros(defaultValue, segment.length);\n    return insertAt(defaultValue, segmentValue, segment.length - segmentValue.length, segment.length);\n  }\n\n  private enrichSegmentDefinitions(segments: FormatSegment[]) {\n    this.positionFormats = {};\n    this.segments = [];\n    let position = 0;\n    for (const segment of segments) {\n      const max = segment.max;\n      const fullSegment: FormatSegmentFull = {\n        ...segment,\n        max: typeof max === 'number' ? () => max : max,\n        start: position,\n        end: position + segment.length,\n      };\n      this.segments.push(fullSegment);\n      // insert this format segment for every char in the max value\n      for (let j = 0; j < fullSegment.length; j++) {\n        this.positionFormats[position++] = fullSegment;\n      }\n      // skip a position for separator\n      position++;\n    }\n  }\n}\n\nexport default MaskFormat;\n"]},"metadata":{},"sourceType":"module"}