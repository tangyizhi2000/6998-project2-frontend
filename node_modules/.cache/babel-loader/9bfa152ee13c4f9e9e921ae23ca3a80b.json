{"ast":null,"code":"import _slicedToArray from \"/Users/tangyizhi/Desktop/Assignment2/frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { useRef, useState } from 'react';\nimport { closestCenter, PointerSensor, useSensor, useSensors } from '@dnd-kit/core';\nimport { hasSortableData } from '@dnd-kit/sortable';\nimport { KeyboardSensor } from './keyboard-sensor';\nvar KeyboardCode;\n(function (KeyboardCode) {\n  KeyboardCode[\"Space\"] = \"Space\";\n  KeyboardCode[\"Down\"] = \"ArrowDown\";\n  KeyboardCode[\"Right\"] = \"ArrowRight\";\n  KeyboardCode[\"Left\"] = \"ArrowLeft\";\n  KeyboardCode[\"Up\"] = \"ArrowUp\";\n  KeyboardCode[\"Esc\"] = \"Escape\";\n  KeyboardCode[\"Enter\"] = \"Enter\";\n})(KeyboardCode || (KeyboardCode = {}));\n// A custom collision detection algorithm is used when using a keyboard to\n// work around an unexpected behavior when reordering items of variable height\n// with the keyboard.\n// Neither closestCenter nor closestCorners work really well for this case,\n// because the center (or corners) of a tall rectangle might be so low that it\n// is detected as being closest to the rectangle below of the one it should\n// actually swap with.\n// Instead of relying on coordinates, the expected results are achieved by\n// moving X positions up or down in the initially sorted array, depending on\n// the desired direction.\n// We let our collisionDetection and customCoordinateGetter use the same\n// getClosestId function which takes its value from the current component\n// state, to make sure they are always in sync.\nexport default function useDragAndDropReorder(_ref) {\n  var sortedOptions = _ref.sortedOptions;\n  var isKeyboard = useRef(false);\n  var positionDelta = useRef(0);\n  var _useState = useState(null),\n    _useState2 = _slicedToArray(_useState, 2),\n    activeItemId = _useState2[0],\n    setActiveItemId = _useState2[1];\n  var setActiveItem = function setActiveItem(id) {\n    setActiveItemId(id);\n    if (!id) {\n      isKeyboard.current = false;\n      positionDelta.current = 0;\n    }\n  };\n  var handleKeyDown = function handleKeyDown(event) {\n    if (isKeyboard.current && activeItemId) {\n      var currentTargetIndex = sortedOptions.findIndex(function (_ref2) {\n        var id = _ref2.id;\n        return id === activeItemId;\n      }) + positionDelta.current;\n      if (event.key === 'ArrowDown' && currentTargetIndex < sortedOptions.length - 1) {\n        positionDelta.current += 1;\n      } else if (event.key === 'ArrowUp' && currentTargetIndex > 0) {\n        positionDelta.current -= 1;\n      }\n    }\n    if (activeItemId && isEscape(event.key)) {\n      // Prevent modal from closing when pressing Esc to cancel the dragging action\n      event.stopPropagation();\n    }\n  };\n  var getClosestId = function getClosestId(active) {\n    if (positionDelta.current === 0) {\n      return active.id;\n    }\n    var currentIndex = sortedOptions.findIndex(function (_ref3) {\n      var id = _ref3.id;\n      return id === active.id;\n    });\n    var newIndex = Math.max(0, Math.min(sortedOptions.length - 1, currentIndex + positionDelta.current));\n    return sortedOptions[newIndex].id;\n  };\n  var collisionDetection = function collisionDetection(_ref4) {\n    var active = _ref4.active,\n      collisionRect = _ref4.collisionRect,\n      droppableContainers = _ref4.droppableContainers,\n      droppableRects = _ref4.droppableRects,\n      pointerCoordinates = _ref4.pointerCoordinates;\n    if (isKeyboard.current) {\n      // For keyboard interaction, determine the colliding container based on the movements made by the arrow keys,\n      // via getClosestId\n      var collidingContainer = getCollidingContainer({\n        activeId: active.id,\n        closestId: getClosestId(active),\n        droppableContainers: droppableContainers\n      });\n      return collidingContainer ? [collidingContainer] : [];\n    } else {\n      // For mouse interaction, use the closest center algorithm\n      return closestCenter({\n        active: active,\n        collisionRect: collisionRect,\n        droppableRects: droppableRects,\n        droppableContainers: droppableContainers,\n        pointerCoordinates: pointerCoordinates\n      });\n    }\n  };\n  var coordinateGetter = function coordinateGetter(event, _ref5) {\n    var _ref5$context = _ref5.context,\n      active = _ref5$context.active,\n      collisionRect = _ref5$context.collisionRect,\n      droppableRects = _ref5$context.droppableRects,\n      droppableContainers = _ref5$context.droppableContainers;\n    if (event.code === KeyboardCode.Up || event.code === KeyboardCode.Down) {\n      event.preventDefault();\n      if (!active || !collisionRect) {\n        return;\n      }\n      var closestId = getClosestId(active);\n      if (closestId !== null) {\n        var activeDroppable = droppableContainers.get(active.id);\n        var newDroppable = droppableContainers.get(closestId);\n        var newRect = newDroppable ? droppableRects.get(newDroppable.id) : null;\n        var newNode = newDroppable === null || newDroppable === void 0 ? void 0 : newDroppable.node.current;\n        if (newNode && newRect && activeDroppable && newDroppable) {\n          var isAfterActive = isAfter(activeDroppable, newDroppable);\n          var offset = {\n            x: isAfterActive ? collisionRect.width - newRect.width : 0,\n            y: isAfterActive ? collisionRect.height - newRect.height : 0\n          };\n          var rectCoordinates = {\n            x: newRect.left,\n            y: newRect.top\n          };\n          return {\n            x: rectCoordinates.x - offset.x,\n            y: rectCoordinates.y - offset.y\n          };\n        }\n      }\n    }\n  };\n  var sensors = useSensors(useSensor(PointerSensor), useSensor(KeyboardSensor, {\n    coordinateGetter: coordinateGetter,\n    onActivation: function onActivation() {\n      isKeyboard.current = true;\n    }\n  }));\n  return {\n    activeItem: activeItemId,\n    collisionDetection: collisionDetection,\n    coordinateGetter: coordinateGetter,\n    handleKeyDown: handleKeyDown,\n    sensors: sensors,\n    setActiveItem: setActiveItem\n  };\n}\nfunction isAfter(a, b) {\n  return hasSortableData(a) && hasSortableData(b) && a.data.current.sortable.index < b.data.current.sortable.index;\n}\nfunction getCollidingContainer(_ref6) {\n  var activeId = _ref6.activeId,\n    closestId = _ref6.closestId,\n    droppableContainers = _ref6.droppableContainers;\n  if (closestId === activeId) {\n    return;\n  }\n  var collidingContainer = droppableContainers.find(function (_ref7) {\n    var id = _ref7.id;\n    return id === closestId;\n  });\n  if (collidingContainer) {\n    return {\n      id: collidingContainer.id,\n      data: {\n        droppableContainer: collidingContainer,\n        value: 0\n      }\n    };\n  }\n}\nvar isEscape = function isEscape(key) {\n  return key === 'Escape' || key === 'Esc';\n};","map":{"version":3,"mappings":"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","names":["useRef","useState","closestCenter","PointerSensor","useSensor","useSensors","hasSortableData","KeyboardSensor","KeyboardCode","useDragAndDropReorder","sortedOptions","isKeyboard","positionDelta","activeItemId","setActiveItemId","setActiveItem","id","current","handleKeyDown","event","currentTargetIndex","findIndex","key","length","isEscape","stopPropagation","getClosestId","active","currentIndex","newIndex","Math","max","min","collisionDetection","collisionRect","droppableContainers","droppableRects","pointerCoordinates","collidingContainer","getCollidingContainer","activeId","closestId","coordinateGetter","context","code","Up","Down","preventDefault","activeDroppable","get","newDroppable","newRect","newNode","node","isAfterActive","isAfter","offset","x","width","y","height","rectCoordinates","left","top","sensors","onActivation","activeItem","a","b","data","sortable","index","find","droppableContainer","value"],"sources":["/Users/tangyizhi/Desktop/Assignment2/frontend/node_modules/@cloudscape-design/components/collection-preferences/content-display/lib/default/collection-preferences/content-display/use-drag-and-drop-reorder.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport React, { useRef, useState } from 'react';\nimport {\n  Active,\n  closestCenter,\n  CollisionDetection,\n  DroppableContainer,\n  KeyboardCoordinateGetter,\n  PointerSensor,\n  UniqueIdentifier,\n  useSensor,\n  useSensors,\n} from '@dnd-kit/core';\nimport { CollectionPreferencesProps } from '../interfaces';\nimport { hasSortableData } from '@dnd-kit/sortable';\nimport { KeyboardSensor } from './keyboard-sensor';\n\nenum KeyboardCode {\n  Space = 'Space',\n  Down = 'ArrowDown',\n  Right = 'ArrowRight',\n  Left = 'ArrowLeft',\n  Up = 'ArrowUp',\n  Esc = 'Escape',\n  Enter = 'Enter',\n}\n\n// A custom collision detection algorithm is used when using a keyboard to\n// work around an unexpected behavior when reordering items of variable height\n// with the keyboard.\n\n// Neither closestCenter nor closestCorners work really well for this case,\n// because the center (or corners) of a tall rectangle might be so low that it\n// is detected as being closest to the rectangle below of the one it should\n// actually swap with.\n\n// Instead of relying on coordinates, the expected results are achieved by\n// moving X positions up or down in the initially sorted array, depending on\n// the desired direction.\n\n// We let our collisionDetection and customCoordinateGetter use the same\n// getClosestId function which takes its value from the current component\n// state, to make sure they are always in sync.\n\nexport default function useDragAndDropReorder({\n  sortedOptions,\n}: {\n  sortedOptions: ReadonlyArray<CollectionPreferencesProps.VisibleContentOption>;\n}) {\n  const isKeyboard = useRef(false);\n  const positionDelta = useRef(0);\n  const [activeItemId, setActiveItemId] = useState<UniqueIdentifier | null>(null);\n\n  const setActiveItem = (id: UniqueIdentifier | null) => {\n    setActiveItemId(id);\n    if (!id) {\n      isKeyboard.current = false;\n      positionDelta.current = 0;\n    }\n  };\n\n  const handleKeyDown = (event: React.KeyboardEvent) => {\n    if (isKeyboard.current && activeItemId) {\n      const currentTargetIndex = sortedOptions.findIndex(({ id }) => id === activeItemId) + positionDelta.current;\n      if (event.key === 'ArrowDown' && currentTargetIndex < sortedOptions.length - 1) {\n        positionDelta.current += 1;\n      } else if (event.key === 'ArrowUp' && currentTargetIndex > 0) {\n        positionDelta.current -= 1;\n      }\n    }\n    if (activeItemId && isEscape(event.key)) {\n      // Prevent modal from closing when pressing Esc to cancel the dragging action\n      event.stopPropagation();\n    }\n  };\n\n  const getClosestId = (active: Active) => {\n    if (positionDelta.current === 0) {\n      return active.id;\n    }\n    const currentIndex = sortedOptions.findIndex(({ id }) => id === active.id);\n    const newIndex = Math.max(0, Math.min(sortedOptions.length - 1, currentIndex + positionDelta.current));\n    return sortedOptions[newIndex].id;\n  };\n\n  const collisionDetection: CollisionDetection = ({\n    active,\n    collisionRect,\n    droppableContainers,\n    droppableRects,\n    pointerCoordinates,\n  }) => {\n    if (isKeyboard.current) {\n      // For keyboard interaction, determine the colliding container based on the movements made by the arrow keys,\n      // via getClosestId\n      const collidingContainer = getCollidingContainer({\n        activeId: active.id,\n        closestId: getClosestId(active),\n        droppableContainers,\n      });\n      return collidingContainer ? [collidingContainer] : [];\n    } else {\n      // For mouse interaction, use the closest center algorithm\n      return closestCenter({ active, collisionRect, droppableRects, droppableContainers, pointerCoordinates });\n    }\n  };\n\n  const coordinateGetter: KeyboardCoordinateGetter = (\n    event,\n    { context: { active, collisionRect, droppableRects, droppableContainers } }\n  ) => {\n    if (event.code === KeyboardCode.Up || event.code === KeyboardCode.Down) {\n      event.preventDefault();\n\n      if (!active || !collisionRect) {\n        return;\n      }\n\n      const closestId = getClosestId(active);\n\n      if (closestId !== null) {\n        const activeDroppable = droppableContainers.get(active.id);\n        const newDroppable = droppableContainers.get(closestId);\n        const newRect = newDroppable ? droppableRects.get(newDroppable.id) : null;\n        const newNode = newDroppable?.node.current;\n\n        if (newNode && newRect && activeDroppable && newDroppable) {\n          const isAfterActive = isAfter(activeDroppable, newDroppable);\n          const offset = {\n            x: isAfterActive ? collisionRect.width - newRect.width : 0,\n            y: isAfterActive ? collisionRect.height - newRect.height : 0,\n          };\n          const rectCoordinates = {\n            x: newRect.left,\n            y: newRect.top,\n          };\n\n          return {\n            x: rectCoordinates.x - offset.x,\n            y: rectCoordinates.y - offset.y,\n          };\n        }\n      }\n    }\n  };\n\n  const sensors = useSensors(\n    useSensor(PointerSensor),\n    useSensor(KeyboardSensor, {\n      coordinateGetter,\n      onActivation: () => {\n        isKeyboard.current = true;\n      },\n    })\n  );\n\n  return {\n    activeItem: activeItemId,\n    collisionDetection,\n    coordinateGetter,\n    handleKeyDown,\n    sensors,\n    setActiveItem,\n  };\n}\n\nfunction isAfter(a: DroppableContainer, b: DroppableContainer) {\n  return hasSortableData(a) && hasSortableData(b) && a.data.current.sortable.index < b.data.current.sortable.index;\n}\n\nfunction getCollidingContainer({\n  activeId,\n  closestId,\n  droppableContainers,\n}: {\n  activeId: UniqueIdentifier;\n  closestId: UniqueIdentifier;\n  droppableContainers: DroppableContainer[];\n}) {\n  if (closestId === activeId) {\n    return;\n  }\n  const collidingContainer = droppableContainers.find(({ id }) => id === closestId);\n  if (collidingContainer) {\n    return {\n      id: collidingContainer.id,\n      data: {\n        droppableContainer: collidingContainer,\n        value: 0,\n      },\n    };\n  }\n}\n\nconst isEscape = (key: string) => key === 'Escape' || key === 'Esc';\n"]},"metadata":{},"sourceType":"module"}