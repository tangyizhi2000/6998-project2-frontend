{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { Position } from \"../utils/position\";\nimport { MoveSolutionState, findNextSolutions } from \"./engine-solution\";\nimport { checkItemsIntersection, sortGridItems } from \"./utils\";\nimport { createMove } from \"./utils\";\n// The solutions can't be searched for infinitely in case the algorithm can't converge.\n// The safety counter ensures there is going to be user feedback within reasonable time.\nconst MAX_SOLUTION_DEPTH = 100;\n// At any given step only a few best solutions are taken to ensure faster convergence.\n// The larger the number the better chance the most optimal solution is found for the given priorities\n// at a cost of more computations made.\nconst NUM_BEST_SOLUTIONS = 5;\n/**\n * The function takes the current layout state (item placements from the previous steps and all moves done so far)\n * and a user command increment that describes an item transition by one cell in some direction.\n * The function finds overlapping elements and resolves all overlaps if possible (always possible when no conflicts).\n * The result in an updated state (new item placements, additional moves, and item conflicts if any).\n */\nexport function resolveOverlaps(layoutState, userMove) {\n  // For better UX the layout engine is optimized for item swaps.\n  // The swapping is only preferred for the user-controlled item and it can only happen when the item overlaps another\n  // item past its midpoint. When the overlap is not enough, the underlying item is considered a conflict and it is not\n  // allowed to move anywhere. The user command cannot be committed at this step.\n  const conflicts = findConflicts(layoutState.grid, layoutState.conflicts, userMove);\n  // The user moves are always applied as is. When the user-controlled item overlaps with other items and there is\n  // no conflict, the type=\"OVERLAP\" moves are performed to settle the grid so that no items overlap with one another.\n  // For this type of move multiple solutions are often available. To ensure the best result all solutions are tried\n  // and a score is given to each. The solution with the minimal score wins.\n  // The process stars from the initial state and the user move. The initial score and the user move score are 0.\n  const initialState = new MoveSolutionState(layoutState.grid, layoutState.moves, conflicts);\n  const initialSolution = [initialState, userMove];\n  // All solutions are guaranteed to have unique move sequences but different move sequences can produce the same result.\n  // As it is never expected for one item to be moved over to the same location twice the combination of the item ID,\n  // item position, and solution score can uniquely represent the solution.\n  // For earlier moves taking a solution from the cache can prevent hundreds of subsequent computations.\n  const solutionsCache = new Map();\n  const createCacheKey = _ref => {\n    let [state, move] = _ref;\n    return `${move.itemId} ${move.x}:${move.y}:${state.score + move.score}`;\n  };\n  let moveSolutions = [initialSolution];\n  let bestSolution = null;\n  let convergenceCounter = MAX_SOLUTION_DEPTH;\n  // The resolution process continues until there is at least one reasonable solution left.\n  // The repetitive, dead-end, and expensive (compared to the best so far) solutions are excluded\n  // so that eventually no more variants to try remain.\n  // The convergence safety counter ensures the logical errors to not cause an infinite loop.\n  while (moveSolutions.length > 0) {\n    let nextSolutions = [];\n    for (let solutionIndex = 0; solutionIndex < Math.min(NUM_BEST_SOLUTIONS, moveSolutions.length); solutionIndex++) {\n      const [solutionState, solutionMove] = moveSolutions[solutionIndex];\n      // Discard the solution before performing the move if its next score is already above the best score found so far.\n      if (bestSolution && solutionState.score + solutionMove.score >= bestSolution.score) {\n        continue;\n      }\n      // Perform the move by mutating the solution's state: grid, moves, score, etc.\n      makeMove(solutionState, solutionMove);\n      // If no overlaps are left the solution is considered valid and the best so far.\n      // The next solutions having the same or higher score will be discarded.\n      if (solutionState.overlaps.size === 0) {\n        bestSolution = solutionState;\n      }\n      // Otherwise, the next set of solutions will be considered. There can be up to four solutions per overlap\n      // (by the number of possible directions to move).\n      else {\n        for (const nextSolution of findNextSolutions(solutionState)) {\n          const solutionKey = createCacheKey(nextSolution);\n          const cachedSolution = solutionsCache.get(solutionKey);\n          if (!cachedSolution) {\n            nextSolutions.push(nextSolution);\n            solutionsCache.set(solutionKey, nextSolution);\n          }\n        }\n      }\n    }\n    // The solutions are ordered by the total score so that the best (so far) solutions are considered first.\n    moveSolutions = nextSolutions.sort((s1, s2) => s1[0].score + s1[1].score - (s2[0].score + s2[1].score));\n    nextSolutions = [];\n    // Reaching the convergence counter might indicate an issue with the algorithm as ideally it should converge faster.\n    // However, that does not necessarily mean the logical problem and no exception should be thrown.\n    // Instead, the current best solution if available applies or a simple solution is offered instead.\n    convergenceCounter--;\n    if (convergenceCounter <= 0) {\n      break;\n    }\n  }\n  // If there are conflicts it might not be possible to find a solution as the items are not allowed to\n  // overlap with the conflicts. In that case the initial state (with the user move applied) is returned.\n  // The user can move the item further to resolve the conflicts which will also unblock the overlaps resolution.\n  // Also, the solution might not be found due to the engine constraints. For example, the convergence number might\n  // be reached before any solution is found or the number of best solutions constraint can filter the only possible\n  // solutions away. In that case the simple solution is returned with all overlapping items pushed to the bottom.\n  if (!bestSolution) {\n    bestSolution = initialState.conflicts ? initialState : resolveOverlapsDown(initialState);\n  }\n  // After each step unless there are conflicts the type=\"FLOAT\" moves are performed on all items\n  // but the user controlled one that can be moved to the top without overlapping with other items.\n  return bestSolution.conflicts ? bestSolution : refloatGrid(bestSolution, userMove);\n}\n// Resolves overlaps the simple way by pushing all overlapping items to the bottom until none is left.\nfunction resolveOverlapsDown(state) {\n  // Move overlapping items to the bottom until resolved. Repeat until no overlaps left.\n  // This solution always converges because there is always free space at the bottom by design.\n  while (state.overlaps.size > 0) {\n    const overlaps = sortGridItems([...state.overlaps].map(_ref2 => {\n      let [overlapId] = _ref2;\n      return state.grid.getItem(overlapId);\n    }));\n    for (const overlap of overlaps) {\n      let y = overlap.y + 1;\n      while (state.grid.getOverlaps({\n        ...overlap,\n        y\n      }).length > 0) {\n        y++;\n      }\n      makeMove(state, createMove(\"OVERLAP\", overlap, new Position({\n        x: overlap.x,\n        y\n      })));\n    }\n  }\n  return state;\n}\n// Find items that can \"float\" to the top and apply the necessary moves.\nfunction refloatGrid(layoutState, userMove) {\n  const state = new MoveSolutionState(layoutState.grid, layoutState.moves, layoutState.conflicts);\n  function makeRefloat() {\n    let needAnotherRefloat = false;\n    for (const item of state.grid.items) {\n      // The active item is skipped until the operation is committed.\n      if (item.id === (userMove === null || userMove === void 0 ? void 0 : userMove.itemId)) {\n        continue;\n      }\n      let y = item.y - 1;\n      let move = null;\n      while (y >= 0) {\n        const moveAttempt = createMove(\"FLOAT\", item, new Position({\n          x: item.x,\n          y\n        }));\n        if (state.grid.getOverlaps({\n          id: item.id,\n          ...moveAttempt\n        }).length > 0) {\n          break;\n        }\n        y--;\n        move = moveAttempt;\n      }\n      if (move) {\n        makeMove(state, move);\n        needAnotherRefloat = true;\n      }\n    }\n    if (needAnotherRefloat) {\n      makeRefloat();\n    }\n  }\n  makeRefloat();\n  return state;\n}\n// Finds items that cannot be resolved at the current step as of being partially overlapped by the user-move item.\nfunction findConflicts(grid, previousConflicts, userMove) {\n  var _a;\n  // The conflicts are only defined for MOVE command type to make swaps possible.\n  if (userMove.type !== \"MOVE\") {\n    return null;\n  }\n  // Using existing conflict direction if available so that conflicting items would swap consistently.\n  // If only the current direction is considered the multi-item conflicts become difficult to comprehend.\n  const direction = (_a = previousConflicts === null || previousConflicts === void 0 ? void 0 : previousConflicts.direction) !== null && _a !== void 0 ? _a : userMove.direction;\n  // Conflicts are partial overlaps. When the item is overlapped fully (considering the direction) it is\n  // no longer treated as conflict.\n  const overlaps = grid.getOverlaps({\n    ...userMove,\n    id: userMove.itemId\n  });\n  const conflicts = overlaps.filter(overlap => {\n    switch (direction) {\n      case \"left\":\n        return overlap.x < userMove.x;\n      case \"right\":\n        return overlap.x + overlap.width - 1 > userMove.x + userMove.width - 1;\n      case \"up\":\n        return overlap.y < userMove.y;\n      case \"down\":\n        return overlap.y + overlap.height - 1 > userMove.y + userMove.height - 1;\n    }\n  });\n  if (conflicts.length > 0) {\n    return {\n      direction,\n      items: new Set(conflicts.map(item => item.id))\n    };\n  }\n  return null;\n}\n// Applies given move to the solution state by updating the grid, moves, overlaps, and score.\nfunction makeMove(state, nextMove) {\n  updateGridWithMove(state, nextMove);\n  updateOverlaps(state, nextMove);\n  state.moves.push(nextMove);\n  state.score += nextMove.score;\n}\nfunction updateGridWithMove(_ref3, move) {\n  let {\n    grid\n  } = _ref3;\n  switch (move.type) {\n    case \"MOVE\":\n    case \"OVERLAP\":\n    case \"FLOAT\":\n      return grid.move(move.itemId, move.x, move.y);\n    case \"INSERT\":\n      return grid.insert({\n        id: move.itemId,\n        ...move\n      });\n    case \"REMOVE\":\n      return grid.remove(move.itemId);\n    case \"RESIZE\":\n      return grid.resize(move.itemId, move.width, move.height);\n  }\n}\nfunction updateOverlaps(state, move) {\n  var _a;\n  // Find and assign items that will overlap with the moved item after the move is performed\n  // unless the overlapping items are considered as conflicts.\n  for (const newOverlap of state.grid.getOverlaps({\n    ...move,\n    id: move.itemId\n  })) {\n    if (!((_a = state.conflicts) === null || _a === void 0 ? void 0 : _a.items.has(newOverlap.id))) {\n      state.overlaps.set(newOverlap.id, move.itemId);\n    }\n  }\n  // Remove no longer valid overlaps after the move is performed.\n  for (const [overlapId, overlapIssuerId] of state.overlaps) {\n    if (!checkItemsIntersection(state.grid.getItem(overlapId), state.grid.getItem(overlapIssuerId))) {\n      state.overlaps.delete(overlapId);\n    }\n  }\n}","map":{"version":3,"names":["Position","MoveSolutionState","findNextSolutions","checkItemsIntersection","sortGridItems","createMove","MAX_SOLUTION_DEPTH","NUM_BEST_SOLUTIONS","resolveOverlaps","layoutState","userMove","conflicts","findConflicts","grid","initialState","moves","initialSolution","solutionsCache","Map","createCacheKey","state","move","itemId","x","y","score","moveSolutions","bestSolution","convergenceCounter","length","nextSolutions","solutionIndex","Math","min","solutionState","solutionMove","makeMove","overlaps","size","nextSolution","solutionKey","cachedSolution","get","push","set","sort","s1","s2","resolveOverlapsDown","refloatGrid","map","overlapId","getItem","overlap","getOverlaps","makeRefloat","needAnotherRefloat","item","items","id","moveAttempt","previousConflicts","_a","type","direction","filter","width","height","Set","nextMove","updateGridWithMove","updateOverlaps","insert","remove","resize","newOverlap","has","overlapIssuerId","delete"],"sources":["/Users/tangyizhi/Desktop/Assignment 2/frontend/node_modules/@cloudscape-design/board-components/internal/layout-engine/engine-step.js"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { Position } from \"../utils/position\";\nimport { MoveSolutionState, findNextSolutions } from \"./engine-solution\";\nimport { checkItemsIntersection, sortGridItems } from \"./utils\";\nimport { createMove } from \"./utils\";\n// The solutions can't be searched for infinitely in case the algorithm can't converge.\n// The safety counter ensures there is going to be user feedback within reasonable time.\nconst MAX_SOLUTION_DEPTH = 100;\n// At any given step only a few best solutions are taken to ensure faster convergence.\n// The larger the number the better chance the most optimal solution is found for the given priorities\n// at a cost of more computations made.\nconst NUM_BEST_SOLUTIONS = 5;\n/**\n * The function takes the current layout state (item placements from the previous steps and all moves done so far)\n * and a user command increment that describes an item transition by one cell in some direction.\n * The function finds overlapping elements and resolves all overlaps if possible (always possible when no conflicts).\n * The result in an updated state (new item placements, additional moves, and item conflicts if any).\n */\nexport function resolveOverlaps(layoutState, userMove) {\n    // For better UX the layout engine is optimized for item swaps.\n    // The swapping is only preferred for the user-controlled item and it can only happen when the item overlaps another\n    // item past its midpoint. When the overlap is not enough, the underlying item is considered a conflict and it is not\n    // allowed to move anywhere. The user command cannot be committed at this step.\n    const conflicts = findConflicts(layoutState.grid, layoutState.conflicts, userMove);\n    // The user moves are always applied as is. When the user-controlled item overlaps with other items and there is\n    // no conflict, the type=\"OVERLAP\" moves are performed to settle the grid so that no items overlap with one another.\n    // For this type of move multiple solutions are often available. To ensure the best result all solutions are tried\n    // and a score is given to each. The solution with the minimal score wins.\n    // The process stars from the initial state and the user move. The initial score and the user move score are 0.\n    const initialState = new MoveSolutionState(layoutState.grid, layoutState.moves, conflicts);\n    const initialSolution = [initialState, userMove];\n    // All solutions are guaranteed to have unique move sequences but different move sequences can produce the same result.\n    // As it is never expected for one item to be moved over to the same location twice the combination of the item ID,\n    // item position, and solution score can uniquely represent the solution.\n    // For earlier moves taking a solution from the cache can prevent hundreds of subsequent computations.\n    const solutionsCache = new Map();\n    const createCacheKey = ([state, move]) => `${move.itemId} ${move.x}:${move.y}:${state.score + move.score}`;\n    let moveSolutions = [initialSolution];\n    let bestSolution = null;\n    let convergenceCounter = MAX_SOLUTION_DEPTH;\n    // The resolution process continues until there is at least one reasonable solution left.\n    // The repetitive, dead-end, and expensive (compared to the best so far) solutions are excluded\n    // so that eventually no more variants to try remain.\n    // The convergence safety counter ensures the logical errors to not cause an infinite loop.\n    while (moveSolutions.length > 0) {\n        let nextSolutions = [];\n        for (let solutionIndex = 0; solutionIndex < Math.min(NUM_BEST_SOLUTIONS, moveSolutions.length); solutionIndex++) {\n            const [solutionState, solutionMove] = moveSolutions[solutionIndex];\n            // Discard the solution before performing the move if its next score is already above the best score found so far.\n            if (bestSolution && solutionState.score + solutionMove.score >= bestSolution.score) {\n                continue;\n            }\n            // Perform the move by mutating the solution's state: grid, moves, score, etc.\n            makeMove(solutionState, solutionMove);\n            // If no overlaps are left the solution is considered valid and the best so far.\n            // The next solutions having the same or higher score will be discarded.\n            if (solutionState.overlaps.size === 0) {\n                bestSolution = solutionState;\n            }\n            // Otherwise, the next set of solutions will be considered. There can be up to four solutions per overlap\n            // (by the number of possible directions to move).\n            else {\n                for (const nextSolution of findNextSolutions(solutionState)) {\n                    const solutionKey = createCacheKey(nextSolution);\n                    const cachedSolution = solutionsCache.get(solutionKey);\n                    if (!cachedSolution) {\n                        nextSolutions.push(nextSolution);\n                        solutionsCache.set(solutionKey, nextSolution);\n                    }\n                }\n            }\n        }\n        // The solutions are ordered by the total score so that the best (so far) solutions are considered first.\n        moveSolutions = nextSolutions.sort((s1, s2) => s1[0].score + s1[1].score - (s2[0].score + s2[1].score));\n        nextSolutions = [];\n        // Reaching the convergence counter might indicate an issue with the algorithm as ideally it should converge faster.\n        // However, that does not necessarily mean the logical problem and no exception should be thrown.\n        // Instead, the current best solution if available applies or a simple solution is offered instead.\n        convergenceCounter--;\n        if (convergenceCounter <= 0) {\n            break;\n        }\n    }\n    // If there are conflicts it might not be possible to find a solution as the items are not allowed to\n    // overlap with the conflicts. In that case the initial state (with the user move applied) is returned.\n    // The user can move the item further to resolve the conflicts which will also unblock the overlaps resolution.\n    // Also, the solution might not be found due to the engine constraints. For example, the convergence number might\n    // be reached before any solution is found or the number of best solutions constraint can filter the only possible\n    // solutions away. In that case the simple solution is returned with all overlapping items pushed to the bottom.\n    if (!bestSolution) {\n        bestSolution = initialState.conflicts ? initialState : resolveOverlapsDown(initialState);\n    }\n    // After each step unless there are conflicts the type=\"FLOAT\" moves are performed on all items\n    // but the user controlled one that can be moved to the top without overlapping with other items.\n    return bestSolution.conflicts ? bestSolution : refloatGrid(bestSolution, userMove);\n}\n// Resolves overlaps the simple way by pushing all overlapping items to the bottom until none is left.\nfunction resolveOverlapsDown(state) {\n    // Move overlapping items to the bottom until resolved. Repeat until no overlaps left.\n    // This solution always converges because there is always free space at the bottom by design.\n    while (state.overlaps.size > 0) {\n        const overlaps = sortGridItems([...state.overlaps].map(([overlapId]) => state.grid.getItem(overlapId)));\n        for (const overlap of overlaps) {\n            let y = overlap.y + 1;\n            while (state.grid.getOverlaps({ ...overlap, y }).length > 0) {\n                y++;\n            }\n            makeMove(state, createMove(\"OVERLAP\", overlap, new Position({ x: overlap.x, y })));\n        }\n    }\n    return state;\n}\n// Find items that can \"float\" to the top and apply the necessary moves.\nfunction refloatGrid(layoutState, userMove) {\n    const state = new MoveSolutionState(layoutState.grid, layoutState.moves, layoutState.conflicts);\n    function makeRefloat() {\n        let needAnotherRefloat = false;\n        for (const item of state.grid.items) {\n            // The active item is skipped until the operation is committed.\n            if (item.id === (userMove === null || userMove === void 0 ? void 0 : userMove.itemId)) {\n                continue;\n            }\n            let y = item.y - 1;\n            let move = null;\n            while (y >= 0) {\n                const moveAttempt = createMove(\"FLOAT\", item, new Position({ x: item.x, y }));\n                if (state.grid.getOverlaps({ id: item.id, ...moveAttempt }).length > 0) {\n                    break;\n                }\n                y--;\n                move = moveAttempt;\n            }\n            if (move) {\n                makeMove(state, move);\n                needAnotherRefloat = true;\n            }\n        }\n        if (needAnotherRefloat) {\n            makeRefloat();\n        }\n    }\n    makeRefloat();\n    return state;\n}\n// Finds items that cannot be resolved at the current step as of being partially overlapped by the user-move item.\nfunction findConflicts(grid, previousConflicts, userMove) {\n    var _a;\n    // The conflicts are only defined for MOVE command type to make swaps possible.\n    if (userMove.type !== \"MOVE\") {\n        return null;\n    }\n    // Using existing conflict direction if available so that conflicting items would swap consistently.\n    // If only the current direction is considered the multi-item conflicts become difficult to comprehend.\n    const direction = (_a = previousConflicts === null || previousConflicts === void 0 ? void 0 : previousConflicts.direction) !== null && _a !== void 0 ? _a : userMove.direction;\n    // Conflicts are partial overlaps. When the item is overlapped fully (considering the direction) it is\n    // no longer treated as conflict.\n    const overlaps = grid.getOverlaps({ ...userMove, id: userMove.itemId });\n    const conflicts = overlaps.filter((overlap) => {\n        switch (direction) {\n            case \"left\":\n                return overlap.x < userMove.x;\n            case \"right\":\n                return overlap.x + overlap.width - 1 > userMove.x + userMove.width - 1;\n            case \"up\":\n                return overlap.y < userMove.y;\n            case \"down\":\n                return overlap.y + overlap.height - 1 > userMove.y + userMove.height - 1;\n        }\n    });\n    if (conflicts.length > 0) {\n        return { direction, items: new Set(conflicts.map((item) => item.id)) };\n    }\n    return null;\n}\n// Applies given move to the solution state by updating the grid, moves, overlaps, and score.\nfunction makeMove(state, nextMove) {\n    updateGridWithMove(state, nextMove);\n    updateOverlaps(state, nextMove);\n    state.moves.push(nextMove);\n    state.score += nextMove.score;\n}\nfunction updateGridWithMove({ grid }, move) {\n    switch (move.type) {\n        case \"MOVE\":\n        case \"OVERLAP\":\n        case \"FLOAT\":\n            return grid.move(move.itemId, move.x, move.y);\n        case \"INSERT\":\n            return grid.insert({ id: move.itemId, ...move });\n        case \"REMOVE\":\n            return grid.remove(move.itemId);\n        case \"RESIZE\":\n            return grid.resize(move.itemId, move.width, move.height);\n    }\n}\nfunction updateOverlaps(state, move) {\n    var _a;\n    // Find and assign items that will overlap with the moved item after the move is performed\n    // unless the overlapping items are considered as conflicts.\n    for (const newOverlap of state.grid.getOverlaps({ ...move, id: move.itemId })) {\n        if (!((_a = state.conflicts) === null || _a === void 0 ? void 0 : _a.items.has(newOverlap.id))) {\n            state.overlaps.set(newOverlap.id, move.itemId);\n        }\n    }\n    // Remove no longer valid overlaps after the move is performed.\n    for (const [overlapId, overlapIssuerId] of state.overlaps) {\n        if (!checkItemsIntersection(state.grid.getItem(overlapId), state.grid.getItem(overlapIssuerId))) {\n            state.overlaps.delete(overlapId);\n        }\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}