{"ast":null,"code":"import { Position } from \"../../internal/utils/position\";\n/**\n * The insertion operation is similar to reorder yet the first path entry is treated differently.\n * The normalization removes leading path entries if on the same edge to optimize UX.\n */\nexport function normalizeInsertionPath(path, insertionDirection, columns, rows) {\n  let edgeIndex = -1;\n  for (let i = 0; i < path.length; i++) {\n    switch (insertionDirection) {\n      case \"left\":\n        {\n          if (path[i].x === 0) {\n            edgeIndex = i;\n          }\n          break;\n        }\n      case \"right\":\n        {\n          if (path[i].x === columns - 1) {\n            edgeIndex = i;\n          }\n          break;\n        }\n      case \"up\":\n        {\n          if (path[i].y === 0) {\n            edgeIndex = i;\n          }\n          break;\n        }\n      case \"down\":\n        {\n          if (path[i].y === rows - 1) {\n            edgeIndex = i;\n          }\n          break;\n        }\n    }\n  }\n  return path.slice(edgeIndex);\n}\nexport function appendMovePath(prevPath, collisionRect) {\n  return appendPath(prevPath, new Position({\n    x: collisionRect.left,\n    y: collisionRect.top\n  }));\n}\nexport function appendResizePath(prevPath, collisionRect) {\n  return appendPath(prevPath, new Position({\n    x: collisionRect.right,\n    y: collisionRect.bottom\n  }));\n}\n/**\n * The operation path must be strictly incremental (each dx + dy == 1). However, the actual collisions\n * data can have gaps due to pointer events throttling or other factors.\n *\n * The function produces next path from previous path and the target position by incrementally adding steps.\n */\nfunction appendPath(prevPath, nextPosition) {\n  const path = [...prevPath];\n  const lastPosition = prevPath[prevPath.length - 1];\n  if (!lastPosition) {\n    return [nextPosition];\n  }\n  const vx = Math.sign(nextPosition.x - lastPosition.x);\n  const vy = Math.sign(nextPosition.y - lastPosition.y);\n  let {\n    x,\n    y\n  } = lastPosition;\n  let safetyCounter = 0;\n  while (x !== nextPosition.x || y !== nextPosition.y) {\n    if (++safetyCounter === 100) {\n      throw new Error(\"Infinite loop in appendPath.\");\n    }\n    if (x !== nextPosition.x) {\n      x += vx;\n    } else {\n      y += vy;\n    }\n    path.push(new Position({\n      x,\n      y\n    }));\n  }\n  return path;\n}","map":{"version":3,"names":["Position","normalizeInsertionPath","path","insertionDirection","columns","rows","edgeIndex","i","length","x","y","slice","appendMovePath","prevPath","collisionRect","appendPath","left","top","appendResizePath","right","bottom","nextPosition","lastPosition","vx","Math","sign","vy","safetyCounter","Error","push"],"sources":["/Users/tangyizhi/Desktop/Assignment 2/frontend/node_modules/@cloudscape-design/board-components/board/utils/path.js"],"sourcesContent":["import { Position } from \"../../internal/utils/position\";\n/**\n * The insertion operation is similar to reorder yet the first path entry is treated differently.\n * The normalization removes leading path entries if on the same edge to optimize UX.\n */\nexport function normalizeInsertionPath(path, insertionDirection, columns, rows) {\n    let edgeIndex = -1;\n    for (let i = 0; i < path.length; i++) {\n        switch (insertionDirection) {\n            case \"left\": {\n                if (path[i].x === 0) {\n                    edgeIndex = i;\n                }\n                break;\n            }\n            case \"right\": {\n                if (path[i].x === columns - 1) {\n                    edgeIndex = i;\n                }\n                break;\n            }\n            case \"up\": {\n                if (path[i].y === 0) {\n                    edgeIndex = i;\n                }\n                break;\n            }\n            case \"down\": {\n                if (path[i].y === rows - 1) {\n                    edgeIndex = i;\n                }\n                break;\n            }\n        }\n    }\n    return path.slice(edgeIndex);\n}\nexport function appendMovePath(prevPath, collisionRect) {\n    return appendPath(prevPath, new Position({ x: collisionRect.left, y: collisionRect.top }));\n}\nexport function appendResizePath(prevPath, collisionRect) {\n    return appendPath(prevPath, new Position({ x: collisionRect.right, y: collisionRect.bottom }));\n}\n/**\n * The operation path must be strictly incremental (each dx + dy == 1). However, the actual collisions\n * data can have gaps due to pointer events throttling or other factors.\n *\n * The function produces next path from previous path and the target position by incrementally adding steps.\n */\nfunction appendPath(prevPath, nextPosition) {\n    const path = [...prevPath];\n    const lastPosition = prevPath[prevPath.length - 1];\n    if (!lastPosition) {\n        return [nextPosition];\n    }\n    const vx = Math.sign(nextPosition.x - lastPosition.x);\n    const vy = Math.sign(nextPosition.y - lastPosition.y);\n    let { x, y } = lastPosition;\n    let safetyCounter = 0;\n    while (x !== nextPosition.x || y !== nextPosition.y) {\n        if (++safetyCounter === 100) {\n            throw new Error(\"Infinite loop in appendPath.\");\n        }\n        if (x !== nextPosition.x) {\n            x += vx;\n        }\n        else {\n            y += vy;\n        }\n        path.push(new Position({ x, y }));\n    }\n    return path;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}