{"ast":null,"code":"import _toConsumableArray from \"/Users/tangyizhi/Desktop/Assignment2/frontend/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _slicedToArray from \"/Users/tangyizhi/Desktop/Assignment2/frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { isDataSeries, isXThreshold, isYThreshold, matchesX } from './utils';\nexport function computeDomainX(series, xScaleType) {\n  if (xScaleType === 'categorical') {\n    return series.reduce(function (acc, s) {\n      if (isDataSeries(s.series)) {\n        s.series.data.forEach(function (_ref) {\n          var x = _ref.x;\n          if (acc.indexOf(x) === -1) {\n            acc.push(x);\n          }\n        });\n      }\n      if (isXThreshold(s.series)) {\n        if (acc.indexOf(s.series.x) === -1) {\n          acc.push(s.series.x);\n        }\n      }\n      return acc;\n    }, []);\n  }\n  return series.reduce(function (acc, curr) {\n    // Y-thresholds don't have X value.\n    if (isYThreshold(curr.series)) {\n      return acc;\n    }\n    // Compare x-threshold X with current min, max.\n    if (isXThreshold(curr.series)) {\n      var _acc = _slicedToArray(acc, 2),\n        min = _acc[0],\n        max = _acc[1];\n      var newMin = min === undefined || min === null || curr.series.x < min ? curr.series.x : min;\n      var newMax = max === undefined || max === null || max < curr.series.x ? curr.series.x : max;\n      return [newMin, newMax];\n    }\n    // Compare all series X values with current min, max.\n    if (isDataSeries(curr.series)) {\n      return curr.series.data.reduce(function (_ref2, _ref3) {\n        var _ref4 = _slicedToArray(_ref2, 2),\n          min = _ref4[0],\n          max = _ref4[1];\n        var x = _ref3.x;\n        var newMin = min === undefined || min === null || x < min ? x : min;\n        var newMax = max === undefined || max === null || max < x ? x : max;\n        return [newMin, newMax];\n      }, acc);\n    }\n    return acc;\n  }, []);\n}\nfunction find(arr, func) {\n  for (var i = 0; i < arr.length; i++) {\n    var found = func(arr[i]);\n    if (found) {\n      return arr[i];\n    }\n  }\n  return null;\n}\nexport function computeDomainY(series, scaleType, stackedBars) {\n  var _series = series;\n  // For stacked bars, we need to accumulate all the bar series into a positive and a negative series\n  if (stackedBars) {\n    var _series$reduce = series.reduce(function (acc, curr) {\n        if (curr.series.type === 'bar') {\n          curr.series.data.forEach(function (_ref5) {\n            var x = _ref5.x,\n              y = _ref5.y;\n            var data = y < 0 ? acc.negativeData : acc.positiveData;\n            var stackedDatum = find(data, function (el) {\n              return matchesX(el.x, x);\n            });\n            if (stackedDatum) {\n              stackedDatum.y += y;\n            } else {\n              data.push({\n                x: x,\n                y: y\n              });\n            }\n            return acc;\n          });\n        }\n        return acc;\n      }, {\n        positiveData: [],\n        negativeData: []\n      }),\n      positiveData = _series$reduce.positiveData,\n      negativeData = _series$reduce.negativeData;\n    // Artificial series with the sum of all bars when stacked\n    var stackedSeries = [{\n      color: '',\n      index: NaN,\n      series: {\n        type: 'bar',\n        title: 'positive',\n        data: positiveData\n      }\n    }, {\n      color: '',\n      index: NaN,\n      series: {\n        type: 'bar',\n        title: 'negative',\n        data: negativeData\n      }\n    }];\n    // MixedLineBarChart can also contain other non-bar series,\n    // so we replace all bars with the artificial bar series\n    // Then proceed to compute range with it and the remaining (non-bar) series\n    _series = [].concat(stackedSeries, _toConsumableArray(_series.filter(function (s) {\n      return s.series.type !== 'bar';\n    })));\n  }\n  var domain = _series.reduce(function (acc, curr) {\n    // Compare threshold Y value with current min, max.\n    if (isYThreshold(curr.series)) {\n      var _acc2 = _slicedToArray(acc, 2),\n        min = _acc2[0],\n        max = _acc2[1];\n      var newMin = min === undefined || curr.series.y < min ? curr.series.y : min;\n      var newMax = max === undefined || max < curr.series.y ? curr.series.y : max;\n      return [newMin, newMax];\n    }\n    // X-thresholds don't have Y value.\n    if (isXThreshold(curr.series)) {\n      return acc;\n    }\n    // Compare all series Y values with current min, max.\n    if (isDataSeries(curr.series)) {\n      return curr.series.data.reduce(function (_ref6, _ref7) {\n        var _ref8 = _slicedToArray(_ref6, 2),\n          min = _ref8[0],\n          max = _ref8[1];\n        var y = _ref7.y;\n        var newMin = min === undefined || y < min ? y : min;\n        var newMax = max === undefined || max < y ? y : max;\n        return [newMin, newMax];\n      }, acc);\n    }\n    return acc;\n  }, [0, 0]);\n  // Log scales can't start from 0, so if possible, start from 1.\n  if (scaleType === 'log' && domain[0] === 0 && domain[1] > 1) {\n    return [1, domain[1]];\n  }\n  return domain;\n}","map":{"version":3,"mappings":"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","names":["isDataSeries","isXThreshold","isYThreshold","matchesX","computeDomainX","series","xScaleType","reduce","acc","s","data","forEach","x","indexOf","push","curr","min","max","newMin","undefined","newMax","find","arr","func","i","length","found","computeDomainY","scaleType","stackedBars","_series","type","y","negativeData","positiveData","stackedDatum","el","stackedSeries","color","index","NaN","title","filter","domain"],"sources":["/Users/tangyizhi/Desktop/Assignment2/frontend/node_modules/@cloudscape-design/components/mixed-line-bar-chart/lib/default/mixed-line-bar-chart/domain.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { InternalChartSeries, MixedLineBarChartProps, ScaleType } from './interfaces';\nimport { isDataSeries, isXThreshold, isYThreshold, matchesX } from './utils';\n\nexport function computeDomainX<T>(series: readonly InternalChartSeries<T>[], xScaleType: ScaleType) {\n  if (xScaleType === 'categorical') {\n    return series.reduce((acc, s) => {\n      if (isDataSeries(s.series)) {\n        s.series.data.forEach(({ x }) => {\n          if (acc.indexOf(x) === -1) {\n            acc.push(x);\n          }\n        });\n      }\n      if (isXThreshold(s.series)) {\n        if (acc.indexOf(s.series.x) === -1) {\n          acc.push(s.series.x);\n        }\n      }\n      return acc;\n    }, [] as T[]);\n  }\n\n  return series.reduce((acc, curr) => {\n    // Y-thresholds don't have X value.\n    if (isYThreshold(curr.series)) {\n      return acc;\n    }\n\n    // Compare x-threshold X with current min, max.\n    if (isXThreshold(curr.series)) {\n      const [min, max] = acc;\n      const newMin = min === undefined || min === null || curr.series.x < min ? curr.series.x : min;\n      const newMax = max === undefined || max === null || max < curr.series.x ? curr.series.x : max;\n      return [newMin, newMax] as T[];\n    }\n\n    // Compare all series X values with current min, max.\n    if (isDataSeries(curr.series)) {\n      return curr.series.data.reduce(([min, max], { x }) => {\n        const newMin = min === undefined || min === null || x < min ? x : min;\n        const newMax = max === undefined || max === null || max < x ? x : max;\n        return [newMin, newMax] as T[];\n      }, acc);\n    }\n\n    return acc;\n  }, [] as T[]);\n}\n\nfunction find<Q>(arr: readonly Q[], func: (el: Q) => boolean) {\n  for (let i = 0; i < arr.length; i++) {\n    const found = func(arr[i]);\n    if (found) {\n      return arr[i];\n    }\n  }\n  return null;\n}\n\nexport function computeDomainY<T>(\n  series: readonly InternalChartSeries<T>[],\n  scaleType: 'linear' | 'log',\n  stackedBars: boolean\n) {\n  let _series = series;\n\n  // For stacked bars, we need to accumulate all the bar series into a positive and a negative series\n  if (stackedBars) {\n    const { positiveData, negativeData } = series.reduce(\n      (acc, curr) => {\n        if (curr.series.type === 'bar') {\n          curr.series.data.forEach(({ x, y }) => {\n            const data = y < 0 ? acc.negativeData : acc.positiveData;\n            const stackedDatum = find(data, el => matchesX(el.x, x));\n            if (stackedDatum) {\n              stackedDatum.y += y;\n            } else {\n              data.push({ x, y });\n            }\n            return acc;\n          });\n        }\n        return acc;\n      },\n      {\n        positiveData: [] as MixedLineBarChartProps.Datum<T>[],\n        negativeData: [] as MixedLineBarChartProps.Datum<T>[],\n      }\n    );\n\n    // Artificial series with the sum of all bars when stacked\n    const stackedSeries: InternalChartSeries<T>[] = [\n      {\n        color: '',\n        index: NaN,\n        series: {\n          type: 'bar',\n          title: 'positive',\n          data: positiveData as any,\n        },\n      },\n      {\n        color: '',\n        index: NaN,\n        series: {\n          type: 'bar',\n          title: 'negative',\n          data: negativeData as any,\n        },\n      },\n    ];\n\n    // MixedLineBarChart can also contain other non-bar series,\n    // so we replace all bars with the artificial bar series\n    // Then proceed to compute range with it and the remaining (non-bar) series\n    _series = [...stackedSeries, ..._series.filter(s => s.series.type !== 'bar')];\n  }\n\n  const domain = _series.reduce(\n    (acc, curr) => {\n      // Compare threshold Y value with current min, max.\n      if (isYThreshold(curr.series)) {\n        const [min, max] = acc;\n        const newMin = min === undefined || curr.series.y < min ? curr.series.y : min;\n        const newMax = max === undefined || max < curr.series.y ? curr.series.y : max;\n        return [newMin, newMax];\n      }\n\n      // X-thresholds don't have Y value.\n      if (isXThreshold(curr.series)) {\n        return acc;\n      }\n\n      // Compare all series Y values with current min, max.\n      if (isDataSeries(curr.series)) {\n        return curr.series.data.reduce(([min, max], { y }) => {\n          const newMin = min === undefined || y < min ? y : min;\n          const newMax = max === undefined || max < y ? y : max;\n          return [newMin, newMax];\n        }, acc);\n      }\n\n      return acc;\n    },\n    [0, 0]\n  );\n\n  // Log scales can't start from 0, so if possible, start from 1.\n  if (scaleType === 'log' && domain[0] === 0 && domain[1] > 1) {\n    return [1, domain[1]];\n  }\n  return domain;\n}\n"]},"metadata":{},"sourceType":"module"}