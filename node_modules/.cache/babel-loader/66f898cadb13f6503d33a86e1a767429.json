{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport clsx from 'clsx';\nimport React, { useEffect, useRef, useState } from 'react';\nimport styles from './styles.css.js';\nimport { KeyCode } from '../../internal/keycode';\nimport { DEFAULT_COLUMN_WIDTH } from '../use-column-widths';\nimport { useStableCallback } from '@cloudscape-design/component-toolkit/internal';\nimport { getHeaderWidth, getResizerElements } from './resizer-lookup';\nconst AUTO_GROW_START_TIME = 10;\nconst AUTO_GROW_INTERVAL = 10;\nconst AUTO_GROW_INCREMENT = 5;\nexport function Resizer(_ref) {\n  let {\n    onWidthUpdate,\n    onWidthUpdateCommit,\n    ariaLabelledby,\n    minWidth = DEFAULT_COLUMN_WIDTH,\n    tabIndex,\n    showFocusRing,\n    focusId\n  } = _ref;\n  onWidthUpdate = useStableCallback(onWidthUpdate);\n  onWidthUpdateCommit = useStableCallback(onWidthUpdateCommit);\n  const resizerRef = useRef(null);\n  const [isDragging, setIsDragging] = useState(false);\n  const autoGrowTimeout = useRef();\n  const [resizerHasFocus, setResizerHasFocus] = useState(false);\n  const [headerCellWidth, setHeaderCellWidth] = useState(0);\n  // Read header width after mounting for it to be available in the element's ARIA label before it gets focused.\n  useEffect(() => {\n    setHeaderCellWidth(getHeaderWidth(resizerRef.current));\n  }, []);\n  useEffect(() => {\n    const elements = getResizerElements(resizerRef.current);\n    if (!isDragging && !resizerHasFocus || !elements) {\n      return;\n    }\n    const {\n      left: leftEdge,\n      right: rightEdge\n    } = elements.scrollParent.getBoundingClientRect();\n    const updateTrackerPosition = newOffset => {\n      const {\n        left: scrollParentLeft\n      } = elements.table.getBoundingClientRect();\n      elements.tracker.style.top = elements.header.getBoundingClientRect().height + 'px';\n      // minus one pixel to offset the cell border\n      elements.tracker.style.left = newOffset - scrollParentLeft - 1 + 'px';\n    };\n    const updateColumnWidth = newWidth => {\n      const {\n        right,\n        width\n      } = elements.header.getBoundingClientRect();\n      const updatedWidth = newWidth < minWidth ? minWidth : newWidth;\n      updateTrackerPosition(right + updatedWidth - width);\n      if (newWidth >= minWidth) {\n        setHeaderCellWidth(newWidth);\n      }\n      // callbacks must be the last calls in the handler, because they may cause an extra update\n      onWidthUpdate(newWidth);\n    };\n    const resizeColumn = offset => {\n      if (offset > leftEdge) {\n        const cellLeft = elements.header.getBoundingClientRect().left;\n        const newWidth = offset - cellLeft;\n        // callbacks must be the last calls in the handler, because they may cause an extra update\n        updateColumnWidth(newWidth);\n      }\n    };\n    const onAutoGrow = () => {\n      const width = elements.header.getBoundingClientRect().width;\n      autoGrowTimeout.current = setTimeout(onAutoGrow, AUTO_GROW_INTERVAL);\n      // callbacks must be the last calls in the handler, because they may cause an extra update\n      updateColumnWidth(width + AUTO_GROW_INCREMENT);\n      elements.scrollParent.scrollLeft += AUTO_GROW_INCREMENT;\n    };\n    const onMouseMove = event => {\n      clearTimeout(autoGrowTimeout.current);\n      const offset = event.pageX;\n      if (offset > rightEdge) {\n        autoGrowTimeout.current = setTimeout(onAutoGrow, AUTO_GROW_START_TIME);\n      } else {\n        resizeColumn(offset);\n      }\n    };\n    const onMouseUp = event => {\n      resizeColumn(event.pageX);\n      setIsDragging(false);\n      onWidthUpdateCommit();\n      clearTimeout(autoGrowTimeout.current);\n    };\n    const onKeyDown = event => {\n      if (event.keyCode === KeyCode.left) {\n        event.preventDefault();\n        updateColumnWidth(elements.header.getBoundingClientRect().width - 10);\n        setTimeout(() => onWidthUpdateCommit(), 0);\n      }\n      if (event.keyCode === KeyCode.right) {\n        event.preventDefault();\n        updateColumnWidth(elements.header.getBoundingClientRect().width + 10);\n        setTimeout(() => onWidthUpdateCommit(), 0);\n      }\n    };\n    updateTrackerPosition(elements.header.getBoundingClientRect().right);\n    if (isDragging) {\n      document.body.classList.add(styles['resize-active']);\n      document.addEventListener('mousemove', onMouseMove);\n      document.addEventListener('mouseup', onMouseUp);\n    }\n    if (resizerHasFocus) {\n      document.body.classList.add(styles['resize-active']);\n      document.body.classList.add(styles['resize-active-with-focus']);\n      elements.header.addEventListener('keydown', onKeyDown);\n    }\n    return () => {\n      clearTimeout(autoGrowTimeout.current);\n      document.body.classList.remove(styles['resize-active']);\n      document.body.classList.remove(styles['resize-active-with-focus']);\n      document.removeEventListener('mousemove', onMouseMove);\n      document.removeEventListener('mouseup', onMouseUp);\n      elements.header.removeEventListener('keydown', onKeyDown);\n    };\n  }, [isDragging, resizerHasFocus, minWidth, onWidthUpdate, onWidthUpdateCommit]);\n  const headerCellWidthString = headerCellWidth.toFixed(0);\n  const resizerAriaProps = {\n    role: 'separator',\n    'aria-labelledby': ariaLabelledby,\n    'aria-orientation': 'vertical',\n    'aria-valuenow': headerCellWidth,\n    // aria-valuetext is needed because the VO announces \"collapsed\" when only aria-valuenow set without aria-valuemax\n    'aria-valuetext': headerCellWidthString,\n    'aria-valuemin': minWidth\n  };\n  return React.createElement(React.Fragment, null, React.createElement(\"span\", Object.assign({\n    ref: resizerRef,\n    className: clsx(styles.resizer, isDragging && styles['resizer-active'], (resizerHasFocus || showFocusRing) && styles['has-focus']),\n    onMouseDown: event => {\n      if (event.button !== 0) {\n        return;\n      }\n      event.preventDefault();\n      setIsDragging(true);\n    },\n    onClick: () => {\n      // Prevents dragging mode activation for VO+Space click.\n      setIsDragging(false);\n    },\n    onFocus: () => {\n      setHeaderCellWidth(getHeaderWidth(resizerRef.current));\n      setResizerHasFocus(true);\n    },\n    onBlur: () => {\n      setResizerHasFocus(false);\n    }\n  }, resizerAriaProps, {\n    tabIndex: tabIndex,\n    \"data-focus-id\": focusId\n  })));\n}\nexport function ResizeTracker() {\n  return React.createElement(\"span\", {\n    className: styles.tracker\n  });\n}","map":{"version":3,"mappings":"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","names":["clsx","React","useEffect","useRef","useState","styles","KeyCode","DEFAULT_COLUMN_WIDTH","useStableCallback","getHeaderWidth","getResizerElements","AUTO_GROW_START_TIME","AUTO_GROW_INTERVAL","AUTO_GROW_INCREMENT","Resizer","onWidthUpdate","onWidthUpdateCommit","ariaLabelledby","minWidth","tabIndex","showFocusRing","focusId","resizerRef","isDragging","setIsDragging","autoGrowTimeout","resizerHasFocus","setResizerHasFocus","headerCellWidth","setHeaderCellWidth","current","elements","left","leftEdge","right","rightEdge","scrollParent","getBoundingClientRect","updateTrackerPosition","newOffset","scrollParentLeft","table","tracker","style","top","header","height","updateColumnWidth","newWidth","width","updatedWidth","resizeColumn","offset","cellLeft","onAutoGrow","setTimeout","scrollLeft","onMouseMove","event","clearTimeout","pageX","onMouseUp","onKeyDown","keyCode","preventDefault","document","body","classList","add","addEventListener","remove","removeEventListener","headerCellWidthString","toFixed","resizerAriaProps","role","ref","className","resizer","onMouseDown","button","onClick","onFocus","onBlur","ResizeTracker"],"sources":["/Users/tangyizhi/Desktop/Assignment2/frontend/node_modules/@cloudscape-design/components/table/resizer/lib/default/table/resizer/index.tsx"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport clsx from 'clsx';\nimport React, { useEffect, useRef, useState } from 'react';\nimport styles from './styles.css.js';\nimport { KeyCode } from '../../internal/keycode';\nimport { DEFAULT_COLUMN_WIDTH } from '../use-column-widths';\nimport { useStableCallback } from '@cloudscape-design/component-toolkit/internal';\nimport { getHeaderWidth, getResizerElements } from './resizer-lookup';\n\ninterface ResizerProps {\n  onWidthUpdate: (newWidth: number) => void;\n  onWidthUpdateCommit: () => void;\n  ariaLabelledby?: string;\n  minWidth?: number;\n  tabIndex?: number;\n  focusId?: string;\n  showFocusRing?: boolean;\n}\n\nconst AUTO_GROW_START_TIME = 10;\nconst AUTO_GROW_INTERVAL = 10;\nconst AUTO_GROW_INCREMENT = 5;\n\nexport function Resizer({\n  onWidthUpdate,\n  onWidthUpdateCommit,\n  ariaLabelledby,\n  minWidth = DEFAULT_COLUMN_WIDTH,\n  tabIndex,\n  showFocusRing,\n  focusId,\n}: ResizerProps) {\n  onWidthUpdate = useStableCallback(onWidthUpdate);\n  onWidthUpdateCommit = useStableCallback(onWidthUpdateCommit);\n\n  const resizerRef = useRef<HTMLSpanElement>(null);\n  const [isDragging, setIsDragging] = useState(false);\n  const autoGrowTimeout = useRef<ReturnType<typeof setTimeout> | undefined>();\n  const [resizerHasFocus, setResizerHasFocus] = useState(false);\n  const [headerCellWidth, setHeaderCellWidth] = useState(0);\n\n  // Read header width after mounting for it to be available in the element's ARIA label before it gets focused.\n  useEffect(() => {\n    setHeaderCellWidth(getHeaderWidth(resizerRef.current));\n  }, []);\n\n  useEffect(() => {\n    const elements = getResizerElements(resizerRef.current);\n    if ((!isDragging && !resizerHasFocus) || !elements) {\n      return;\n    }\n\n    const { left: leftEdge, right: rightEdge } = elements.scrollParent.getBoundingClientRect();\n\n    const updateTrackerPosition = (newOffset: number) => {\n      const { left: scrollParentLeft } = elements.table.getBoundingClientRect();\n      elements.tracker.style.top = elements.header.getBoundingClientRect().height + 'px';\n      // minus one pixel to offset the cell border\n      elements.tracker.style.left = newOffset - scrollParentLeft - 1 + 'px';\n    };\n\n    const updateColumnWidth = (newWidth: number) => {\n      const { right, width } = elements.header.getBoundingClientRect();\n      const updatedWidth = newWidth < minWidth ? minWidth : newWidth;\n      updateTrackerPosition(right + updatedWidth - width);\n      if (newWidth >= minWidth) {\n        setHeaderCellWidth(newWidth);\n      }\n      // callbacks must be the last calls in the handler, because they may cause an extra update\n      onWidthUpdate(newWidth);\n    };\n\n    const resizeColumn = (offset: number) => {\n      if (offset > leftEdge) {\n        const cellLeft = elements.header.getBoundingClientRect().left;\n        const newWidth = offset - cellLeft;\n        // callbacks must be the last calls in the handler, because they may cause an extra update\n        updateColumnWidth(newWidth);\n      }\n    };\n\n    const onAutoGrow = () => {\n      const width = elements.header.getBoundingClientRect().width;\n      autoGrowTimeout.current = setTimeout(onAutoGrow, AUTO_GROW_INTERVAL);\n      // callbacks must be the last calls in the handler, because they may cause an extra update\n      updateColumnWidth(width + AUTO_GROW_INCREMENT);\n      elements.scrollParent.scrollLeft += AUTO_GROW_INCREMENT;\n    };\n\n    const onMouseMove = (event: MouseEvent) => {\n      clearTimeout(autoGrowTimeout.current);\n      const offset = event.pageX;\n      if (offset > rightEdge) {\n        autoGrowTimeout.current = setTimeout(onAutoGrow, AUTO_GROW_START_TIME);\n      } else {\n        resizeColumn(offset);\n      }\n    };\n\n    const onMouseUp = (event: MouseEvent) => {\n      resizeColumn(event.pageX);\n      setIsDragging(false);\n      onWidthUpdateCommit();\n      clearTimeout(autoGrowTimeout.current);\n    };\n\n    const onKeyDown = (event: KeyboardEvent) => {\n      if (event.keyCode === KeyCode.left) {\n        event.preventDefault();\n        updateColumnWidth(elements.header.getBoundingClientRect().width - 10);\n        setTimeout(() => onWidthUpdateCommit(), 0);\n      }\n      if (event.keyCode === KeyCode.right) {\n        event.preventDefault();\n        updateColumnWidth(elements.header.getBoundingClientRect().width + 10);\n        setTimeout(() => onWidthUpdateCommit(), 0);\n      }\n    };\n\n    updateTrackerPosition(elements.header.getBoundingClientRect().right);\n\n    if (isDragging) {\n      document.body.classList.add(styles['resize-active']);\n      document.addEventListener('mousemove', onMouseMove);\n      document.addEventListener('mouseup', onMouseUp);\n    }\n    if (resizerHasFocus) {\n      document.body.classList.add(styles['resize-active']);\n      document.body.classList.add(styles['resize-active-with-focus']);\n      elements.header.addEventListener('keydown', onKeyDown);\n    }\n\n    return () => {\n      clearTimeout(autoGrowTimeout.current);\n      document.body.classList.remove(styles['resize-active']);\n      document.body.classList.remove(styles['resize-active-with-focus']);\n      document.removeEventListener('mousemove', onMouseMove);\n      document.removeEventListener('mouseup', onMouseUp);\n      elements.header.removeEventListener('keydown', onKeyDown);\n    };\n  }, [isDragging, resizerHasFocus, minWidth, onWidthUpdate, onWidthUpdateCommit]);\n\n  const headerCellWidthString = headerCellWidth.toFixed(0);\n  const resizerAriaProps = {\n    role: 'separator',\n    'aria-labelledby': ariaLabelledby,\n    'aria-orientation': 'vertical' as const,\n    'aria-valuenow': headerCellWidth,\n    // aria-valuetext is needed because the VO announces \"collapsed\" when only aria-valuenow set without aria-valuemax\n    'aria-valuetext': headerCellWidthString,\n    'aria-valuemin': minWidth,\n  };\n\n  return (\n    <>\n      <span\n        ref={resizerRef}\n        className={clsx(\n          styles.resizer,\n          isDragging && styles['resizer-active'],\n          (resizerHasFocus || showFocusRing) && styles['has-focus']\n        )}\n        onMouseDown={event => {\n          if (event.button !== 0) {\n            return;\n          }\n          event.preventDefault();\n          setIsDragging(true);\n        }}\n        onClick={() => {\n          // Prevents dragging mode activation for VO+Space click.\n          setIsDragging(false);\n        }}\n        onFocus={() => {\n          setHeaderCellWidth(getHeaderWidth(resizerRef.current));\n          setResizerHasFocus(true);\n        }}\n        onBlur={() => {\n          setResizerHasFocus(false);\n        }}\n        {...resizerAriaProps}\n        tabIndex={tabIndex}\n        data-focus-id={focusId}\n      />\n    </>\n  );\n}\n\nexport function ResizeTracker() {\n  return <span className={styles.tracker} />;\n}\n"]},"metadata":{},"sourceType":"module"}