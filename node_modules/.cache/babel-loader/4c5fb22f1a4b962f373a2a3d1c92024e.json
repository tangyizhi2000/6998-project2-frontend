{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { useRef, useState } from 'react';\nimport { closestCenter, PointerSensor, useSensor, useSensors } from '@dnd-kit/core';\nimport { hasSortableData } from '@dnd-kit/sortable';\nimport { KeyboardSensor } from './keyboard-sensor';\nvar KeyboardCode;\n(function (KeyboardCode) {\n  KeyboardCode[\"Space\"] = \"Space\";\n  KeyboardCode[\"Down\"] = \"ArrowDown\";\n  KeyboardCode[\"Right\"] = \"ArrowRight\";\n  KeyboardCode[\"Left\"] = \"ArrowLeft\";\n  KeyboardCode[\"Up\"] = \"ArrowUp\";\n  KeyboardCode[\"Esc\"] = \"Escape\";\n  KeyboardCode[\"Enter\"] = \"Enter\";\n})(KeyboardCode || (KeyboardCode = {}));\n// A custom collision detection algorithm is used when using a keyboard to\n// work around an unexpected behavior when reordering items of variable height\n// with the keyboard.\n// Neither closestCenter nor closestCorners work really well for this case,\n// because the center (or corners) of a tall rectangle might be so low that it\n// is detected as being closest to the rectangle below of the one it should\n// actually swap with.\n// Instead of relying on coordinates, the expected results are achieved by\n// moving X positions up or down in the initially sorted array, depending on\n// the desired direction.\n// We let our collisionDetection and customCoordinateGetter use the same\n// getClosestId function which takes its value from the current component\n// state, to make sure they are always in sync.\nexport default function useDragAndDropReorder(_ref) {\n  let {\n    sortedOptions\n  } = _ref;\n  const isKeyboard = useRef(false);\n  const positionDelta = useRef(0);\n  const [activeItemId, setActiveItemId] = useState(null);\n  const setActiveItem = id => {\n    setActiveItemId(id);\n    if (!id) {\n      isKeyboard.current = false;\n      positionDelta.current = 0;\n    }\n  };\n  const handleKeyDown = event => {\n    if (isKeyboard.current && activeItemId) {\n      const currentTargetIndex = sortedOptions.findIndex(_ref2 => {\n        let {\n          id\n        } = _ref2;\n        return id === activeItemId;\n      }) + positionDelta.current;\n      if (event.key === 'ArrowDown' && currentTargetIndex < sortedOptions.length - 1) {\n        positionDelta.current += 1;\n      } else if (event.key === 'ArrowUp' && currentTargetIndex > 0) {\n        positionDelta.current -= 1;\n      }\n    }\n    if (activeItemId && isEscape(event.key)) {\n      // Prevent modal from closing when pressing Esc to cancel the dragging action\n      event.stopPropagation();\n    }\n  };\n  const getClosestId = active => {\n    if (positionDelta.current === 0) {\n      return active.id;\n    }\n    const currentIndex = sortedOptions.findIndex(_ref3 => {\n      let {\n        id\n      } = _ref3;\n      return id === active.id;\n    });\n    const newIndex = Math.max(0, Math.min(sortedOptions.length - 1, currentIndex + positionDelta.current));\n    return sortedOptions[newIndex].id;\n  };\n  const collisionDetection = _ref4 => {\n    let {\n      active,\n      collisionRect,\n      droppableContainers,\n      droppableRects,\n      pointerCoordinates\n    } = _ref4;\n    if (isKeyboard.current) {\n      // For keyboard interaction, determine the colliding container based on the movements made by the arrow keys,\n      // via getClosestId\n      const collidingContainer = getCollidingContainer({\n        activeId: active.id,\n        closestId: getClosestId(active),\n        droppableContainers\n      });\n      return collidingContainer ? [collidingContainer] : [];\n    } else {\n      // For mouse interaction, use the closest center algorithm\n      return closestCenter({\n        active,\n        collisionRect,\n        droppableRects,\n        droppableContainers,\n        pointerCoordinates\n      });\n    }\n  };\n  const coordinateGetter = (event, _ref5) => {\n    let {\n      context: {\n        active,\n        collisionRect,\n        droppableRects,\n        droppableContainers\n      }\n    } = _ref5;\n    if (event.code === KeyboardCode.Up || event.code === KeyboardCode.Down) {\n      event.preventDefault();\n      if (!active || !collisionRect) {\n        return;\n      }\n      const closestId = getClosestId(active);\n      if (closestId !== null) {\n        const activeDroppable = droppableContainers.get(active.id);\n        const newDroppable = droppableContainers.get(closestId);\n        const newRect = newDroppable ? droppableRects.get(newDroppable.id) : null;\n        const newNode = newDroppable === null || newDroppable === void 0 ? void 0 : newDroppable.node.current;\n        if (newNode && newRect && activeDroppable && newDroppable) {\n          const isAfterActive = isAfter(activeDroppable, newDroppable);\n          const offset = {\n            x: isAfterActive ? collisionRect.width - newRect.width : 0,\n            y: isAfterActive ? collisionRect.height - newRect.height : 0\n          };\n          const rectCoordinates = {\n            x: newRect.left,\n            y: newRect.top\n          };\n          return {\n            x: rectCoordinates.x - offset.x,\n            y: rectCoordinates.y - offset.y\n          };\n        }\n      }\n    }\n  };\n  const sensors = useSensors(useSensor(PointerSensor), useSensor(KeyboardSensor, {\n    coordinateGetter,\n    onActivation: () => {\n      isKeyboard.current = true;\n    }\n  }));\n  return {\n    activeItem: activeItemId,\n    collisionDetection,\n    coordinateGetter,\n    handleKeyDown,\n    sensors,\n    setActiveItem\n  };\n}\nfunction isAfter(a, b) {\n  return hasSortableData(a) && hasSortableData(b) && a.data.current.sortable.index < b.data.current.sortable.index;\n}\nfunction getCollidingContainer(_ref6) {\n  let {\n    activeId,\n    closestId,\n    droppableContainers\n  } = _ref6;\n  if (closestId === activeId) {\n    return;\n  }\n  const collidingContainer = droppableContainers.find(_ref7 => {\n    let {\n      id\n    } = _ref7;\n    return id === closestId;\n  });\n  if (collidingContainer) {\n    return {\n      id: collidingContainer.id,\n      data: {\n        droppableContainer: collidingContainer,\n        value: 0\n      }\n    };\n  }\n}\nconst isEscape = key => key === 'Escape' || key === 'Esc';","map":{"version":3,"mappings":"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","names":["useRef","useState","closestCenter","PointerSensor","useSensor","useSensors","hasSortableData","KeyboardSensor","KeyboardCode","useDragAndDropReorder","sortedOptions","isKeyboard","positionDelta","activeItemId","setActiveItemId","setActiveItem","id","current","handleKeyDown","event","currentTargetIndex","findIndex","key","length","isEscape","stopPropagation","getClosestId","active","currentIndex","newIndex","Math","max","min","collisionDetection","collisionRect","droppableContainers","droppableRects","pointerCoordinates","collidingContainer","getCollidingContainer","activeId","closestId","coordinateGetter","context","code","Up","Down","preventDefault","activeDroppable","get","newDroppable","newRect","newNode","node","isAfterActive","isAfter","offset","x","width","y","height","rectCoordinates","left","top","sensors","onActivation","activeItem","a","b","data","sortable","index","find","droppableContainer","value"],"sources":["/Users/tangyizhi/Desktop/Assignment2/frontend/node_modules/@cloudscape-design/components/collection-preferences/content-display/lib/default/collection-preferences/content-display/use-drag-and-drop-reorder.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport React, { useRef, useState } from 'react';\nimport {\n  Active,\n  closestCenter,\n  CollisionDetection,\n  DroppableContainer,\n  KeyboardCoordinateGetter,\n  PointerSensor,\n  UniqueIdentifier,\n  useSensor,\n  useSensors,\n} from '@dnd-kit/core';\nimport { CollectionPreferencesProps } from '../interfaces';\nimport { hasSortableData } from '@dnd-kit/sortable';\nimport { KeyboardSensor } from './keyboard-sensor';\n\nenum KeyboardCode {\n  Space = 'Space',\n  Down = 'ArrowDown',\n  Right = 'ArrowRight',\n  Left = 'ArrowLeft',\n  Up = 'ArrowUp',\n  Esc = 'Escape',\n  Enter = 'Enter',\n}\n\n// A custom collision detection algorithm is used when using a keyboard to\n// work around an unexpected behavior when reordering items of variable height\n// with the keyboard.\n\n// Neither closestCenter nor closestCorners work really well for this case,\n// because the center (or corners) of a tall rectangle might be so low that it\n// is detected as being closest to the rectangle below of the one it should\n// actually swap with.\n\n// Instead of relying on coordinates, the expected results are achieved by\n// moving X positions up or down in the initially sorted array, depending on\n// the desired direction.\n\n// We let our collisionDetection and customCoordinateGetter use the same\n// getClosestId function which takes its value from the current component\n// state, to make sure they are always in sync.\n\nexport default function useDragAndDropReorder({\n  sortedOptions,\n}: {\n  sortedOptions: ReadonlyArray<CollectionPreferencesProps.VisibleContentOption>;\n}) {\n  const isKeyboard = useRef(false);\n  const positionDelta = useRef(0);\n  const [activeItemId, setActiveItemId] = useState<UniqueIdentifier | null>(null);\n\n  const setActiveItem = (id: UniqueIdentifier | null) => {\n    setActiveItemId(id);\n    if (!id) {\n      isKeyboard.current = false;\n      positionDelta.current = 0;\n    }\n  };\n\n  const handleKeyDown = (event: React.KeyboardEvent) => {\n    if (isKeyboard.current && activeItemId) {\n      const currentTargetIndex = sortedOptions.findIndex(({ id }) => id === activeItemId) + positionDelta.current;\n      if (event.key === 'ArrowDown' && currentTargetIndex < sortedOptions.length - 1) {\n        positionDelta.current += 1;\n      } else if (event.key === 'ArrowUp' && currentTargetIndex > 0) {\n        positionDelta.current -= 1;\n      }\n    }\n    if (activeItemId && isEscape(event.key)) {\n      // Prevent modal from closing when pressing Esc to cancel the dragging action\n      event.stopPropagation();\n    }\n  };\n\n  const getClosestId = (active: Active) => {\n    if (positionDelta.current === 0) {\n      return active.id;\n    }\n    const currentIndex = sortedOptions.findIndex(({ id }) => id === active.id);\n    const newIndex = Math.max(0, Math.min(sortedOptions.length - 1, currentIndex + positionDelta.current));\n    return sortedOptions[newIndex].id;\n  };\n\n  const collisionDetection: CollisionDetection = ({\n    active,\n    collisionRect,\n    droppableContainers,\n    droppableRects,\n    pointerCoordinates,\n  }) => {\n    if (isKeyboard.current) {\n      // For keyboard interaction, determine the colliding container based on the movements made by the arrow keys,\n      // via getClosestId\n      const collidingContainer = getCollidingContainer({\n        activeId: active.id,\n        closestId: getClosestId(active),\n        droppableContainers,\n      });\n      return collidingContainer ? [collidingContainer] : [];\n    } else {\n      // For mouse interaction, use the closest center algorithm\n      return closestCenter({ active, collisionRect, droppableRects, droppableContainers, pointerCoordinates });\n    }\n  };\n\n  const coordinateGetter: KeyboardCoordinateGetter = (\n    event,\n    { context: { active, collisionRect, droppableRects, droppableContainers } }\n  ) => {\n    if (event.code === KeyboardCode.Up || event.code === KeyboardCode.Down) {\n      event.preventDefault();\n\n      if (!active || !collisionRect) {\n        return;\n      }\n\n      const closestId = getClosestId(active);\n\n      if (closestId !== null) {\n        const activeDroppable = droppableContainers.get(active.id);\n        const newDroppable = droppableContainers.get(closestId);\n        const newRect = newDroppable ? droppableRects.get(newDroppable.id) : null;\n        const newNode = newDroppable?.node.current;\n\n        if (newNode && newRect && activeDroppable && newDroppable) {\n          const isAfterActive = isAfter(activeDroppable, newDroppable);\n          const offset = {\n            x: isAfterActive ? collisionRect.width - newRect.width : 0,\n            y: isAfterActive ? collisionRect.height - newRect.height : 0,\n          };\n          const rectCoordinates = {\n            x: newRect.left,\n            y: newRect.top,\n          };\n\n          return {\n            x: rectCoordinates.x - offset.x,\n            y: rectCoordinates.y - offset.y,\n          };\n        }\n      }\n    }\n  };\n\n  const sensors = useSensors(\n    useSensor(PointerSensor),\n    useSensor(KeyboardSensor, {\n      coordinateGetter,\n      onActivation: () => {\n        isKeyboard.current = true;\n      },\n    })\n  );\n\n  return {\n    activeItem: activeItemId,\n    collisionDetection,\n    coordinateGetter,\n    handleKeyDown,\n    sensors,\n    setActiveItem,\n  };\n}\n\nfunction isAfter(a: DroppableContainer, b: DroppableContainer) {\n  return hasSortableData(a) && hasSortableData(b) && a.data.current.sortable.index < b.data.current.sortable.index;\n}\n\nfunction getCollidingContainer({\n  activeId,\n  closestId,\n  droppableContainers,\n}: {\n  activeId: UniqueIdentifier;\n  closestId: UniqueIdentifier;\n  droppableContainers: DroppableContainer[];\n}) {\n  if (closestId === activeId) {\n    return;\n  }\n  const collidingContainer = droppableContainers.find(({ id }) => id === closestId);\n  if (collidingContainer) {\n    return {\n      id: collidingContainer.id,\n      data: {\n        droppableContainer: collidingContainer,\n        value: 0,\n      },\n    };\n  }\n}\n\nconst isEscape = (key: string) => key === 'Escape' || key === 'Esc';\n"]},"metadata":{},"sourceType":"module"}