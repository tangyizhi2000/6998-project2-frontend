{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { getBreakpointValue } from '../../breakpoints';\nimport { getOverflowParents, getOverflowParentDimensions } from '../../utils/scrollable-containers';\nimport styles from './styles.css.js';\nconst AVAILABLE_SPACE_RESERVE_DEFAULT = 50;\nconst AVAILABLE_SPACE_RESERVE_MOBILE_VERTICAL = 19; // 50 - 31\nconst AVAILABLE_SPACE_RESERVE_MOBILE_HORIZONTAL = 20;\nconst getClosestParentDimensions = element => {\n  const parents = getOverflowParents(element).map(el => {\n    const {\n      height,\n      width,\n      top,\n      left\n    } = el.getBoundingClientRect();\n    return {\n      height,\n      width,\n      top,\n      left\n    };\n  });\n  return parents.shift();\n};\n// By default, most dropdowns should expand their content as necessary, but to a maximum of 465px (the XXS breakpoint).\n// This value was determined by UX but may be subject to change in the future, depending on the feedback.\nexport const defaultMaxDropdownWidth = getBreakpointValue('xxs');\nexport const getAvailableSpace = _ref => {\n  let {\n    trigger,\n    overflowParents,\n    stretchWidth = false,\n    stretchHeight = false,\n    isMobile\n  } = _ref;\n  const availableSpaceReserveVertical = stretchHeight ? 0 : isMobile ? AVAILABLE_SPACE_RESERVE_MOBILE_VERTICAL : AVAILABLE_SPACE_RESERVE_DEFAULT;\n  const availableSpaceReserveHorizontal = stretchWidth ? 0 : isMobile ? AVAILABLE_SPACE_RESERVE_MOBILE_HORIZONTAL : AVAILABLE_SPACE_RESERVE_DEFAULT;\n  const {\n    bottom: triggerBottom,\n    left: triggerLeft,\n    right: triggerRight\n  } = trigger.getBoundingClientRect();\n  return overflowParents.reduce((_ref2, overflowParent) => {\n    let {\n      above,\n      below,\n      left,\n      right\n    } = _ref2;\n    const offsetTop = triggerBottom - overflowParent.top;\n    const currentAbove = offsetTop - trigger.offsetHeight - availableSpaceReserveVertical;\n    const currentBelow = overflowParent.height - offsetTop - availableSpaceReserveVertical;\n    const currentLeft = triggerRight - overflowParent.left - availableSpaceReserveHorizontal;\n    const currentRight = overflowParent.left + overflowParent.width - triggerLeft - availableSpaceReserveHorizontal;\n    return {\n      above: Math.min(above, currentAbove),\n      below: Math.min(below, currentBelow),\n      left: Math.min(left, currentLeft),\n      right: Math.min(right, currentRight)\n    };\n  }, {\n    above: Number.MAX_VALUE,\n    below: Number.MAX_VALUE,\n    left: Number.MAX_VALUE,\n    right: Number.MAX_VALUE\n  });\n};\nexport const getInteriorAvailableSpace = _ref3 => {\n  let {\n    trigger,\n    overflowParents,\n    isMobile\n  } = _ref3;\n  const AVAILABLE_SPACE_RESERVE_VERTICAL = isMobile ? AVAILABLE_SPACE_RESERVE_MOBILE_VERTICAL : AVAILABLE_SPACE_RESERVE_DEFAULT;\n  const AVAILABLE_SPACE_RESERVE_HORIZONTAL = isMobile ? AVAILABLE_SPACE_RESERVE_MOBILE_HORIZONTAL : AVAILABLE_SPACE_RESERVE_DEFAULT;\n  const {\n    bottom: triggerBottom,\n    top: triggerTop,\n    left: triggerLeft,\n    right: triggerRight\n  } = trigger.getBoundingClientRect();\n  return overflowParents.reduce((_ref4, overflowParent) => {\n    let {\n      above,\n      below,\n      left,\n      right\n    } = _ref4;\n    const currentAbove = triggerBottom - overflowParent.top - AVAILABLE_SPACE_RESERVE_VERTICAL;\n    const currentBelow = overflowParent.height - triggerTop + overflowParent.top - AVAILABLE_SPACE_RESERVE_VERTICAL;\n    const currentLeft = triggerLeft - overflowParent.left - AVAILABLE_SPACE_RESERVE_HORIZONTAL;\n    const currentRight = overflowParent.left + overflowParent.width - triggerRight - AVAILABLE_SPACE_RESERVE_HORIZONTAL;\n    return {\n      above: Math.min(above, currentAbove),\n      below: Math.min(below, currentBelow),\n      left: Math.min(left, currentLeft),\n      right: Math.min(right, currentRight)\n    };\n  }, {\n    above: Number.MAX_VALUE,\n    below: Number.MAX_VALUE,\n    left: Number.MAX_VALUE,\n    right: Number.MAX_VALUE\n  });\n};\nexport const getWidths = _ref5 => {\n  let {\n    triggerElement,\n    dropdownElement,\n    desiredMinWidth,\n    stretchBeyondTriggerWidth = false\n  } = _ref5;\n  // Determine the width of the trigger\n  const triggerWidth = triggerElement.getBoundingClientRect().width;\n  // Minimum width is determined by either an explicit number (desiredMinWidth) or the trigger width\n  const minWidth = desiredMinWidth ? Math.min(triggerWidth, desiredMinWidth) : triggerWidth;\n  // If stretchBeyondTriggerWidth is true, the maximum width is the XS breakpoint (465px) or the trigger width (if bigger).\n  const maxWidth = stretchBeyondTriggerWidth ? Math.max(defaultMaxDropdownWidth, triggerWidth) : Number.MAX_VALUE;\n  // Determine the actual dropdown width, the size that it \"wants\" to be\n  const requiredWidth = dropdownElement.getBoundingClientRect().width;\n  // Try to achieve the required/desired width within the given parameters\n  const idealWidth = Math.min(Math.max(requiredWidth, minWidth), maxWidth);\n  return {\n    idealWidth,\n    minWidth,\n    triggerWidth\n  };\n};\nexport const hasEnoughSpaceToStretchBeyondTriggerWidth = _ref6 => {\n  let {\n    triggerElement,\n    dropdownElement,\n    desiredMinWidth,\n    expandToViewport,\n    stretchWidth,\n    stretchHeight,\n    isMobile\n  } = _ref6;\n  const overflowParents = getOverflowParentDimensions({\n    element: dropdownElement,\n    excludeClosestParent: false,\n    expandToViewport,\n    canExpandOutsideViewport: stretchHeight\n  });\n  const {\n    idealWidth\n  } = getWidths({\n    triggerElement: triggerElement,\n    dropdownElement,\n    desiredMinWidth,\n    stretchBeyondTriggerWidth: true\n  });\n  const availableSpace = getAvailableSpace({\n    trigger: triggerElement,\n    overflowParents,\n    stretchWidth,\n    stretchHeight,\n    isMobile\n  });\n  return idealWidth <= availableSpace.left || idealWidth <= availableSpace.right;\n};\nexport const getDropdownPosition = _ref7 => {\n  let {\n    triggerElement,\n    dropdownElement,\n    overflowParents,\n    minWidth: desiredMinWidth,\n    preferCenter = false,\n    stretchWidth = false,\n    stretchHeight = false,\n    isMobile = false,\n    stretchBeyondTriggerWidth = false\n  } = _ref7;\n  // Determine the space available around the dropdown that it can grow in\n  const availableSpace = getAvailableSpace({\n    trigger: triggerElement,\n    overflowParents,\n    stretchWidth,\n    stretchHeight,\n    isMobile\n  });\n  const {\n    idealWidth,\n    minWidth,\n    triggerWidth\n  } = getWidths({\n    triggerElement,\n    dropdownElement,\n    desiredMinWidth,\n    stretchBeyondTriggerWidth\n  });\n  let dropLeft;\n  let left = null;\n  let width = idealWidth;\n  //1. Can it be positioned with ideal width to the right?\n  if (idealWidth <= availableSpace.right) {\n    dropLeft = false;\n    //2. Can it be positioned with ideal width to the left?\n  } else if (idealWidth <= availableSpace.left) {\n    dropLeft = true;\n    //3. Fit into biggest available space either on left or right\n  } else {\n    dropLeft = availableSpace.left > availableSpace.right;\n    width = Math.max(availableSpace.left, availableSpace.right, minWidth);\n  }\n  if (preferCenter) {\n    const spillOver = (idealWidth - triggerWidth) / 2;\n    // availableSpace always includes the trigger width, but we want to exclude that\n    const availableOutsideLeft = availableSpace.left - triggerWidth;\n    const availableOutsideRight = availableSpace.right - triggerWidth;\n    const fitsInCenter = availableOutsideLeft >= spillOver && availableOutsideRight >= spillOver;\n    if (fitsInCenter) {\n      left = -spillOver;\n    }\n  }\n  const dropUp = availableSpace.below < dropdownElement.offsetHeight && availableSpace.above > availableSpace.below;\n  const availableHeight = dropUp ? availableSpace.above : availableSpace.below;\n  // Try and crop the bottom item when all options can't be displayed, affordance for \"there's more\"\n  const croppedHeight = stretchHeight ? availableHeight : Math.floor(availableHeight / 31) * 31 + 16;\n  return {\n    dropUp,\n    dropLeft,\n    left: left === null ? 'auto' : `${left}px`,\n    height: `${croppedHeight}px`,\n    width: `${width}px`\n  };\n};\nexport const getInteriorDropdownPosition = (trigger, dropdown, overflowParents, isMobile) => {\n  const availableSpace = getInteriorAvailableSpace({\n    trigger,\n    overflowParents,\n    isMobile\n  });\n  const {\n    bottom: triggerBottom,\n    top: triggerTop,\n    width: triggerWidth\n  } = trigger.getBoundingClientRect();\n  const {\n    top: parentDropdownTop,\n    height: parentDropdownHeight\n  } = getClosestParentDimensions(trigger);\n  let dropLeft;\n  let width = dropdown.getBoundingClientRect().width;\n  const top = triggerTop - parentDropdownTop;\n  if (width <= availableSpace.right) {\n    dropLeft = false;\n  } else if (width <= availableSpace.left) {\n    dropLeft = true;\n  } else {\n    dropLeft = availableSpace.left > availableSpace.right;\n    width = Math.max(availableSpace.left, availableSpace.right);\n  }\n  const left = dropLeft ? 0 - width : triggerWidth;\n  const dropUp = availableSpace.below < dropdown.offsetHeight && availableSpace.above > availableSpace.below;\n  const bottom = dropUp ? parentDropdownTop + parentDropdownHeight - triggerBottom : 0;\n  const availableHeight = dropUp ? availableSpace.above : availableSpace.below;\n  // Try and crop the bottom item when all options can't be displayed, affordance for \"there's more\"\n  const croppedHeight = Math.floor(availableHeight / 31) * 31 + 16;\n  return {\n    dropUp,\n    dropLeft,\n    height: `${croppedHeight}px`,\n    width: `${width}px`,\n    top: `${top}px`,\n    bottom: `${bottom}px`,\n    left: `${left}px`\n  };\n};\nexport const calculatePosition = (dropdownElement, triggerElement, verticalContainerElement, interior, expandToViewport, preferCenter, stretchWidth, stretchHeight, isMobile, minWidth, stretchBeyondTriggerWidth) => {\n  // cleaning previously assigned values,\n  // so that they are not reused in case of screen resize and similar events\n  verticalContainerElement.style.maxHeight = '';\n  dropdownElement.style.width = '';\n  dropdownElement.style.top = '';\n  dropdownElement.style.bottom = '';\n  dropdownElement.style.left = '';\n  dropdownElement.classList.remove(styles['dropdown-drop-left']);\n  dropdownElement.classList.remove(styles['dropdown-drop-right']);\n  dropdownElement.classList.remove(styles['dropdown-drop-up']);\n  const overflowParents = getOverflowParentDimensions({\n    element: dropdownElement,\n    excludeClosestParent: interior,\n    expandToViewport,\n    canExpandOutsideViewport: stretchHeight\n  });\n  const position = interior ? getInteriorDropdownPosition(triggerElement, dropdownElement, overflowParents, isMobile) : getDropdownPosition({\n    triggerElement,\n    dropdownElement,\n    overflowParents,\n    minWidth,\n    preferCenter,\n    stretchWidth,\n    stretchHeight,\n    isMobile,\n    stretchBeyondTriggerWidth\n  });\n  const triggerBox = triggerElement.getBoundingClientRect();\n  return [position, triggerBox];\n};","map":{"version":3,"mappings":"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","names":["getBreakpointValue","getOverflowParents","getOverflowParentDimensions","styles","AVAILABLE_SPACE_RESERVE_DEFAULT","AVAILABLE_SPACE_RESERVE_MOBILE_VERTICAL","AVAILABLE_SPACE_RESERVE_MOBILE_HORIZONTAL","getClosestParentDimensions","element","parents","map","el","height","width","top","left","getBoundingClientRect","shift","defaultMaxDropdownWidth","getAvailableSpace","trigger","overflowParents","stretchWidth","stretchHeight","isMobile","availableSpaceReserveVertical","availableSpaceReserveHorizontal","bottom","triggerBottom","triggerLeft","right","triggerRight","reduce","overflowParent","above","below","offsetTop","currentAbove","offsetHeight","currentBelow","currentLeft","currentRight","Math","min","Number","MAX_VALUE","getInteriorAvailableSpace","AVAILABLE_SPACE_RESERVE_VERTICAL","AVAILABLE_SPACE_RESERVE_HORIZONTAL","triggerTop","getWidths","triggerElement","dropdownElement","desiredMinWidth","stretchBeyondTriggerWidth","triggerWidth","minWidth","maxWidth","max","requiredWidth","idealWidth","hasEnoughSpaceToStretchBeyondTriggerWidth","expandToViewport","excludeClosestParent","canExpandOutsideViewport","availableSpace","getDropdownPosition","preferCenter","dropLeft","spillOver","availableOutsideLeft","availableOutsideRight","fitsInCenter","dropUp","availableHeight","croppedHeight","floor","getInteriorDropdownPosition","dropdown","parentDropdownTop","parentDropdownHeight","calculatePosition","verticalContainerElement","interior","style","maxHeight","classList","remove","position","triggerBox"],"sources":["/Users/tangyizhi/Desktop/Assignment2/frontend/node_modules/@cloudscape-design/components/internal/components/dropdown/lib/default/internal/components/dropdown/dropdown-fit-handler.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { getBreakpointValue } from '../../breakpoints';\nimport { Dimensions, getOverflowParents, getOverflowParentDimensions } from '../../utils/scrollable-containers';\nimport styles from './styles.css.js';\n\nconst AVAILABLE_SPACE_RESERVE_DEFAULT = 50;\nconst AVAILABLE_SPACE_RESERVE_MOBILE_VERTICAL = 19; // 50 - 31\nconst AVAILABLE_SPACE_RESERVE_MOBILE_HORIZONTAL = 20;\n\ninterface AvailableSpace {\n  above: number;\n  below: number;\n  left: number;\n  right: number;\n}\nexport interface DropdownPosition {\n  height: string;\n  width: string;\n  dropUp: boolean;\n  dropLeft: boolean;\n  left: string;\n}\nexport interface InteriorDropdownPosition extends DropdownPosition {\n  bottom: string;\n  top: string;\n}\n\nconst getClosestParentDimensions = (element: HTMLElement): any => {\n  const parents = getOverflowParents(element).map(el => {\n    const { height, width, top, left } = el.getBoundingClientRect();\n    return {\n      height,\n      width,\n      top,\n      left,\n    };\n  });\n\n  return parents.shift();\n};\n\n// By default, most dropdowns should expand their content as necessary, but to a maximum of 465px (the XXS breakpoint).\n// This value was determined by UX but may be subject to change in the future, depending on the feedback.\nexport const defaultMaxDropdownWidth = getBreakpointValue('xxs');\n\nexport const getAvailableSpace = ({\n  trigger,\n  overflowParents,\n  stretchWidth = false,\n  stretchHeight = false,\n  isMobile,\n}: {\n  trigger: HTMLElement;\n  overflowParents: ReadonlyArray<Dimensions>;\n  stretchWidth?: boolean;\n  stretchHeight?: boolean;\n  isMobile?: boolean;\n}): AvailableSpace => {\n  const availableSpaceReserveVertical = stretchHeight\n    ? 0\n    : isMobile\n    ? AVAILABLE_SPACE_RESERVE_MOBILE_VERTICAL\n    : AVAILABLE_SPACE_RESERVE_DEFAULT;\n  const availableSpaceReserveHorizontal = stretchWidth\n    ? 0\n    : isMobile\n    ? AVAILABLE_SPACE_RESERVE_MOBILE_HORIZONTAL\n    : AVAILABLE_SPACE_RESERVE_DEFAULT;\n  const { bottom: triggerBottom, left: triggerLeft, right: triggerRight } = trigger.getBoundingClientRect();\n\n  return overflowParents.reduce(\n    ({ above, below, left, right }, overflowParent) => {\n      const offsetTop = triggerBottom - overflowParent.top;\n      const currentAbove = offsetTop - trigger.offsetHeight - availableSpaceReserveVertical;\n      const currentBelow = overflowParent.height - offsetTop - availableSpaceReserveVertical;\n      const currentLeft = triggerRight - overflowParent.left - availableSpaceReserveHorizontal;\n      const currentRight = overflowParent.left + overflowParent.width - triggerLeft - availableSpaceReserveHorizontal;\n\n      return {\n        above: Math.min(above, currentAbove),\n        below: Math.min(below, currentBelow),\n        left: Math.min(left, currentLeft),\n        right: Math.min(right, currentRight),\n      };\n    },\n    { above: Number.MAX_VALUE, below: Number.MAX_VALUE, left: Number.MAX_VALUE, right: Number.MAX_VALUE }\n  );\n};\n\nexport const getInteriorAvailableSpace = ({\n  trigger,\n  overflowParents,\n  isMobile,\n}: {\n  trigger: HTMLElement;\n  overflowParents: ReadonlyArray<Dimensions>;\n  isMobile?: boolean;\n}): AvailableSpace => {\n  const AVAILABLE_SPACE_RESERVE_VERTICAL = isMobile\n    ? AVAILABLE_SPACE_RESERVE_MOBILE_VERTICAL\n    : AVAILABLE_SPACE_RESERVE_DEFAULT;\n  const AVAILABLE_SPACE_RESERVE_HORIZONTAL = isMobile\n    ? AVAILABLE_SPACE_RESERVE_MOBILE_HORIZONTAL\n    : AVAILABLE_SPACE_RESERVE_DEFAULT;\n  const {\n    bottom: triggerBottom,\n    top: triggerTop,\n    left: triggerLeft,\n    right: triggerRight,\n  } = trigger.getBoundingClientRect();\n\n  return overflowParents.reduce(\n    ({ above, below, left, right }, overflowParent) => {\n      const currentAbove = triggerBottom - overflowParent.top - AVAILABLE_SPACE_RESERVE_VERTICAL;\n      const currentBelow = overflowParent.height - triggerTop + overflowParent.top - AVAILABLE_SPACE_RESERVE_VERTICAL;\n      const currentLeft = triggerLeft - overflowParent.left - AVAILABLE_SPACE_RESERVE_HORIZONTAL;\n      const currentRight =\n        overflowParent.left + overflowParent.width - triggerRight - AVAILABLE_SPACE_RESERVE_HORIZONTAL;\n\n      return {\n        above: Math.min(above, currentAbove),\n        below: Math.min(below, currentBelow),\n        left: Math.min(left, currentLeft),\n        right: Math.min(right, currentRight),\n      };\n    },\n    { above: Number.MAX_VALUE, below: Number.MAX_VALUE, left: Number.MAX_VALUE, right: Number.MAX_VALUE }\n  );\n};\n\nexport const getWidths = ({\n  triggerElement,\n  dropdownElement,\n  desiredMinWidth,\n  stretchBeyondTriggerWidth = false,\n}: {\n  triggerElement: HTMLElement;\n  dropdownElement: HTMLElement;\n  desiredMinWidth?: number;\n  stretchBeyondTriggerWidth?: boolean;\n}) => {\n  // Determine the width of the trigger\n  const triggerWidth = triggerElement.getBoundingClientRect().width;\n  // Minimum width is determined by either an explicit number (desiredMinWidth) or the trigger width\n  const minWidth = desiredMinWidth ? Math.min(triggerWidth, desiredMinWidth) : triggerWidth;\n  // If stretchBeyondTriggerWidth is true, the maximum width is the XS breakpoint (465px) or the trigger width (if bigger).\n  const maxWidth = stretchBeyondTriggerWidth ? Math.max(defaultMaxDropdownWidth, triggerWidth) : Number.MAX_VALUE;\n  // Determine the actual dropdown width, the size that it \"wants\" to be\n  const requiredWidth = dropdownElement.getBoundingClientRect().width;\n  // Try to achieve the required/desired width within the given parameters\n  const idealWidth = Math.min(Math.max(requiredWidth, minWidth), maxWidth);\n  return { idealWidth, minWidth, triggerWidth };\n};\n\nexport const hasEnoughSpaceToStretchBeyondTriggerWidth = ({\n  triggerElement,\n  dropdownElement,\n  desiredMinWidth,\n  expandToViewport,\n  stretchWidth,\n  stretchHeight,\n  isMobile,\n}: {\n  triggerElement: HTMLElement;\n  dropdownElement: HTMLElement;\n  desiredMinWidth?: number;\n  expandToViewport: boolean;\n  stretchWidth: boolean;\n  stretchHeight: boolean;\n  isMobile: boolean;\n}) => {\n  const overflowParents = getOverflowParentDimensions({\n    element: dropdownElement,\n    excludeClosestParent: false,\n    expandToViewport,\n    canExpandOutsideViewport: stretchHeight,\n  });\n  const { idealWidth } = getWidths({\n    triggerElement: triggerElement,\n    dropdownElement,\n    desiredMinWidth,\n    stretchBeyondTriggerWidth: true,\n  });\n  const availableSpace = getAvailableSpace({\n    trigger: triggerElement,\n    overflowParents,\n    stretchWidth,\n    stretchHeight,\n    isMobile,\n  });\n  return idealWidth <= availableSpace.left || idealWidth <= availableSpace.right;\n};\n\nexport const getDropdownPosition = ({\n  triggerElement,\n  dropdownElement,\n  overflowParents,\n  minWidth: desiredMinWidth,\n  preferCenter = false,\n  stretchWidth = false,\n  stretchHeight = false,\n  isMobile = false,\n  stretchBeyondTriggerWidth = false,\n}: {\n  triggerElement: HTMLElement;\n  dropdownElement: HTMLElement;\n  overflowParents: ReadonlyArray<Dimensions>;\n  minWidth?: number;\n  preferCenter?: boolean;\n  stretchWidth?: boolean;\n  stretchHeight?: boolean;\n  isMobile?: boolean;\n  stretchBeyondTriggerWidth?: boolean;\n}): DropdownPosition => {\n  // Determine the space available around the dropdown that it can grow in\n  const availableSpace = getAvailableSpace({\n    trigger: triggerElement,\n    overflowParents,\n    stretchWidth,\n    stretchHeight,\n    isMobile,\n  });\n  const { idealWidth, minWidth, triggerWidth } = getWidths({\n    triggerElement,\n    dropdownElement,\n    desiredMinWidth,\n    stretchBeyondTriggerWidth,\n  });\n\n  let dropLeft: boolean;\n  let left: number | null = null;\n  let width = idealWidth;\n\n  //1. Can it be positioned with ideal width to the right?\n  if (idealWidth <= availableSpace.right) {\n    dropLeft = false;\n    //2. Can it be positioned with ideal width to the left?\n  } else if (idealWidth <= availableSpace.left) {\n    dropLeft = true;\n    //3. Fit into biggest available space either on left or right\n  } else {\n    dropLeft = availableSpace.left > availableSpace.right;\n    width = Math.max(availableSpace.left, availableSpace.right, minWidth);\n  }\n\n  if (preferCenter) {\n    const spillOver = (idealWidth - triggerWidth) / 2;\n\n    // availableSpace always includes the trigger width, but we want to exclude that\n    const availableOutsideLeft = availableSpace.left - triggerWidth;\n    const availableOutsideRight = availableSpace.right - triggerWidth;\n\n    const fitsInCenter = availableOutsideLeft >= spillOver && availableOutsideRight >= spillOver;\n    if (fitsInCenter) {\n      left = -spillOver;\n    }\n  }\n\n  const dropUp = availableSpace.below < dropdownElement.offsetHeight && availableSpace.above > availableSpace.below;\n  const availableHeight = dropUp ? availableSpace.above : availableSpace.below;\n  // Try and crop the bottom item when all options can't be displayed, affordance for \"there's more\"\n  const croppedHeight = stretchHeight ? availableHeight : Math.floor(availableHeight / 31) * 31 + 16;\n\n  return {\n    dropUp,\n    dropLeft,\n    left: left === null ? 'auto' : `${left}px`,\n    height: `${croppedHeight}px`,\n    width: `${width}px`,\n  };\n};\n\nexport const getInteriorDropdownPosition = (\n  trigger: HTMLElement,\n  dropdown: HTMLElement,\n  overflowParents: ReadonlyArray<Dimensions>,\n  isMobile?: boolean\n): InteriorDropdownPosition => {\n  const availableSpace = getInteriorAvailableSpace({ trigger, overflowParents, isMobile });\n  const { bottom: triggerBottom, top: triggerTop, width: triggerWidth } = trigger.getBoundingClientRect();\n  const { top: parentDropdownTop, height: parentDropdownHeight } = getClosestParentDimensions(trigger);\n\n  let dropLeft;\n\n  let width = dropdown.getBoundingClientRect().width;\n  const top = triggerTop - parentDropdownTop;\n  if (width <= availableSpace.right) {\n    dropLeft = false;\n  } else if (width <= availableSpace.left) {\n    dropLeft = true;\n  } else {\n    dropLeft = availableSpace.left > availableSpace.right;\n    width = Math.max(availableSpace.left, availableSpace.right);\n  }\n\n  const left = dropLeft ? 0 - width : triggerWidth;\n\n  const dropUp = availableSpace.below < dropdown.offsetHeight && availableSpace.above > availableSpace.below;\n  const bottom = dropUp ? parentDropdownTop + parentDropdownHeight - triggerBottom : 0;\n  const availableHeight = dropUp ? availableSpace.above : availableSpace.below;\n  // Try and crop the bottom item when all options can't be displayed, affordance for \"there's more\"\n  const croppedHeight = Math.floor(availableHeight / 31) * 31 + 16;\n\n  return {\n    dropUp,\n    dropLeft,\n    height: `${croppedHeight}px`,\n    width: `${width}px`,\n    top: `${top}px`,\n    bottom: `${bottom}px`,\n    left: `${left}px`,\n  };\n};\n\nexport const calculatePosition = (\n  dropdownElement: HTMLDivElement,\n  triggerElement: HTMLDivElement,\n  verticalContainerElement: HTMLDivElement,\n  interior: boolean,\n  expandToViewport: boolean,\n  preferCenter: boolean,\n  stretchWidth: boolean,\n  stretchHeight: boolean,\n  isMobile: boolean,\n  minWidth?: number,\n  stretchBeyondTriggerWidth?: boolean\n): [DropdownPosition, DOMRect] => {\n  // cleaning previously assigned values,\n  // so that they are not reused in case of screen resize and similar events\n  verticalContainerElement.style.maxHeight = '';\n  dropdownElement.style.width = '';\n  dropdownElement.style.top = '';\n  dropdownElement.style.bottom = '';\n  dropdownElement.style.left = '';\n\n  dropdownElement.classList.remove(styles['dropdown-drop-left']);\n  dropdownElement.classList.remove(styles['dropdown-drop-right']);\n  dropdownElement.classList.remove(styles['dropdown-drop-up']);\n\n  const overflowParents = getOverflowParentDimensions({\n    element: dropdownElement,\n    excludeClosestParent: interior,\n    expandToViewport,\n    canExpandOutsideViewport: stretchHeight,\n  });\n  const position = interior\n    ? getInteriorDropdownPosition(triggerElement, dropdownElement, overflowParents, isMobile)\n    : getDropdownPosition({\n        triggerElement,\n        dropdownElement,\n        overflowParents,\n        minWidth,\n        preferCenter,\n        stretchWidth,\n        stretchHeight,\n        isMobile,\n        stretchBeyondTriggerWidth,\n      });\n  const triggerBox = triggerElement.getBoundingClientRect();\n  return [position, triggerBox];\n};\n"]},"metadata":{},"sourceType":"module"}