{"ast":null,"code":"import { warnOnce } from '@cloudscape-design/component-toolkit/internal';\nimport { formatTimezoneOffset, parseTimezoneOffset, shiftTimezoneOffset } from '../internal/utils/date-time';\nimport { addMinutes } from 'date-fns';\n/**\n * Appends a time zone offset to an offset-less date string.\n */\nexport function setTimeOffset(value, timeOffset) {\n  if (!((value === null || value === void 0 ? void 0 : value.type) === 'absolute')) {\n    return value;\n  }\n  return {\n    type: 'absolute',\n    startDate: value.startDate + formatTimezoneOffset(value.startDate, timeOffset.startDate),\n    endDate: value.endDate + formatTimezoneOffset(value.endDate, timeOffset.endDate)\n  };\n}\n/**\n * Re-formats an absolute date range so that it is expressed using the\n * target time offset. The returned value still represents the same range\n * in time, but contains no visible offset.\n */\nexport function shiftTimeOffset(value, timeOffset) {\n  if (!value || value.type !== 'absolute') {\n    return value;\n  }\n  /*\n    This regex matches an ISO date-time with\n    - optional seconds;\n    - optional milliseconds;\n    - optional time offset or 'Z'.\n  */\n  var dateTimeRegex = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}(:\\d{2})?(\\.\\d{1,3})?(((\\+|-)\\d{2}(:\\d{2})?)|Z)?$/;\n  if (!dateTimeRegex.test(value.startDate) || !dateTimeRegex.test(value.endDate)) {\n    warnOnce('DateRangePicker', 'You have provided a misformatted start or end date. The component will fall back to an empty value. ' + 'Dates have to be ISO8601-formatted with an optional time zone offset.');\n    return null;\n  }\n  return {\n    type: 'absolute',\n    startDate: shiftTimezoneOffset(value.startDate, timeOffset.startDate),\n    endDate: shiftTimezoneOffset(value.endDate, timeOffset.endDate)\n  };\n}\nexport function normalizeTimeOffset(value, getTimeOffset, timeOffset) {\n  if (value && value.type === 'absolute') {\n    if (getTimeOffset) {\n      return {\n        startDate: getTimeOffset(parseDateUTC(value.startDate)),\n        endDate: getTimeOffset(parseDateUTC(value.endDate))\n      };\n    } else if (timeOffset !== undefined) {\n      return {\n        startDate: timeOffset,\n        endDate: timeOffset\n      };\n    }\n  }\n  return {\n    startDate: undefined,\n    endDate: undefined\n  };\n}\n/*\n  Before the getTimeOffset function is used there is no information on the preferred time offset.\n  \n  Besides, the ISO date string might or might not contain the offset:\n  - 2021-02-03T01:02:03\n  - 2021-02-03T01:02:03Z\n  - 2021-02-03T01:02:03+01:00\n  \n  For every value above the date is converted to UTC and the following is true:\n  date.getUTCFullYear() === 2021\n  date.getUTCMonth() === 1\n  date.getUTCDate() === 3\n  date.getUTCHours() === 1\n  date.getUTCMinutes() === 2\n  date.getUTCSeconds() === 3\n*/\nfunction parseDateUTC(isoDateString) {\n  var date = new Date(isoDateString);\n  return addMinutes(date, parseTimezoneOffset(isoDateString));\n}","map":{"version":3,"mappings":"AAGA,SAASA,QAAQ,QAAQ,+CAA+C;AACxE,SAASC,oBAAoB,EAAEC,mBAAmB,EAAEC,mBAAmB,QAAQ,6BAA6B;AAC5G,SAASC,UAAU,QAAQ,UAAU;AAErC;;;AAGA,OAAM,SAAUC,aAAa,CAC3BC,KAAwC,EACxCC,UAAoD;EAEpD,IAAI,EAAE,MAAK,aAALD,KAAK,uBAALA,KAAK,CAAEE,IAAI,MAAK,UAAU,CAAC,EAAE;IACjC,OAAOF,KAAK;;EAEd,OAAO;IACLE,IAAI,EAAE,UAAU;IAChBC,SAAS,EAAEH,KAAK,CAACG,SAAS,GAAGR,oBAAoB,CAACK,KAAK,CAACG,SAAS,EAAEF,UAAU,CAACE,SAAS,CAAC;IACxFC,OAAO,EAAEJ,KAAK,CAACI,OAAO,GAAGT,oBAAoB,CAACK,KAAK,CAACI,OAAO,EAAEH,UAAU,CAACG,OAAO;GAChF;AACH;AAEA;;;;;AAKA,OAAM,SAAUC,eAAe,CAC7BL,KAAwC,EACxCC,UAAoD;EAEpD,IAAI,CAACD,KAAK,IAAIA,KAAK,CAACE,IAAI,KAAK,UAAU,EAAE;IACvC,OAAOF,KAAK;;EAGd;;;;;;EAMA,IAAMM,aAAa,GAAG,iFAAiF;EAEvG,IAAI,CAACA,aAAa,CAACC,IAAI,CAACP,KAAK,CAACG,SAAS,CAAC,IAAI,CAACG,aAAa,CAACC,IAAI,CAACP,KAAK,CAACI,OAAO,CAAC,EAAE;IAC9EV,QAAQ,CACN,iBAAiB,EACjB,sGAAsG,GACpG,uEAAuE,CAC1E;IACD,OAAO,IAAI;;EAGb,OAAO;IACLQ,IAAI,EAAE,UAAU;IAChBC,SAAS,EAAEN,mBAAmB,CAACG,KAAK,CAACG,SAAS,EAAEF,UAAU,CAACE,SAAS,CAAC;IACrEC,OAAO,EAAEP,mBAAmB,CAACG,KAAK,CAACI,OAAO,EAAEH,UAAU,CAACG,OAAO;GAC/D;AACH;AAEA,OAAM,SAAUI,mBAAmB,CACjCR,KAAwC,EACxCS,aAA0D,EAC1DR,UAAmB;EAEnB,IAAID,KAAK,IAAIA,KAAK,CAACE,IAAI,KAAK,UAAU,EAAE;IACtC,IAAIO,aAAa,EAAE;MACjB,OAAO;QACLN,SAAS,EAAEM,aAAa,CAACC,YAAY,CAACV,KAAK,CAACG,SAAS,CAAC,CAAC;QACvDC,OAAO,EAAEK,aAAa,CAACC,YAAY,CAACV,KAAK,CAACI,OAAO,CAAC;OACnD;KACF,MAAM,IAAIH,UAAU,KAAKU,SAAS,EAAE;MACnC,OAAO;QAAER,SAAS,EAAEF,UAAU;QAAEG,OAAO,EAAEH;MAAU,CAAE;;;EAGzD,OAAO;IAAEE,SAAS,EAAEQ,SAAS;IAAEP,OAAO,EAAEO;EAAS,CAAE;AACrD;AAEA;;;;;;;;;;;;;;;;AAgBA,SAASD,YAAY,CAACE,aAAqB;EACzC,IAAMC,IAAI,GAAG,IAAIC,IAAI,CAACF,aAAa,CAAC;EACpC,OAAOd,UAAU,CAACe,IAAI,EAAEjB,mBAAmB,CAACgB,aAAa,CAAC,CAAC;AAC7D","names":["warnOnce","formatTimezoneOffset","parseTimezoneOffset","shiftTimezoneOffset","addMinutes","setTimeOffset","value","timeOffset","type","startDate","endDate","shiftTimeOffset","dateTimeRegex","test","normalizeTimeOffset","getTimeOffset","parseDateUTC","undefined","isoDateString","date","Date"],"sources":["/Users/tangyizhi/Desktop/Assignment2/frontend/node_modules/@cloudscape-design/components/date-range-picker/lib/default/date-range-picker/time-offset.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { DateRangePickerProps } from './interfaces';\nimport { warnOnce } from '@cloudscape-design/component-toolkit/internal';\nimport { formatTimezoneOffset, parseTimezoneOffset, shiftTimezoneOffset } from '../internal/utils/date-time';\nimport { addMinutes } from 'date-fns';\n\n/**\n * Appends a time zone offset to an offset-less date string.\n */\nexport function setTimeOffset(\n  value: DateRangePickerProps.Value | null,\n  timeOffset: { startDate?: number; endDate?: number }\n): DateRangePickerProps.Value | null {\n  if (!(value?.type === 'absolute')) {\n    return value;\n  }\n  return {\n    type: 'absolute',\n    startDate: value.startDate + formatTimezoneOffset(value.startDate, timeOffset.startDate),\n    endDate: value.endDate + formatTimezoneOffset(value.endDate, timeOffset.endDate),\n  };\n}\n\n/**\n * Re-formats an absolute date range so that it is expressed using the\n * target time offset. The returned value still represents the same range\n * in time, but contains no visible offset.\n */\nexport function shiftTimeOffset(\n  value: null | DateRangePickerProps.Value,\n  timeOffset: { startDate?: number; endDate?: number }\n): DateRangePickerProps.Value | null {\n  if (!value || value.type !== 'absolute') {\n    return value;\n  }\n\n  /*\n    This regex matches an ISO date-time with\n    - optional seconds;\n    - optional milliseconds;\n    - optional time offset or 'Z'.\n  */\n  const dateTimeRegex = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}(:\\d{2})?(\\.\\d{1,3})?(((\\+|-)\\d{2}(:\\d{2})?)|Z)?$/;\n\n  if (!dateTimeRegex.test(value.startDate) || !dateTimeRegex.test(value.endDate)) {\n    warnOnce(\n      'DateRangePicker',\n      'You have provided a misformatted start or end date. The component will fall back to an empty value. ' +\n        'Dates have to be ISO8601-formatted with an optional time zone offset.'\n    );\n    return null;\n  }\n\n  return {\n    type: 'absolute',\n    startDate: shiftTimezoneOffset(value.startDate, timeOffset.startDate),\n    endDate: shiftTimezoneOffset(value.endDate, timeOffset.endDate),\n  };\n}\n\nexport function normalizeTimeOffset(\n  value: null | DateRangePickerProps.Value,\n  getTimeOffset?: DateRangePickerProps.GetTimeOffsetFunction,\n  timeOffset?: number\n) {\n  if (value && value.type === 'absolute') {\n    if (getTimeOffset) {\n      return {\n        startDate: getTimeOffset(parseDateUTC(value.startDate)),\n        endDate: getTimeOffset(parseDateUTC(value.endDate)),\n      };\n    } else if (timeOffset !== undefined) {\n      return { startDate: timeOffset, endDate: timeOffset };\n    }\n  }\n  return { startDate: undefined, endDate: undefined };\n}\n\n/*\n  Before the getTimeOffset function is used there is no information on the preferred time offset.\n  \n  Besides, the ISO date string might or might not contain the offset:\n  - 2021-02-03T01:02:03\n  - 2021-02-03T01:02:03Z\n  - 2021-02-03T01:02:03+01:00\n  \n  For every value above the date is converted to UTC and the following is true:\n  date.getUTCFullYear() === 2021\n  date.getUTCMonth() === 1\n  date.getUTCDate() === 3\n  date.getUTCHours() === 1\n  date.getUTCMinutes() === 2\n  date.getUTCSeconds() === 3\n*/\nfunction parseDateUTC(isoDateString: string): Date {\n  const date = new Date(isoDateString);\n  return addMinutes(date, parseTimezoneOffset(isoDateString));\n}\n"]},"metadata":{},"sourceType":"module"}