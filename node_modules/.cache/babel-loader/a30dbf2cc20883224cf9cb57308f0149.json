{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { nodeContains } from '@cloudscape-design/component-toolkit/dom';\nimport styles from '../styles.css.js';\nimport { isYThreshold } from '../utils';\nconst MAX_HOVER_MARGIN = 6;\nconst POPOVER_DEADZONE = 12;\nexport function useMouseHover(_ref) {\n  let {\n    plotRef,\n    popoverRef,\n    scaledSeries,\n    barGroups,\n    highlightPoint,\n    highlightGroup,\n    clearHighlightedSeries,\n    isGroupNavigation,\n    isHandlersDisabled,\n    highlightX\n  } = _ref;\n  const isMouseOverPopover = event => {\n    var _a;\n    if ((_a = popoverRef.current) === null || _a === void 0 ? void 0 : _a.firstChild) {\n      const popoverPosition = popoverRef.current.firstChild.getBoundingClientRect();\n      if (event.clientX > popoverPosition.x - POPOVER_DEADZONE && event.clientX < popoverPosition.x + popoverPosition.width + POPOVER_DEADZONE && event.clientY > popoverPosition.y - POPOVER_DEADZONE && event.clientY < popoverPosition.y + popoverPosition.height + POPOVER_DEADZONE) {\n        return true;\n      }\n    }\n    return false;\n  };\n  const onSeriesMouseMove = event => {\n    var _a, _b;\n    const svgRect = event.target.getBoundingClientRect();\n    const offsetX = event.clientX - svgRect.left;\n    const closestX = scaledSeries.map(v => v.x).reduce((prev, curr) => Math.abs(curr - offsetX) < Math.abs(prev - offsetX) ? curr : prev, -Infinity);\n    if (isFinite(closestX)) {\n      const offsetY = event.clientY - svgRect.top;\n      const closestY = scaledSeries.filter(v => v.x === closestX || isYThreshold(v.series)).map(v => v.y).reduce((prev, curr) => Math.abs(curr - offsetY) < Math.abs(prev - offsetY) ? curr : prev, -Infinity);\n      if (isFinite(closestY) && Math.abs(offsetX - closestX) < MAX_HOVER_MARGIN && Math.abs(offsetY - closestY) < MAX_HOVER_MARGIN) {\n        const [{\n          color,\n          datum,\n          series\n        }] = scaledSeries.filter(s => (s.x === closestX || isYThreshold(s.series)) && s.y === closestY);\n        highlightPoint({\n          x: closestX,\n          y: closestY,\n          color,\n          datum,\n          series\n        });\n      } else {\n        let datumX = null;\n        for (const point of scaledSeries) {\n          if (point.x === closestX) {\n            datumX = (_b = (_a = point.datum) === null || _a === void 0 ? void 0 : _a.x) !== null && _b !== void 0 ? _b : null;\n            break;\n          }\n        }\n        highlightX({\n          scaledX: closestX,\n          label: datumX\n        });\n      }\n    }\n  };\n  const onGroupMouseMove = event => {\n    const svgRect = event.target.getBoundingClientRect();\n    const offsetX = event.clientX - svgRect.left;\n    const offsetY = event.clientY - svgRect.top;\n    // If hovering over some group - highlight it.\n    for (let groupIndex = 0; groupIndex < barGroups.length; groupIndex++) {\n      const {\n        position: {\n          x,\n          y,\n          width,\n          height\n        }\n      } = barGroups[groupIndex];\n      if (x <= offsetX && offsetX <= x + width && y <= offsetY && offsetY <= y + height) {\n        highlightGroup(groupIndex);\n        return;\n      }\n    }\n    // Otherwise - clear the highlight.\n    clearHighlightedSeries();\n  };\n  const onSVGMouseMove = event => {\n    if (event.target === plotRef.current.svg && !isHandlersDisabled && !isMouseOverPopover(event)) {\n      if (isGroupNavigation) {\n        onGroupMouseMove(event);\n      } else if (scaledSeries.length > 0) {\n        onSeriesMouseMove(event);\n      }\n    }\n  };\n  const onSVGMouseOut = event => {\n    if (isHandlersDisabled || isMouseOverPopover(event)) {\n      return;\n    }\n    if (!nodeContains(plotRef.current.svg, event.relatedTarget) || event.relatedTarget && event.relatedTarget.classList.contains(styles.series)) {\n      highlightX(null);\n      clearHighlightedSeries();\n    }\n  };\n  const onPopoverLeave = event => {\n    if (!plotRef.current.svg.contains(event.relatedTarget)) {\n      highlightX(null);\n      clearHighlightedSeries();\n    }\n  };\n  return {\n    onSVGMouseMove,\n    onSVGMouseOut,\n    onPopoverLeave\n  };\n}","map":{"version":3,"mappings":"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","names":["nodeContains","styles","isYThreshold","MAX_HOVER_MARGIN","POPOVER_DEADZONE","useMouseHover","plotRef","popoverRef","scaledSeries","barGroups","highlightPoint","highlightGroup","clearHighlightedSeries","isGroupNavigation","isHandlersDisabled","highlightX","isMouseOverPopover","event","current","firstChild","popoverPosition","getBoundingClientRect","clientX","x","width","clientY","y","height","onSeriesMouseMove","svgRect","target","offsetX","left","closestX","map","v","reduce","prev","curr","Math","abs","Infinity","isFinite","offsetY","top","closestY","filter","series","color","datum","s","datumX","point","scaledX","label","onGroupMouseMove","groupIndex","length","position","onSVGMouseMove","svg","onSVGMouseOut","relatedTarget","classList","contains","onPopoverLeave"],"sources":["/Users/tangyizhi/Desktop/Assignment 2/frontend/node_modules/@cloudscape-design/components/mixed-line-bar-chart/hooks/lib/default/mixed-line-bar-chart/hooks/use-mouse-hover.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { nodeContains } from '@cloudscape-design/component-toolkit/dom';\n\nimport { ScaledBarGroup } from '../make-scaled-bar-groups';\nimport { ScaledPoint } from '../make-scaled-series';\n\nimport styles from '../styles.css.js';\nimport { ChartPlotRef } from '../../internal/components/chart-plot';\nimport { VerticalMarkerX } from '../interfaces';\nimport { isYThreshold } from '../utils';\n\nconst MAX_HOVER_MARGIN = 6;\nconst POPOVER_DEADZONE = 12;\n\nexport interface UseMouseHoverProps<T> {\n  plotRef: React.RefObject<ChartPlotRef>;\n  popoverRef: React.RefObject<HTMLElement>;\n  scaledSeries: ReadonlyArray<ScaledPoint<T>>;\n  barGroups: ScaledBarGroup<T>[];\n  highlightPoint: (point: ScaledPoint<T> | null) => void;\n  highlightGroup: (groupIndex: number) => void;\n  clearHighlightedSeries: () => void;\n  isGroupNavigation: boolean;\n  isHandlersDisabled: boolean;\n  highlightX: (verticalMarker: VerticalMarkerX<T> | null) => void;\n}\n\nexport function useMouseHover<T>({\n  plotRef,\n  popoverRef,\n  scaledSeries,\n  barGroups,\n  highlightPoint,\n  highlightGroup,\n  clearHighlightedSeries,\n  isGroupNavigation,\n  isHandlersDisabled,\n  highlightX,\n}: UseMouseHoverProps<T>) {\n  const isMouseOverPopover = (event: React.MouseEvent<SVGElement, MouseEvent>) => {\n    if (popoverRef.current?.firstChild) {\n      const popoverPosition = (popoverRef.current.firstChild as HTMLElement).getBoundingClientRect();\n      if (\n        event.clientX > popoverPosition.x - POPOVER_DEADZONE &&\n        event.clientX < popoverPosition.x + popoverPosition.width + POPOVER_DEADZONE &&\n        event.clientY > popoverPosition.y - POPOVER_DEADZONE &&\n        event.clientY < popoverPosition.y + popoverPosition.height + POPOVER_DEADZONE\n      ) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  const onSeriesMouseMove = (event: React.MouseEvent<SVGElement, MouseEvent>) => {\n    const svgRect = (event.target as SVGElement).getBoundingClientRect();\n    const offsetX = event.clientX - svgRect.left;\n\n    const closestX = scaledSeries\n      .map(v => v.x)\n      .reduce((prev, curr) => (Math.abs(curr - offsetX) < Math.abs(prev - offsetX) ? curr : prev), -Infinity);\n\n    if (isFinite(closestX)) {\n      const offsetY = event.clientY - svgRect.top;\n      const closestY = scaledSeries\n        .filter(v => v.x === closestX || isYThreshold(v.series))\n        .map(v => v.y)\n        .reduce((prev, curr) => (Math.abs(curr - offsetY) < Math.abs(prev - offsetY) ? curr : prev), -Infinity);\n\n      if (\n        isFinite(closestY) &&\n        Math.abs(offsetX - closestX) < MAX_HOVER_MARGIN &&\n        Math.abs(offsetY - closestY) < MAX_HOVER_MARGIN\n      ) {\n        const [{ color, datum, series }] = scaledSeries.filter(\n          s => (s.x === closestX || isYThreshold(s.series)) && s.y === closestY\n        );\n        highlightPoint({ x: closestX, y: closestY, color, datum, series });\n      } else {\n        let datumX = null;\n        for (const point of scaledSeries) {\n          if (point.x === closestX) {\n            datumX = point.datum?.x ?? null;\n            break;\n          }\n        }\n        highlightX({ scaledX: closestX, label: datumX });\n      }\n    }\n  };\n\n  const onGroupMouseMove = (event: React.MouseEvent<SVGElement, MouseEvent>) => {\n    const svgRect = (event.target as SVGElement).getBoundingClientRect();\n    const offsetX = event.clientX - svgRect.left;\n    const offsetY = event.clientY - svgRect.top;\n\n    // If hovering over some group - highlight it.\n    for (let groupIndex = 0; groupIndex < barGroups.length; groupIndex++) {\n      const {\n        position: { x, y, width, height },\n      } = barGroups[groupIndex];\n\n      if (x <= offsetX && offsetX <= x + width && y <= offsetY && offsetY <= y + height) {\n        highlightGroup(groupIndex);\n        return;\n      }\n    }\n    // Otherwise - clear the highlight.\n    clearHighlightedSeries();\n  };\n\n  const onSVGMouseMove = (event: React.MouseEvent<SVGElement, MouseEvent>) => {\n    if (event.target === plotRef.current!.svg && !isHandlersDisabled && !isMouseOverPopover(event)) {\n      if (isGroupNavigation) {\n        onGroupMouseMove(event);\n      } else if (scaledSeries.length > 0) {\n        onSeriesMouseMove(event);\n      }\n    }\n  };\n\n  const onSVGMouseOut = (event: React.MouseEvent<SVGElement, MouseEvent>) => {\n    if (isHandlersDisabled || isMouseOverPopover(event)) {\n      return;\n    }\n    if (\n      !nodeContains(plotRef.current!.svg, event.relatedTarget as Element) ||\n      (event.relatedTarget && (event.relatedTarget as Element).classList.contains(styles.series))\n    ) {\n      highlightX(null);\n      clearHighlightedSeries();\n    }\n  };\n\n  const onPopoverLeave = (event: React.MouseEvent) => {\n    if (!plotRef.current!.svg.contains(event.relatedTarget as Node)) {\n      highlightX(null);\n      clearHighlightedSeries();\n    }\n  };\n\n  return { onSVGMouseMove, onSVGMouseOut, onPopoverLeave };\n}\n"]},"metadata":{},"sourceType":"module"}