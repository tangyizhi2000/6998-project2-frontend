{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { Position } from \"../utils/position\";\nimport { LayoutEngineGrid } from \"./grid\";\nimport { checkOppositeDirections, createMove, getMoveOriginalRect, getMoveRect } from \"./utils\";\n// All directions in which overlaps can be incrementally resolved.\nconst PRIORITY_DIRECTIONS = [\"down\", \"right\", \"left\", \"up\"];\n// The class represents an intermediate layout state used to find the next set of solutions for.\n// The solution is terminal when no overlaps are left and it can become the next layout state if its\n// score is smaller than that of the alternative solutions.\nexport class MoveSolutionState {\n  constructor(grid, moves, conflicts) {\n    this.moveIndex = 0;\n    this.overlaps = new Map();\n    this.score = 0;\n    this.grid = LayoutEngineGrid.clone(grid);\n    this.moves = [...moves];\n    this.moveIndex = moves.length;\n    this.conflicts = conflicts;\n  }\n  // The solution state needs to be cloned after the move is performed in case there are overlaps left\n  // so that the next solutions won't have the shared state to corrupt.\n  // The conflicts never change and can be carried over w/o cloning.\n  static clone(_ref) {\n    let {\n      grid,\n      moves,\n      moveIndex,\n      conflicts,\n      overlaps,\n      score\n    } = _ref;\n    return {\n      grid: LayoutEngineGrid.clone(grid),\n      moves: [...moves],\n      moveIndex,\n      conflicts,\n      overlaps: new Map([...overlaps]),\n      score\n    };\n  }\n}\n/**\n * Given a solution state finds a set of all possible moves each resolving a particular overlap.\n */\nexport function findNextSolutions(state) {\n  // For every overlap and direction found a move if exists that resolves the overlap.\n  // A pair of the given state and the overlap resolution move is a new solution to try.\n  const nextMoveSolutions = [];\n  for (const [overlapId, overlapIssuerId] of state.overlaps) {\n    for (const moveDirection of PRIORITY_DIRECTIONS) {\n      const move = getOverlapMove(state, overlapId, overlapIssuerId, moveDirection);\n      if (move !== null) {\n        nextMoveSolutions.push([MoveSolutionState.clone(state), move]);\n      }\n    }\n  }\n  return nextMoveSolutions;\n}\n// Returns an evaluated move to resolve the given overlap in the given direction or null if such move is not possible.\nfunction getOverlapMove(state, overlapId, overlapIssuerId, moveDirection) {\n  var _a;\n  const userItem = state.grid.getItem(state.moves[0].itemId);\n  const overlapItem = state.grid.getItem(overlapId);\n  const overlapIssuerItem = state.grid.getItem(overlapIssuerId);\n  const overlapMove = getMoveForDirection(overlapItem, overlapIssuerItem, moveDirection);\n  // The move position is outside the grid boundaries.\n  if (overlapMove.x < 0 || overlapMove.y < 0 || overlapMove.x + overlapMove.width > state.grid.width) {\n    return null;\n  }\n  // Subsequent item overlap moves in the opposite directions do not contribute to solution.\n  const prevOverlapMove = getLastSolutionMove(state, overlapItem.id);\n  if (prevOverlapMove && checkOppositeDirections(prevOverlapMove.direction, moveDirection)) {\n    return null;\n  }\n  const pathOverlaps = getPathOverlaps(state, overlapMove, overlapIssuerItem);\n  for (const overlap of pathOverlaps) {\n    // Not allowed to intersect with the user-controlled item.\n    if (overlap.id === userItem.id) {\n      return null;\n    }\n    // Not allowed to intersect with conflicting items.\n    if ((_a = state.conflicts) === null || _a === void 0 ? void 0 : _a.items.has(overlap.id)) {\n      return null;\n    }\n    // Intersecting with items having unresolved overlaps does not contribute to solution.\n    if (state.overlaps.has(overlap.id)) {\n      return null;\n    }\n  }\n  const lastIssuerMove = getLastSolutionMove(state, overlapIssuerItem.id);\n  if (!lastIssuerMove) {\n    throw new Error(\"Invariant violation: overlap issuer has no associated moves.\");\n  }\n  const issuerDirection = lastIssuerMove.direction;\n  const isSwap = checkIfSwap(overlapMove, lastIssuerMove);\n  const isDifferentIssuerDirection = moveDirection !== issuerDirection;\n  const isOppositeIssuerDirection = checkOppositeDirections(moveDirection, issuerDirection);\n  const userMoveBoundaries = getUserMoveBoundaries(state);\n  const moveVector = getSolutionMovesVector(state);\n  // Swap score penalizes non-swap overlap resolutions in case the direction does not match that of the issuer.\n  const swapPenalty = isSwap ? 0 : 20;\n  const differentDirectionPenalty = !isSwap && isDifferentIssuerDirection ? 10 : 0;\n  const oppositeDirectionPenalty = !isSwap && isOppositeIssuerDirection ? 500 : 0;\n  const swapScore = swapPenalty + differentDirectionPenalty + oppositeDirectionPenalty;\n  // Overlaps score penalizes moves that cause additional overlaps.\n  const overlapsScore = pathOverlaps.size * 50;\n  // Boundaries score penalize movements of items that are outside the area covered by the user move.\n  const moveOutsideUserTopPenalty = overlapItem.y + overlapItem.height - 1 < userMoveBoundaries.top ? 500 : 0;\n  const moveOutsideUserLeftPenalty = overlapItem.x + overlapItem.width - 1 < userMoveBoundaries.left ? 50 : 0;\n  const moveOutsideUserRightPenalty = overlapItem.x > userMoveBoundaries.right ? 50 : 0;\n  const boundariesScore = moveOutsideUserTopPenalty + moveOutsideUserLeftPenalty + moveOutsideUserRightPenalty;\n  // Move vector score penalize movements that are against the common move direction of other items.\n  const vectorXPenalty = overlapMove.distanceX * moveVector.x < 0 ? moveVector.x * 2 : 0;\n  const vectorYPenalty = overlapMove.distanceY * moveVector.y < 0 ? moveVector.y * 2 : 0;\n  const moveVectorScore = vectorXPenalty + vectorYPenalty;\n  // Score starts from 1 to avoid overlap moves having 0 score which breaks the solutions cache.\n  const score = 1 + swapScore + overlapsScore + moveVectorScore + boundariesScore;\n  return {\n    ...overlapMove,\n    score\n  };\n}\n// Retrieves the first possible move for the given direction to resolve the overlap.\nfunction getMoveForDirection(moveTarget, overlap, direction) {\n  switch (direction) {\n    case \"up\":\n      return createMove(\"OVERLAP\", moveTarget, new Position({\n        x: moveTarget.x,\n        y: overlap.y - moveTarget.height\n      }));\n    case \"down\":\n      return createMove(\"OVERLAP\", moveTarget, new Position({\n        x: moveTarget.x,\n        y: overlap.y + overlap.height\n      }));\n    case \"left\":\n      return createMove(\"OVERLAP\", moveTarget, new Position({\n        x: overlap.x - moveTarget.width,\n        y: moveTarget.y\n      }));\n    case \"right\":\n      return createMove(\"OVERLAP\", moveTarget, new Position({\n        x: overlap.x + overlap.width,\n        y: moveTarget.y\n      }));\n  }\n}\n// Retrieves the last move if exists within the given solution.\nfunction getLastSolutionMove(state, itemId) {\n  let lastMove = null;\n  for (let i = state.moves.length - 1; i >= state.moveIndex; i--) {\n    if (state.moves[i].itemId === itemId) {\n      lastMove = state.moves[i];\n      break;\n    }\n  }\n  return lastMove;\n}\n// Calculates vector as the amount of cell movements to either direction.\n// All moves in one direction are summarized, the opposite moves cancel each other.\n// The vector show in which direction (left / right, up / down) the most overlaps were resolved.\nfunction getSolutionMovesVector(state) {\n  const vector = {\n    x: 0,\n    y: 0\n  };\n  for (let i = state.moveIndex; i < state.moves.length; i++) {\n    const move = state.moves[i];\n    if (move.type === \"OVERLAP\") {\n      vector.x += move.distanceX * move.height;\n      vector.y += move.distanceY * move.width;\n    }\n  }\n  return vector;\n}\n// Finds a rectangle within which the user-controlled item was moved (previous and current positions only).\n// The layout items outside the boundaries are not expected to be disturbed.\nfunction getUserMoveBoundaries(state) {\n  const firstUserMove = state.moves[0];\n  const lastUserMove = state.moves[state.moveIndex];\n  if (!firstUserMove || !lastUserMove || firstUserMove.itemId !== lastUserMove.itemId) {\n    throw new Error(\"Invariant violation: unexpected user move.\");\n  }\n  const original = getMoveOriginalRect(lastUserMove);\n  const current = getMoveRect(lastUserMove);\n  return {\n    top: Math.min(original.top, current.top),\n    right: Math.max(original.right, current.right),\n    bottom: Math.max(original.bottom, current.bottom),\n    left: Math.min(original.left, current.left)\n  };\n}\n// Finds all overlaps that the move will cause along its path not considering the original location and original overlap.\nfunction getPathOverlaps(state, move, overlapIssuerItem) {\n  const {\n    left,\n    right,\n    top,\n    bottom\n  } = getMoveOriginalRect(move);\n  const startX = move.distanceX <= 0 ? move.x : right + 1;\n  const endX = move.distanceX < 0 ? left - 1 : right + move.distanceX;\n  const startY = move.distanceY <= 0 ? move.y : bottom + 1;\n  const endY = move.distanceY < 0 ? top - 1 : bottom + move.distanceY;\n  const pathOverlaps = new Set(state.grid.getOverlaps({\n    id: move.itemId,\n    x: startX,\n    width: 1 + endX - startX,\n    y: startY,\n    height: 1 + endY - startY\n  }));\n  pathOverlaps.delete(overlapIssuerItem);\n  return pathOverlaps;\n}\n// Checks if the overlap move is a swap with the user-moved item.\nfunction checkIfSwap(overlapMove, lastIssuerMove) {\n  if (lastIssuerMove.type !== \"MOVE\") {\n    return false;\n  }\n  if (!checkOppositeDirections(overlapMove.direction, lastIssuerMove.direction)) {\n    return false;\n  }\n  const overlapRect = getMoveOriginalRect(overlapMove);\n  const issuerRect = getMoveRect(lastIssuerMove);\n  switch (lastIssuerMove.direction) {\n    case \"up\":\n      return overlapRect.top === issuerRect.top;\n    case \"right\":\n      return overlapRect.right === issuerRect.right;\n    case \"down\":\n      return overlapRect.bottom === issuerRect.bottom;\n    case \"left\":\n      return overlapRect.left === issuerRect.left;\n  }\n}","map":{"version":3,"names":["Position","LayoutEngineGrid","checkOppositeDirections","createMove","getMoveOriginalRect","getMoveRect","PRIORITY_DIRECTIONS","MoveSolutionState","constructor","grid","moves","conflicts","moveIndex","overlaps","Map","score","clone","length","findNextSolutions","state","nextMoveSolutions","overlapId","overlapIssuerId","moveDirection","move","getOverlapMove","push","_a","userItem","getItem","itemId","overlapItem","overlapIssuerItem","overlapMove","getMoveForDirection","x","y","width","prevOverlapMove","getLastSolutionMove","id","direction","pathOverlaps","getPathOverlaps","overlap","items","has","lastIssuerMove","Error","issuerDirection","isSwap","checkIfSwap","isDifferentIssuerDirection","isOppositeIssuerDirection","userMoveBoundaries","getUserMoveBoundaries","moveVector","getSolutionMovesVector","swapPenalty","differentDirectionPenalty","oppositeDirectionPenalty","swapScore","overlapsScore","size","moveOutsideUserTopPenalty","height","top","moveOutsideUserLeftPenalty","left","moveOutsideUserRightPenalty","right","boundariesScore","vectorXPenalty","distanceX","vectorYPenalty","distanceY","moveVectorScore","moveTarget","lastMove","i","vector","type","firstUserMove","lastUserMove","original","current","Math","min","max","bottom","startX","endX","startY","endY","Set","getOverlaps","delete","overlapRect","issuerRect"],"sources":["/Users/tangyizhi/Desktop/Assignment 2/frontend/node_modules/@cloudscape-design/board-components/internal/layout-engine/engine-solution.js"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { Position } from \"../utils/position\";\nimport { LayoutEngineGrid } from \"./grid\";\nimport { checkOppositeDirections, createMove, getMoveOriginalRect, getMoveRect } from \"./utils\";\n// All directions in which overlaps can be incrementally resolved.\nconst PRIORITY_DIRECTIONS = [\"down\", \"right\", \"left\", \"up\"];\n// The class represents an intermediate layout state used to find the next set of solutions for.\n// The solution is terminal when no overlaps are left and it can become the next layout state if its\n// score is smaller than that of the alternative solutions.\nexport class MoveSolutionState {\n    constructor(grid, moves, conflicts) {\n        this.moveIndex = 0;\n        this.overlaps = new Map();\n        this.score = 0;\n        this.grid = LayoutEngineGrid.clone(grid);\n        this.moves = [...moves];\n        this.moveIndex = moves.length;\n        this.conflicts = conflicts;\n    }\n    // The solution state needs to be cloned after the move is performed in case there are overlaps left\n    // so that the next solutions won't have the shared state to corrupt.\n    // The conflicts never change and can be carried over w/o cloning.\n    static clone({ grid, moves, moveIndex, conflicts, overlaps, score }) {\n        return {\n            grid: LayoutEngineGrid.clone(grid),\n            moves: [...moves],\n            moveIndex,\n            conflicts,\n            overlaps: new Map([...overlaps]),\n            score,\n        };\n    }\n}\n/**\n * Given a solution state finds a set of all possible moves each resolving a particular overlap.\n */\nexport function findNextSolutions(state) {\n    // For every overlap and direction found a move if exists that resolves the overlap.\n    // A pair of the given state and the overlap resolution move is a new solution to try.\n    const nextMoveSolutions = [];\n    for (const [overlapId, overlapIssuerId] of state.overlaps) {\n        for (const moveDirection of PRIORITY_DIRECTIONS) {\n            const move = getOverlapMove(state, overlapId, overlapIssuerId, moveDirection);\n            if (move !== null) {\n                nextMoveSolutions.push([MoveSolutionState.clone(state), move]);\n            }\n        }\n    }\n    return nextMoveSolutions;\n}\n// Returns an evaluated move to resolve the given overlap in the given direction or null if such move is not possible.\nfunction getOverlapMove(state, overlapId, overlapIssuerId, moveDirection) {\n    var _a;\n    const userItem = state.grid.getItem(state.moves[0].itemId);\n    const overlapItem = state.grid.getItem(overlapId);\n    const overlapIssuerItem = state.grid.getItem(overlapIssuerId);\n    const overlapMove = getMoveForDirection(overlapItem, overlapIssuerItem, moveDirection);\n    // The move position is outside the grid boundaries.\n    if (overlapMove.x < 0 || overlapMove.y < 0 || overlapMove.x + overlapMove.width > state.grid.width) {\n        return null;\n    }\n    // Subsequent item overlap moves in the opposite directions do not contribute to solution.\n    const prevOverlapMove = getLastSolutionMove(state, overlapItem.id);\n    if (prevOverlapMove && checkOppositeDirections(prevOverlapMove.direction, moveDirection)) {\n        return null;\n    }\n    const pathOverlaps = getPathOverlaps(state, overlapMove, overlapIssuerItem);\n    for (const overlap of pathOverlaps) {\n        // Not allowed to intersect with the user-controlled item.\n        if (overlap.id === userItem.id) {\n            return null;\n        }\n        // Not allowed to intersect with conflicting items.\n        if ((_a = state.conflicts) === null || _a === void 0 ? void 0 : _a.items.has(overlap.id)) {\n            return null;\n        }\n        // Intersecting with items having unresolved overlaps does not contribute to solution.\n        if (state.overlaps.has(overlap.id)) {\n            return null;\n        }\n    }\n    const lastIssuerMove = getLastSolutionMove(state, overlapIssuerItem.id);\n    if (!lastIssuerMove) {\n        throw new Error(\"Invariant violation: overlap issuer has no associated moves.\");\n    }\n    const issuerDirection = lastIssuerMove.direction;\n    const isSwap = checkIfSwap(overlapMove, lastIssuerMove);\n    const isDifferentIssuerDirection = moveDirection !== issuerDirection;\n    const isOppositeIssuerDirection = checkOppositeDirections(moveDirection, issuerDirection);\n    const userMoveBoundaries = getUserMoveBoundaries(state);\n    const moveVector = getSolutionMovesVector(state);\n    // Swap score penalizes non-swap overlap resolutions in case the direction does not match that of the issuer.\n    const swapPenalty = isSwap ? 0 : 20;\n    const differentDirectionPenalty = !isSwap && isDifferentIssuerDirection ? 10 : 0;\n    const oppositeDirectionPenalty = !isSwap && isOppositeIssuerDirection ? 500 : 0;\n    const swapScore = swapPenalty + differentDirectionPenalty + oppositeDirectionPenalty;\n    // Overlaps score penalizes moves that cause additional overlaps.\n    const overlapsScore = pathOverlaps.size * 50;\n    // Boundaries score penalize movements of items that are outside the area covered by the user move.\n    const moveOutsideUserTopPenalty = overlapItem.y + overlapItem.height - 1 < userMoveBoundaries.top ? 500 : 0;\n    const moveOutsideUserLeftPenalty = overlapItem.x + overlapItem.width - 1 < userMoveBoundaries.left ? 50 : 0;\n    const moveOutsideUserRightPenalty = overlapItem.x > userMoveBoundaries.right ? 50 : 0;\n    const boundariesScore = moveOutsideUserTopPenalty + moveOutsideUserLeftPenalty + moveOutsideUserRightPenalty;\n    // Move vector score penalize movements that are against the common move direction of other items.\n    const vectorXPenalty = overlapMove.distanceX * moveVector.x < 0 ? moveVector.x * 2 : 0;\n    const vectorYPenalty = overlapMove.distanceY * moveVector.y < 0 ? moveVector.y * 2 : 0;\n    const moveVectorScore = vectorXPenalty + vectorYPenalty;\n    // Score starts from 1 to avoid overlap moves having 0 score which breaks the solutions cache.\n    const score = 1 + swapScore + overlapsScore + moveVectorScore + boundariesScore;\n    return { ...overlapMove, score };\n}\n// Retrieves the first possible move for the given direction to resolve the overlap.\nfunction getMoveForDirection(moveTarget, overlap, direction) {\n    switch (direction) {\n        case \"up\":\n            return createMove(\"OVERLAP\", moveTarget, new Position({ x: moveTarget.x, y: overlap.y - moveTarget.height }));\n        case \"down\":\n            return createMove(\"OVERLAP\", moveTarget, new Position({ x: moveTarget.x, y: overlap.y + overlap.height }));\n        case \"left\":\n            return createMove(\"OVERLAP\", moveTarget, new Position({ x: overlap.x - moveTarget.width, y: moveTarget.y }));\n        case \"right\":\n            return createMove(\"OVERLAP\", moveTarget, new Position({ x: overlap.x + overlap.width, y: moveTarget.y }));\n    }\n}\n// Retrieves the last move if exists within the given solution.\nfunction getLastSolutionMove(state, itemId) {\n    let lastMove = null;\n    for (let i = state.moves.length - 1; i >= state.moveIndex; i--) {\n        if (state.moves[i].itemId === itemId) {\n            lastMove = state.moves[i];\n            break;\n        }\n    }\n    return lastMove;\n}\n// Calculates vector as the amount of cell movements to either direction.\n// All moves in one direction are summarized, the opposite moves cancel each other.\n// The vector show in which direction (left / right, up / down) the most overlaps were resolved.\nfunction getSolutionMovesVector(state) {\n    const vector = { x: 0, y: 0 };\n    for (let i = state.moveIndex; i < state.moves.length; i++) {\n        const move = state.moves[i];\n        if (move.type === \"OVERLAP\") {\n            vector.x += move.distanceX * move.height;\n            vector.y += move.distanceY * move.width;\n        }\n    }\n    return vector;\n}\n// Finds a rectangle within which the user-controlled item was moved (previous and current positions only).\n// The layout items outside the boundaries are not expected to be disturbed.\nfunction getUserMoveBoundaries(state) {\n    const firstUserMove = state.moves[0];\n    const lastUserMove = state.moves[state.moveIndex];\n    if (!firstUserMove || !lastUserMove || firstUserMove.itemId !== lastUserMove.itemId) {\n        throw new Error(\"Invariant violation: unexpected user move.\");\n    }\n    const original = getMoveOriginalRect(lastUserMove);\n    const current = getMoveRect(lastUserMove);\n    return {\n        top: Math.min(original.top, current.top),\n        right: Math.max(original.right, current.right),\n        bottom: Math.max(original.bottom, current.bottom),\n        left: Math.min(original.left, current.left),\n    };\n}\n// Finds all overlaps that the move will cause along its path not considering the original location and original overlap.\nfunction getPathOverlaps(state, move, overlapIssuerItem) {\n    const { left, right, top, bottom } = getMoveOriginalRect(move);\n    const startX = move.distanceX <= 0 ? move.x : right + 1;\n    const endX = move.distanceX < 0 ? left - 1 : right + move.distanceX;\n    const startY = move.distanceY <= 0 ? move.y : bottom + 1;\n    const endY = move.distanceY < 0 ? top - 1 : bottom + move.distanceY;\n    const pathOverlaps = new Set(state.grid.getOverlaps({\n        id: move.itemId,\n        x: startX,\n        width: 1 + endX - startX,\n        y: startY,\n        height: 1 + endY - startY,\n    }));\n    pathOverlaps.delete(overlapIssuerItem);\n    return pathOverlaps;\n}\n// Checks if the overlap move is a swap with the user-moved item.\nfunction checkIfSwap(overlapMove, lastIssuerMove) {\n    if (lastIssuerMove.type !== \"MOVE\") {\n        return false;\n    }\n    if (!checkOppositeDirections(overlapMove.direction, lastIssuerMove.direction)) {\n        return false;\n    }\n    const overlapRect = getMoveOriginalRect(overlapMove);\n    const issuerRect = getMoveRect(lastIssuerMove);\n    switch (lastIssuerMove.direction) {\n        case \"up\":\n            return overlapRect.top === issuerRect.top;\n        case \"right\":\n            return overlapRect.right === issuerRect.right;\n        case \"down\":\n            return overlapRect.bottom === issuerRect.bottom;\n        case \"left\":\n            return overlapRect.left === issuerRect.left;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}