{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { useCallback, useMemo, useState } from 'react';\nimport { KeyCode } from '../../internal/keycode';\nimport { findNavigableSeries, isXThreshold, isYThreshold, nextValidDomainIndex } from '../utils';\nexport function useNavigation(_ref) {\n  let {\n    series,\n    visibleSeries,\n    scaledSeries,\n    barGroups,\n    xScale,\n    yScale,\n    highlightedPoint,\n    highlightedGroupIndex,\n    highlightedSeries,\n    isHandlersDisabled,\n    pinPopover,\n    highlightSeries,\n    highlightGroup,\n    highlightPoint,\n    highlightX,\n    verticalMarkerX\n  } = _ref;\n  const [targetX, setTargetX] = useState(null);\n  const [xIndex, setXIndex] = useState(0);\n  // There are two different types of navigation:\n  // 1) Group navigation for any chart that contains a bar series\n  // 2) Line navigation for any chart that only contains lines and thresholds\n  const isGroupNavigation = useMemo(() => visibleSeries.some(_ref2 => {\n    let {\n      series\n    } = _ref2;\n    return series.type === 'bar';\n  }), [visibleSeries]);\n  // Make a list of series that can be navigated between. Bar series are treated as one.\n  const {\n    navigableSeries\n  } = useMemo(() => findNavigableSeries(visibleSeries), [visibleSeries]);\n  const containsMultipleSeries = navigableSeries.length > 1;\n  const onBarGroupFocus = () => {\n    const groupIndex = highlightedGroupIndex !== null && highlightedGroupIndex !== void 0 ? highlightedGroupIndex : 0;\n    setTargetX(xScale.domain[groupIndex]);\n    highlightGroup(groupIndex);\n  };\n  const onLineFocus = () => {\n    if (verticalMarkerX === null) {\n      if (containsMultipleSeries) {\n        moveToLineGroupIndex(0);\n      } else {\n        moveBetweenSeries(0);\n      }\n    }\n  };\n  const onFocus = () => {\n    if (isGroupNavigation) {\n      onBarGroupFocus();\n    } else {\n      onLineFocus();\n    }\n  };\n  // Returns all the unique X coordinates in scaledSeries.\n  // Assumes scaledSeries is sorted by `x`.\n  const allUniqueX = useMemo(() => {\n    const result = [];\n    for (let i = 0; i < scaledSeries.length; i += 1) {\n      const point = scaledSeries[i];\n      if (point !== undefined && (!result.length || result[result.length - 1].scaledX !== point.x)) {\n        result.push({\n          scaledX: point.x,\n          datum: point.datum\n        });\n      }\n    }\n    return result;\n  }, [scaledSeries]);\n  const moveBetweenSeries = useCallback(direction => {\n    var _a, _b, _c, _d;\n    if (isGroupNavigation) {\n      return;\n    }\n    const xOffset = xScale.isCategorical() ? Math.max(0, xScale.d3Scale.bandwidth() - 1) / 2 : 0;\n    const MAX_SERIES_INDEX = navigableSeries.length - 1;\n    // Find the index of the currently highlighted series (if any)\n    let previousSeriesIndex = -1;\n    if (highlightedSeries) {\n      previousSeriesIndex = navigableSeries.indexOf(highlightedSeries);\n    }\n    // Move forwards or backwards to the new series\n    // If index === -1, show all data points from all series at the given X instead of one single series\n    const firstPossibleIndex = containsMultipleSeries ? -1 : 0;\n    let nextSeriesIndex = 0;\n    if (previousSeriesIndex !== null) {\n      nextSeriesIndex = previousSeriesIndex + direction;\n      if (nextSeriesIndex > MAX_SERIES_INDEX) {\n        nextSeriesIndex = firstPossibleIndex;\n      } else if (nextSeriesIndex < firstPossibleIndex) {\n        nextSeriesIndex = MAX_SERIES_INDEX;\n      }\n    }\n    if (nextSeriesIndex === -1) {\n      highlightSeries(null);\n      highlightPoint(null);\n      return;\n    }\n    const nextSeries = navigableSeries[nextSeriesIndex];\n    const nextInternalSeries = series.filter(_ref3 => {\n      let {\n        series\n      } = _ref3;\n      return series === nextSeries;\n    })[0];\n    // 2. Find point in the next series\n    let targetXPoint = ((_a = xScale.d3Scale(targetX)) !== null && _a !== void 0 ? _a : NaN) + xOffset;\n    if (!isFinite(targetXPoint)) {\n      targetXPoint = 0;\n    }\n    if (nextSeries.type === 'line') {\n      const nextScaledSeries = scaledSeries.filter(it => it.series === nextSeries);\n      const closestNextSeriesPoint = nextScaledSeries.reduce((prev, curr) => Math.abs(curr.x - targetXPoint) < Math.abs(prev.x - targetXPoint) ? curr : prev, {\n        x: -Infinity,\n        y: -Infinity\n      });\n      highlightPoint(Object.assign(Object.assign({}, closestNextSeriesPoint), {\n        color: nextInternalSeries.color,\n        series: nextSeries\n      }));\n    } else if (isYThreshold(nextSeries)) {\n      const scaledTargetIndex = scaledSeries.map(it => {\n        var _a;\n        return ((_a = it.datum) === null || _a === void 0 ? void 0 : _a.x) || null;\n      }).indexOf(targetX);\n      highlightPoint({\n        x: targetXPoint,\n        y: (_b = yScale.d3Scale(nextSeries.y)) !== null && _b !== void 0 ? _b : NaN,\n        color: nextInternalSeries.color,\n        series: nextSeries,\n        datum: (_c = scaledSeries[scaledTargetIndex]) === null || _c === void 0 ? void 0 : _c.datum\n      });\n    } else if (isXThreshold(nextSeries)) {\n      highlightPoint({\n        x: (_d = xScale.d3Scale(nextSeries.x)) !== null && _d !== void 0 ? _d : NaN,\n        y: yScale.d3Scale.range()[0],\n        color: nextInternalSeries.color,\n        series: nextSeries,\n        datum: {\n          x: nextSeries.x,\n          y: NaN\n        }\n      });\n    }\n  }, [isGroupNavigation, xScale, navigableSeries, highlightedSeries, containsMultipleSeries, highlightSeries, highlightPoint, series, targetX, scaledSeries, yScale]);\n  const moveWithinSeries = useCallback(direction => {\n    var _a;\n    const series = highlightedSeries || visibleSeries[0].series;\n    if (series.type === 'line' || isYThreshold(series)) {\n      const targetScaledSeries = scaledSeries.filter(it => it.series === series);\n      const previousPoint = highlightedPoint || targetScaledSeries[0];\n      const indexOfPreviousPoint = targetScaledSeries.map(it => it.x).indexOf(previousPoint.x);\n      const nextPointIndex = circleIndex(indexOfPreviousPoint + direction, [0, targetScaledSeries.length - 1]);\n      const nextPoint = targetScaledSeries[nextPointIndex];\n      setTargetX(((_a = nextPoint.datum) === null || _a === void 0 ? void 0 : _a.x) || null);\n      setXIndex(nextPointIndex);\n      highlightPoint(nextPoint);\n    } else if (series.type === 'bar') {\n      const xDomain = xScale.domain;\n      const MAX_GROUP_INDEX = xDomain.length - 1;\n      let nextGroupIndex = 0;\n      if (highlightedGroupIndex !== null) {\n        // find next group\n        nextGroupIndex = highlightedGroupIndex + direction;\n        if (nextGroupIndex > MAX_GROUP_INDEX) {\n          nextGroupIndex = 0;\n        } else if (nextGroupIndex < 0) {\n          nextGroupIndex = MAX_GROUP_INDEX;\n        }\n      }\n      const nextDomainIndex = nextValidDomainIndex(nextGroupIndex, barGroups, direction);\n      setTargetX(xDomain[nextDomainIndex]);\n      highlightGroup(nextDomainIndex);\n    }\n  }, [highlightedSeries, visibleSeries, scaledSeries, highlightedPoint, highlightPoint, xScale.domain, highlightedGroupIndex, barGroups, highlightGroup]);\n  const moveToLineGroupIndex = useCallback(index => {\n    var _a, _b, _c, _d;\n    const point = allUniqueX[index];\n    setXIndex(index);\n    setTargetX(((_a = point.datum) === null || _a === void 0 ? void 0 : _a.x) || null);\n    highlightX({\n      scaledX: (_b = point === null || point === void 0 ? void 0 : point.scaledX) !== null && _b !== void 0 ? _b : null,\n      label: (_d = (_c = point.datum) === null || _c === void 0 ? void 0 : _c.x) !== null && _d !== void 0 ? _d : null\n    });\n  }, [allUniqueX, highlightX]);\n  const moveWithinXAxis = useCallback(direction => {\n    if (highlightedSeries || isGroupNavigation) {\n      moveWithinSeries(direction);\n    } else {\n      const nextPointGroupIndex = circleIndex(xIndex + direction, [0, allUniqueX.length - 1]);\n      moveToLineGroupIndex(nextPointGroupIndex);\n    }\n  }, [highlightedSeries, isGroupNavigation, moveWithinSeries, xIndex, allUniqueX.length, moveToLineGroupIndex]);\n  const onKeyDown = useCallback(event => {\n    const keyCode = event.keyCode;\n    if (keyCode !== KeyCode.up && keyCode !== KeyCode.right && keyCode !== KeyCode.down && keyCode !== KeyCode.left && keyCode !== KeyCode.space && keyCode !== KeyCode.enter) {\n      return;\n    }\n    event.preventDefault();\n    if (isHandlersDisabled) {\n      return;\n    }\n    if (keyCode === KeyCode.down || keyCode === KeyCode.up) {\n      moveBetweenSeries(keyCode === KeyCode.down ? 1 : -1);\n    } else if (keyCode === KeyCode.left || keyCode === KeyCode.right) {\n      moveWithinXAxis(keyCode === KeyCode.right ? 1 : -1);\n    } else if (keyCode === KeyCode.enter || keyCode === KeyCode.space) {\n      pinPopover();\n    }\n  }, [isHandlersDisabled, moveBetweenSeries, moveWithinXAxis, pinPopover]);\n  return {\n    isGroupNavigation,\n    onFocus,\n    onKeyDown,\n    xIndex\n  };\n}\n// Returns given index if it is in range or the opposite range boundary otherwise.\nfunction circleIndex(index, _ref4) {\n  let [from, to] = _ref4;\n  if (index < from) {\n    return to;\n  }\n  if (index > to) {\n    return from;\n  }\n  return index;\n}","map":{"version":3,"mappings":"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","names":["useCallback","useMemo","useState","KeyCode","findNavigableSeries","isXThreshold","isYThreshold","nextValidDomainIndex","useNavigation","series","visibleSeries","scaledSeries","barGroups","xScale","yScale","highlightedPoint","highlightedGroupIndex","highlightedSeries","isHandlersDisabled","pinPopover","highlightSeries","highlightGroup","highlightPoint","highlightX","verticalMarkerX","targetX","setTargetX","xIndex","setXIndex","isGroupNavigation","some","type","navigableSeries","containsMultipleSeries","length","onBarGroupFocus","groupIndex","domain","onLineFocus","moveToLineGroupIndex","moveBetweenSeries","onFocus","allUniqueX","result","i","point","undefined","scaledX","x","push","datum","direction","xOffset","isCategorical","Math","max","d3Scale","bandwidth","MAX_SERIES_INDEX","previousSeriesIndex","indexOf","firstPossibleIndex","nextSeriesIndex","nextSeries","nextInternalSeries","filter","targetXPoint","NaN","isFinite","nextScaledSeries","it","closestNextSeriesPoint","reduce","prev","curr","abs","Infinity","y","color","scaledTargetIndex","map","range","moveWithinSeries","targetScaledSeries","previousPoint","indexOfPreviousPoint","nextPointIndex","circleIndex","nextPoint","xDomain","MAX_GROUP_INDEX","nextGroupIndex","nextDomainIndex","index","label","moveWithinXAxis","nextPointGroupIndex","onKeyDown","event","keyCode","up","right","down","left","space","enter","preventDefault","from","to"],"sources":["/Users/tangyizhi/Desktop/Assignment 2/frontend/node_modules/@cloudscape-design/components/mixed-line-bar-chart/hooks/lib/default/mixed-line-bar-chart/hooks/use-navigation.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport React, { useCallback, useMemo, useState } from 'react';\nimport { KeyCode } from '../../internal/keycode';\nimport { ChartContainerProps } from '../chart-container';\nimport { ChartDataTypes, MixedLineBarChartProps, VerticalMarkerX } from '../interfaces';\nimport { ChartScale, NumericChartScale } from '../../internal/components/cartesian-chart/scales';\nimport { findNavigableSeries, isXThreshold, isYThreshold, nextValidDomainIndex } from '../utils';\nimport { ScaledPoint } from '../make-scaled-series';\nimport { ScaledBarGroup } from '../make-scaled-bar-groups';\n\nexport type UseNavigationProps<T extends ChartDataTypes> = Pick<\n  ChartContainerProps<T>,\n  'highlightedSeries' | 'series' | 'visibleSeries'\n> & {\n  xScale: ChartScale;\n  yScale: NumericChartScale;\n  barGroups: ScaledBarGroup<T>[];\n  scaledSeries: ReadonlyArray<ScaledPoint<T>>;\n\n  highlightedPoint: ScaledPoint<T> | null;\n  highlightedGroupIndex: number | null;\n  isHandlersDisabled: boolean;\n\n  pinPopover(pinned?: boolean): void;\n  highlightSeries(series: MixedLineBarChartProps.ChartSeries<T> | null): void;\n  highlightGroup(groupIndex: number): void;\n  highlightPoint(point: ScaledPoint<T> | null): void;\n  highlightX: (verticalMarker: VerticalMarkerX<T> | null) => void;\n  clearHighlightedSeries(): void;\n  verticalMarkerX: VerticalMarkerX<T> | null;\n};\n\nexport function useNavigation<T extends ChartDataTypes>({\n  series,\n  visibleSeries,\n  scaledSeries,\n  barGroups,\n  xScale,\n  yScale,\n  highlightedPoint,\n  highlightedGroupIndex,\n  highlightedSeries,\n  isHandlersDisabled,\n  pinPopover,\n  highlightSeries,\n  highlightGroup,\n  highlightPoint,\n  highlightX,\n  verticalMarkerX,\n}: UseNavigationProps<T>) {\n  const [targetX, setTargetX] = useState<T | null>(null);\n  const [xIndex, setXIndex] = useState(0);\n\n  // There are two different types of navigation:\n  // 1) Group navigation for any chart that contains a bar series\n  // 2) Line navigation for any chart that only contains lines and thresholds\n  const isGroupNavigation = useMemo(() => visibleSeries.some(({ series }) => series.type === 'bar'), [visibleSeries]);\n\n  // Make a list of series that can be navigated between. Bar series are treated as one.\n  const { navigableSeries } = useMemo(() => findNavigableSeries(visibleSeries), [visibleSeries]);\n  const containsMultipleSeries = navigableSeries.length > 1;\n\n  const onBarGroupFocus = () => {\n    const groupIndex = highlightedGroupIndex ?? 0;\n    setTargetX((xScale.domain as T[])[groupIndex]);\n    highlightGroup(groupIndex);\n  };\n\n  const onLineFocus = () => {\n    if (verticalMarkerX === null) {\n      if (containsMultipleSeries) {\n        moveToLineGroupIndex(0);\n      } else {\n        moveBetweenSeries(0);\n      }\n    }\n  };\n\n  const onFocus = () => {\n    if (isGroupNavigation) {\n      onBarGroupFocus();\n    } else {\n      onLineFocus();\n    }\n  };\n\n  // Returns all the unique X coordinates in scaledSeries.\n  // Assumes scaledSeries is sorted by `x`.\n  const allUniqueX = useMemo(() => {\n    const result = [];\n    for (let i = 0; i < scaledSeries.length; i += 1) {\n      const point = scaledSeries[i];\n      if (point !== undefined && (!result.length || result[result.length - 1].scaledX !== point.x)) {\n        result.push({ scaledX: point.x, datum: point.datum });\n      }\n    }\n    return result;\n  }, [scaledSeries]);\n\n  const moveBetweenSeries = useCallback(\n    (direction: number) => {\n      if (isGroupNavigation) {\n        return;\n      }\n\n      const xOffset = xScale.isCategorical() ? Math.max(0, xScale.d3Scale.bandwidth() - 1) / 2 : 0;\n      const MAX_SERIES_INDEX = navigableSeries.length - 1;\n\n      // Find the index of the currently highlighted series (if any)\n      let previousSeriesIndex = -1;\n      if (highlightedSeries) {\n        previousSeriesIndex = navigableSeries.indexOf(highlightedSeries);\n      }\n\n      // Move forwards or backwards to the new series\n      // If index === -1, show all data points from all series at the given X instead of one single series\n      const firstPossibleIndex = containsMultipleSeries ? -1 : 0;\n      let nextSeriesIndex = 0;\n      if (previousSeriesIndex !== null) {\n        nextSeriesIndex = previousSeriesIndex + direction;\n        if (nextSeriesIndex > MAX_SERIES_INDEX) {\n          nextSeriesIndex = firstPossibleIndex;\n        } else if (nextSeriesIndex < firstPossibleIndex) {\n          nextSeriesIndex = MAX_SERIES_INDEX;\n        }\n      }\n      if (nextSeriesIndex === -1) {\n        highlightSeries(null);\n        highlightPoint(null);\n        return;\n      }\n      const nextSeries = navigableSeries[nextSeriesIndex];\n      const nextInternalSeries = series.filter(({ series }) => series === nextSeries)[0];\n\n      // 2. Find point in the next series\n      let targetXPoint = (xScale.d3Scale(targetX as any) ?? NaN) + xOffset;\n      if (!isFinite(targetXPoint)) {\n        targetXPoint = 0;\n      }\n\n      if (nextSeries.type === 'line') {\n        const nextScaledSeries = scaledSeries.filter(it => it.series === nextSeries);\n        const closestNextSeriesPoint = nextScaledSeries.reduce(\n          (prev, curr) => (Math.abs(curr.x - targetXPoint) < Math.abs(prev.x - targetXPoint) ? curr : prev),\n          { x: -Infinity, y: -Infinity }\n        );\n        highlightPoint({ ...closestNextSeriesPoint, color: nextInternalSeries.color, series: nextSeries });\n      } else if (isYThreshold(nextSeries)) {\n        const scaledTargetIndex = scaledSeries.map(it => it.datum?.x || null).indexOf(targetX);\n        highlightPoint({\n          x: targetXPoint,\n          y: yScale.d3Scale(nextSeries.y) ?? NaN,\n          color: nextInternalSeries.color,\n          series: nextSeries,\n          datum: scaledSeries[scaledTargetIndex]?.datum,\n        });\n      } else if (isXThreshold(nextSeries)) {\n        highlightPoint({\n          x: xScale.d3Scale(nextSeries.x as any) ?? NaN,\n          y: yScale.d3Scale.range()[0],\n          color: nextInternalSeries.color,\n          series: nextSeries,\n          datum: { x: nextSeries.x, y: NaN },\n        });\n      }\n    },\n    [\n      isGroupNavigation,\n      xScale,\n      navigableSeries,\n      highlightedSeries,\n      containsMultipleSeries,\n      highlightSeries,\n      highlightPoint,\n      series,\n      targetX,\n      scaledSeries,\n      yScale,\n    ]\n  );\n\n  const moveWithinSeries = useCallback(\n    (direction: number) => {\n      const series = highlightedSeries || visibleSeries[0].series;\n\n      if (series.type === 'line' || isYThreshold(series)) {\n        const targetScaledSeries = scaledSeries.filter(it => it.series === series);\n        const previousPoint = highlightedPoint || targetScaledSeries[0];\n        const indexOfPreviousPoint = targetScaledSeries.map(it => it.x).indexOf(previousPoint.x);\n        const nextPointIndex = circleIndex(indexOfPreviousPoint + direction, [0, targetScaledSeries.length - 1]);\n        const nextPoint = targetScaledSeries[nextPointIndex];\n\n        setTargetX(nextPoint.datum?.x || null);\n        setXIndex(nextPointIndex);\n        highlightPoint(nextPoint);\n      } else if (series.type === 'bar') {\n        const xDomain = xScale.domain as T[];\n        const MAX_GROUP_INDEX = xDomain.length - 1;\n\n        let nextGroupIndex = 0;\n        if (highlightedGroupIndex !== null) {\n          // find next group\n          nextGroupIndex = highlightedGroupIndex + direction;\n          if (nextGroupIndex > MAX_GROUP_INDEX) {\n            nextGroupIndex = 0;\n          } else if (nextGroupIndex < 0) {\n            nextGroupIndex = MAX_GROUP_INDEX;\n          }\n        }\n\n        const nextDomainIndex = nextValidDomainIndex(nextGroupIndex, barGroups, direction);\n        setTargetX(xDomain[nextDomainIndex]);\n        highlightGroup(nextDomainIndex);\n      }\n    },\n    [\n      highlightedSeries,\n      visibleSeries,\n      scaledSeries,\n      highlightedPoint,\n      highlightPoint,\n      xScale.domain,\n      highlightedGroupIndex,\n      barGroups,\n      highlightGroup,\n    ]\n  );\n\n  const moveToLineGroupIndex = useCallback(\n    (index: number) => {\n      const point = allUniqueX[index];\n      setXIndex(index);\n      setTargetX(point.datum?.x || null);\n      highlightX({ scaledX: point?.scaledX ?? null, label: point.datum?.x ?? null });\n    },\n    [allUniqueX, highlightX]\n  );\n\n  const moveWithinXAxis = useCallback(\n    (direction: number) => {\n      if (highlightedSeries || isGroupNavigation) {\n        moveWithinSeries(direction);\n      } else {\n        const nextPointGroupIndex = circleIndex(xIndex + direction, [0, allUniqueX.length - 1]);\n        moveToLineGroupIndex(nextPointGroupIndex);\n      }\n    },\n    [highlightedSeries, isGroupNavigation, moveWithinSeries, xIndex, allUniqueX.length, moveToLineGroupIndex]\n  );\n\n  const onKeyDown = useCallback(\n    (event: React.KeyboardEvent) => {\n      const keyCode = event.keyCode;\n      if (\n        keyCode !== KeyCode.up &&\n        keyCode !== KeyCode.right &&\n        keyCode !== KeyCode.down &&\n        keyCode !== KeyCode.left &&\n        keyCode !== KeyCode.space &&\n        keyCode !== KeyCode.enter\n      ) {\n        return;\n      }\n\n      event.preventDefault();\n\n      if (isHandlersDisabled) {\n        return;\n      }\n\n      if (keyCode === KeyCode.down || keyCode === KeyCode.up) {\n        moveBetweenSeries(keyCode === KeyCode.down ? 1 : -1);\n      } else if (keyCode === KeyCode.left || keyCode === KeyCode.right) {\n        moveWithinXAxis(keyCode === KeyCode.right ? 1 : -1);\n      } else if (keyCode === KeyCode.enter || keyCode === KeyCode.space) {\n        pinPopover();\n      }\n    },\n    [isHandlersDisabled, moveBetweenSeries, moveWithinXAxis, pinPopover]\n  );\n\n  return { isGroupNavigation, onFocus, onKeyDown, xIndex };\n}\n\n// Returns given index if it is in range or the opposite range boundary otherwise.\nfunction circleIndex(index: number, [from, to]: [number, number]): number {\n  if (index < from) {\n    return to;\n  }\n  if (index > to) {\n    return from;\n  }\n  return index;\n}\n"]},"metadata":{},"sourceType":"module"}