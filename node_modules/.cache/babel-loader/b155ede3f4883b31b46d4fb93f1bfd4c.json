{"ast":null,"code":"// A sufficiently small value.\n// The Number.EPSILON is not available in the target ECMA version.\n// See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON\nconst EPSILON = 0.0000000000001;\n// When x-domain is not set explicitly - guess it based on the available data.\nexport function computeDomainX(series) {\n  const xValues = getXValues(series);\n  if (xValues.length === 0) {\n    return [];\n  }\n  // Assuming categorical domain.\n  // In that case, all values are to be included.\n  if (typeof xValues[0] === 'string') {\n    return uniq(xValues);\n  }\n  // For non-categorical domain find min and max bounds.\n  return xValues.reduce((_ref, x) => {\n    let [min, max] = _ref;\n    return [x < min ? x : min, max < x ? x : max];\n  }, [xValues[0], xValues[0]]);\n}\n// When y-domain is not set explicitly - guess it based on the available data and series.\nexport function computeDomainY(series, scaleType) {\n  let min = Number.POSITIVE_INFINITY;\n  let max = Number.NEGATIVE_INFINITY;\n  // Find the min and max for threshold series.\n  series.forEach(s => {\n    if (s.type === 'threshold') {\n      min = Math.min(min, s.y);\n      max = Math.max(max, s.y);\n    }\n  });\n  // Find the min and max for area series considering their stacking.\n  getXValues(series).forEach((_, xIndex) => {\n    var _a;\n    // Maintains the prev stack level.\n    let stackY = scaleType === 'linear' ? 0 : EPSILON;\n    for (const s of series) {\n      if (s.type === 'area') {\n        stackY = stackY + (((_a = s.data[xIndex]) === null || _a === void 0 ? void 0 : _a.y) || 0);\n        min = Math.min(min, stackY);\n        max = Math.max(max, stackY);\n      }\n    }\n  });\n  // If min/max is not overridden than either series or series data is empty.\n  if (min === Number.POSITIVE_INFINITY) {\n    return [];\n  }\n  // Log scales can't start from 0, so, if possible, start from 1.\n  if (scaleType === 'log' && min === 0 && max > 1) {\n    return [1, max];\n  }\n  return [min, max];\n}\n// For given data, series and scales, compute all points and group them as\n// x:y, x:series and series:x to allow constant time access to the required point or subset.\nexport function computePlotPoints(series, xScale, yScale) {\n  const xValues = getXValues(series);\n  // Lookup for xy[xIndex][yIndex]\n  const xy = [];\n  // Lookup for xs[xIndex][seriesIndex]\n  const xs = [];\n  // Lookup for sx[seriesIndex][xIndex]\n  const sx = [];\n  // Filter out the data which is beyond the plot for whatever reason.\n  getVisibleData(xValues, xScale).forEach((_ref2, xIndex) => {\n    let {\n      x,\n      scaledX\n    } = _ref2;\n    // Maintains the prev stack level. Starting from epsilon to not break log scales.\n    let stackY = yScale.scaleType === 'linear' ? 0 : EPSILON;\n    // A column of series points related to the same x.\n    const points = [];\n    // Collect the points, leaving y-index as 0 for now.\n    series.forEach((s, sIndex) => {\n      var _a;\n      if (s.type === 'threshold') {\n        const scaledY = yScale.d3Scale(s.y) || 0;\n        points.push({\n          x: x,\n          y0: s.y,\n          y1: s.y,\n          scaled: {\n            x: scaledX,\n            y0: scaledY,\n            y1: scaledY\n          },\n          index: {\n            x: xIndex,\n            s: sIndex,\n            y: 0\n          },\n          value: 0\n        });\n      } else {\n        const value = ((_a = s.data[xIndex]) === null || _a === void 0 ? void 0 : _a.y) || 0;\n        const y0 = stackY;\n        const y1 = stackY + value;\n        points.push({\n          x: x,\n          y0: y0,\n          y1: y1,\n          scaled: {\n            x: scaledX,\n            y0: yScale.d3Scale(y0) || 0,\n            y1: yScale.d3Scale(y1) || 0\n          },\n          index: {\n            x: xIndex,\n            s: sIndex,\n            y: 0\n          },\n          value: value\n        });\n        stackY = y1;\n      }\n    });\n    // Sort points by y and insert the missing y-index.\n    points.sort((p1, p2) => p1.y1 - p2.y1).forEach((point, index) => {\n      point.index.y = index;\n      // Insert the points to the respective two-dimensional lookup arrays.\n      insertIntoMatrix(xy, point.index.x, point.index.y, point);\n      insertIntoMatrix(xs, point.index.x, point.index.s, point);\n      insertIntoMatrix(sx, point.index.s, point.index.x, point);\n    });\n  });\n  return {\n    xy,\n    xs,\n    sx\n  };\n}\n// Finds the closest point in the sorted array.\nexport function findClosest(sortedArray, target, getter) {\n  // The method guarantees to return a point hence empty arrays are not allowed.\n  if (sortedArray.length === 0) {\n    throw new Error('Invariant violation: array is empty.');\n  }\n  const isAscending = getter(sortedArray[0]) < getter(sortedArray[sortedArray.length - 1]);\n  const compare = x => isAscending ? getter(x) < target : getter(x) > target;\n  const delta = x => Math.abs(getter(x) - target);\n  // Use binary search to find the closest value in a sorted array.\n  let lo = 0;\n  let hi = sortedArray.length - 1;\n  while (hi - lo > 1) {\n    const mid = Math.floor((lo + hi) / 2);\n    if (compare(sortedArray[mid])) {\n      lo = mid;\n    } else {\n      hi = mid;\n    }\n  }\n  return delta(sortedArray[lo]) < delta(sortedArray[hi]) ? sortedArray[lo] : sortedArray[hi];\n}\n// Returns given index if it is in range or the opposite range boundary otherwise.\nexport function circleIndex(index, _ref3) {\n  let [from, to] = _ref3;\n  if (index < from) {\n    return to;\n  }\n  if (index > to) {\n    return from;\n  }\n  return index;\n}\n// Compares all x-values between series to ensure they are consistent.\nexport function isSeriesValid(series) {\n  var _a;\n  const sampleXValues = getXValues(series);\n  for (const s of series) {\n    if (s.type === 'area') {\n      for (let i = 0; i < Math.max(s.data.length, sampleXValues.length); i++) {\n        if (((_a = s.data[i]) === null || _a === void 0 ? void 0 : _a.x) !== sampleXValues[i]) {\n          return false;\n        }\n      }\n    }\n  }\n  return true;\n}\n// Takes first area series x-values as all data x-values are to match across series.\nfunction getXValues(series) {\n  for (const s of series) {\n    if (s.type === 'area') {\n      return s.data.map(_ref4 => {\n        let {\n          x\n        } = _ref4;\n        return x;\n      });\n    }\n  }\n  return [];\n}\n// Returns data that is visible in the given scale.\nfunction getVisibleData(data, xScale) {\n  const scaledOffsetX = xScale.isCategorical() ? Math.max(0, xScale.d3Scale.bandwidth() - 1) / 2 : 0;\n  const visibleData = [];\n  for (const x of data) {\n    const scaledX = xScale.d3Scale(x);\n    if (scaledX !== undefined) {\n      visibleData.push({\n        x,\n        scaledX: scaledX + scaledOffsetX\n      });\n    }\n  }\n  return visibleData;\n}\n// Inserts given value into a two-dimensional array.\nfunction insertIntoMatrix(matrix, row, col, value) {\n  if (!matrix[row]) {\n    matrix[row] = [];\n  }\n  matrix[row][col] = value;\n}\n// Creates new array with only unique elements of the given array.\nfunction uniq(arr) {\n  const set = new Set();\n  const uniqArray = [];\n  for (const value of arr) {\n    if (!set.has(value)) {\n      set.add(value);\n      uniqArray.push(value);\n    }\n  }\n  return uniqArray;\n}","map":{"version":3,"mappings":"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","names":["EPSILON","computeDomainX","series","xValues","getXValues","length","uniq","reduce","x","min","max","computeDomainY","scaleType","Number","POSITIVE_INFINITY","NEGATIVE_INFINITY","forEach","s","type","Math","y","_","xIndex","stackY","data","computePlotPoints","xScale","yScale","xy","xs","sx","getVisibleData","scaledX","points","sIndex","scaledY","d3Scale","push","y0","y1","scaled","index","value","sort","p1","p2","point","insertIntoMatrix","findClosest","sortedArray","target","getter","Error","isAscending","compare","delta","abs","lo","hi","mid","floor","circleIndex","from","to","isSeriesValid","sampleXValues","i","map","scaledOffsetX","isCategorical","bandwidth","visibleData","undefined","matrix","row","col","arr","set","Set","uniqArray","has","add"],"sources":["/Users/tangyizhi/Desktop/Assignment2/frontend/node_modules/@cloudscape-design/components/area-chart/model/lib/default/area-chart/model/utils.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { AreaChartProps } from '../interfaces';\nimport { ChartScale, NumericChartScale } from '../../internal/components/cartesian-chart/scales';\nimport { ChartDataTypes, XDomain, YDomain, YScaleType } from '../../internal/components/cartesian-chart/interfaces';\nimport { ChartModel } from './index';\n\n// A sufficiently small value.\n// The Number.EPSILON is not available in the target ECMA version.\n// See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON\nconst EPSILON = 0.0000000000001;\n\n// When x-domain is not set explicitly - guess it based on the available data.\nexport function computeDomainX<T extends ChartDataTypes>(series: readonly AreaChartProps.Series<T>[]): XDomain<T> {\n  const xValues = getXValues(series);\n\n  if (xValues.length === 0) {\n    return [] as unknown as XDomain<T>;\n  }\n\n  // Assuming categorical domain.\n  // In that case, all values are to be included.\n  if (typeof xValues[0] === 'string') {\n    return uniq(xValues) as unknown as XDomain<T>;\n  }\n\n  // For non-categorical domain find min and max bounds.\n  return xValues.reduce(\n    ([min, max], x) => [x < min ? x : min, max < x ? x : max],\n    [xValues[0], xValues[0]]\n  ) as unknown as XDomain<T>;\n}\n\n// When y-domain is not set explicitly - guess it based on the available data and series.\nexport function computeDomainY<T>(series: readonly AreaChartProps.Series<T>[], scaleType: YScaleType): YDomain {\n  let min = Number.POSITIVE_INFINITY;\n  let max = Number.NEGATIVE_INFINITY;\n\n  // Find the min and max for threshold series.\n  series.forEach(s => {\n    if (s.type === 'threshold') {\n      min = Math.min(min, s.y);\n      max = Math.max(max, s.y);\n    }\n  });\n\n  // Find the min and max for area series considering their stacking.\n  getXValues(series).forEach((_, xIndex) => {\n    // Maintains the prev stack level.\n    let stackY = scaleType === 'linear' ? 0 : EPSILON;\n\n    for (const s of series) {\n      if (s.type === 'area') {\n        stackY = stackY + (s.data[xIndex]?.y || 0);\n        min = Math.min(min, stackY);\n        max = Math.max(max, stackY);\n      }\n    }\n  });\n\n  // If min/max is not overridden than either series or series data is empty.\n  if (min === Number.POSITIVE_INFINITY) {\n    return [];\n  }\n\n  // Log scales can't start from 0, so, if possible, start from 1.\n  if (scaleType === 'log' && min === 0 && max > 1) {\n    return [1, max];\n  }\n\n  return [min, max];\n}\n\n// For given data, series and scales, compute all points and group them as\n// x:y, x:series and series:x to allow constant time access to the required point or subset.\nexport function computePlotPoints<T>(\n  series: readonly AreaChartProps.Series<T>[],\n  xScale: ChartScale,\n  yScale: NumericChartScale\n): {\n  xy: ChartModel.PlotPoint<T>[][];\n  xs: ChartModel.PlotPoint<T>[][];\n  sx: ChartModel.PlotPoint<T>[][];\n} {\n  const xValues = getXValues(series);\n\n  // Lookup for xy[xIndex][yIndex]\n  const xy: ChartModel.PlotPoint<T>[][] = [];\n  // Lookup for xs[xIndex][seriesIndex]\n  const xs: ChartModel.PlotPoint<T>[][] = [];\n  // Lookup for sx[seriesIndex][xIndex]\n  const sx: ChartModel.PlotPoint<T>[][] = [];\n\n  // Filter out the data which is beyond the plot for whatever reason.\n  getVisibleData(xValues, xScale).forEach(({ x, scaledX }, xIndex) => {\n    // Maintains the prev stack level. Starting from epsilon to not break log scales.\n    let stackY = yScale.scaleType === 'linear' ? 0 : EPSILON;\n\n    // A column of series points related to the same x.\n    const points: ChartModel.PlotPoint<T>[] = [];\n\n    // Collect the points, leaving y-index as 0 for now.\n    series.forEach((s, sIndex) => {\n      if (s.type === 'threshold') {\n        const scaledY = yScale.d3Scale(s.y) || 0;\n        points.push({\n          x: x,\n          y0: s.y,\n          y1: s.y,\n          scaled: { x: scaledX, y0: scaledY, y1: scaledY },\n          index: { x: xIndex, s: sIndex, y: 0 },\n          value: 0,\n        });\n      } else {\n        const value = s.data[xIndex]?.y || 0;\n        const y0 = stackY;\n        const y1 = stackY + value;\n        points.push({\n          x: x,\n          y0: y0,\n          y1: y1,\n          scaled: { x: scaledX, y0: yScale.d3Scale(y0) || 0, y1: yScale.d3Scale(y1) || 0 },\n          index: { x: xIndex, s: sIndex, y: 0 },\n          value: value,\n        });\n\n        stackY = y1;\n      }\n    });\n\n    // Sort points by y and insert the missing y-index.\n    points\n      .sort((p1, p2) => p1.y1 - p2.y1)\n      .forEach((point, index) => {\n        point.index.y = index;\n\n        // Insert the points to the respective two-dimensional lookup arrays.\n        insertIntoMatrix(xy, point.index.x, point.index.y, point);\n        insertIntoMatrix(xs, point.index.x, point.index.s, point);\n        insertIntoMatrix(sx, point.index.s, point.index.x, point);\n      });\n  });\n\n  return { xy, xs, sx };\n}\n\n// Finds the closest point in the sorted array.\nexport function findClosest<T>(sortedArray: readonly T[], target: number, getter: (item: T) => number): T {\n  // The method guarantees to return a point hence empty arrays are not allowed.\n  if (sortedArray.length === 0) {\n    throw new Error('Invariant violation: array is empty.');\n  }\n\n  const isAscending = getter(sortedArray[0]) < getter(sortedArray[sortedArray.length - 1]);\n  const compare = (x: T) => (isAscending ? getter(x) < target : getter(x) > target);\n  const delta = (x: T) => Math.abs(getter(x) - target);\n\n  // Use binary search to find the closest value in a sorted array.\n  let lo = 0;\n  let hi = sortedArray.length - 1;\n  while (hi - lo > 1) {\n    const mid = Math.floor((lo + hi) / 2);\n    if (compare(sortedArray[mid])) {\n      lo = mid;\n    } else {\n      hi = mid;\n    }\n  }\n  return delta(sortedArray[lo]) < delta(sortedArray[hi]) ? sortedArray[lo] : sortedArray[hi];\n}\n\n// Returns given index if it is in range or the opposite range boundary otherwise.\nexport function circleIndex(index: number, [from, to]: [number, number]): number {\n  if (index < from) {\n    return to;\n  }\n  if (index > to) {\n    return from;\n  }\n  return index;\n}\n\n// Compares all x-values between series to ensure they are consistent.\nexport function isSeriesValid<T>(series: readonly AreaChartProps.Series<T>[]) {\n  const sampleXValues = getXValues(series);\n\n  for (const s of series) {\n    if (s.type === 'area') {\n      for (let i = 0; i < Math.max(s.data.length, sampleXValues.length); i++) {\n        if (s.data[i]?.x !== sampleXValues[i]) {\n          return false;\n        }\n      }\n    }\n  }\n\n  return true;\n}\n\n// Takes first area series x-values as all data x-values are to match across series.\nfunction getXValues<T>(series: readonly AreaChartProps.Series<T>[]) {\n  for (const s of series) {\n    if (s.type === 'area') {\n      return s.data.map(({ x }) => x);\n    }\n  }\n\n  return [];\n}\n\n// Returns data that is visible in the given scale.\nfunction getVisibleData<T>(data: readonly T[], xScale: ChartScale) {\n  const scaledOffsetX = xScale.isCategorical() ? Math.max(0, xScale.d3Scale.bandwidth() - 1) / 2 : 0;\n\n  const visibleData = [];\n  for (const x of data) {\n    const scaledX = xScale.d3Scale(x as any);\n\n    if (scaledX !== undefined) {\n      visibleData.push({ x, scaledX: scaledX + scaledOffsetX });\n    }\n  }\n  return visibleData;\n}\n\n// Inserts given value into a two-dimensional array.\nfunction insertIntoMatrix<T>(matrix: T[][], row: number, col: number, value: T) {\n  if (!matrix[row]) {\n    matrix[row] = [];\n  }\n  matrix[row][col] = value;\n}\n\n// Creates new array with only unique elements of the given array.\nfunction uniq<T>(arr: readonly T[]): readonly T[] {\n  const set = new Set();\n  const uniqArray: T[] = [];\n\n  for (const value of arr) {\n    if (!set.has(value)) {\n      set.add(value);\n      uniqArray.push(value);\n    }\n  }\n\n  return uniqArray;\n}\n"]},"metadata":{},"sourceType":"module"}