{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { useState } from 'react';\nimport { fireNonCancelableEvent } from '../../internal/events';\nimport { useUniqueId } from '../../internal/hooks/use-unique-id';\nimport { getTrackableValue } from '../utils';\nimport { joinStrings } from '../../internal/utils/strings';\nimport { ItemSet } from './utils';\nexport function useSelection(_ref) {\n  let {\n    items,\n    selectedItems = [],\n    selectionType,\n    isItemDisabled = () => false,\n    trackBy,\n    onSelectionChange,\n    ariaLabels,\n    loading\n  } = _ref;\n  const [shiftPressed, setShiftPressed] = useState(false);\n  const [lastClickedItem, setLastClickedItem] = useState(null);\n  const selectionName = useUniqueId();\n  const finalSelectedItems = selectionType === 'single' ? selectedItems.slice(0, 1) : selectedItems;\n  const selectedSet = new ItemSet(trackBy, finalSelectedItems);\n  const itemIndexesMap = new Map();\n  items.forEach((item, i) => itemIndexesMap.set(getTrackableValue(trackBy, item), i));\n  const isItemSelected = selectedSet.has.bind(selectedSet);\n  const getItemState = item => ({\n    disabled: isItemDisabled(item),\n    selected: isItemSelected(item)\n  });\n  const [allDisabled, allEnabledSelected] = selectionType ? items.reduce((_ref2, item) => {\n    let [allDisabled, allEnabledSelected] = _ref2;\n    const {\n      disabled,\n      selected\n    } = getItemState(item);\n    return [\n    // all items are disabled (or none are present)\n    allDisabled && disabled,\n    // all enabled items are selected (or none are present)\n    allEnabledSelected && (selected || disabled)];\n  }, [true, true]) : [true, true];\n  // the page has at least one selected item\n  const hasSelected = finalSelectedItems.length > 0;\n  const handleToggleAll = () => {\n    const requestedItems = new ItemSet(trackBy, items);\n    const newSelectedItems = allEnabledSelected ? deselectItems(requestedItems) : selectItems(requestedItems);\n    fireNonCancelableEvent(onSelectionChange, {\n      selectedItems: newSelectedItems\n    });\n  };\n  const getRequestedItems = item => {\n    const requestedItems = new ItemSet(trackBy, [item]);\n    let lastClickedItemIndex = lastClickedItem ? itemIndexesMap.get(getTrackableValue(trackBy, lastClickedItem)) : -1;\n    if (lastClickedItemIndex === undefined) {\n      lastClickedItemIndex = -1;\n    }\n    // we use lastClickedItemIndex to determine if filtering/sorting/pagination\n    // made previously selected item invisible, therefore we reset state for shift-select\n    if (shiftPressed && lastClickedItemIndex !== -1) {\n      // item is always in items\n      const currentItemIndex = itemIndexesMap.get(getTrackableValue(trackBy, item));\n      const start = Math.min(currentItemIndex, lastClickedItemIndex);\n      const end = Math.max(currentItemIndex, lastClickedItemIndex);\n      items.slice(start, end + 1).forEach(item => requestedItems.put(item));\n    }\n    return requestedItems;\n  };\n  const deselectItems = requestedItems => {\n    const newSelectedItems = [];\n    selectedItems.forEach(selectedItem => {\n      const toUnselect = requestedItems.has(selectedItem);\n      if (!toUnselect || isItemDisabled(selectedItem)) {\n        newSelectedItems.push(selectedItem);\n      }\n    });\n    return newSelectedItems;\n  };\n  const selectItems = requestedItems => {\n    const newSelectedItems = [...selectedItems];\n    requestedItems.forEach(newItem => {\n      const {\n        selected,\n        disabled\n      } = getItemState(newItem);\n      if (!selected && !disabled) {\n        newSelectedItems.push(newItem);\n      }\n    });\n    return newSelectedItems;\n  };\n  const handleToggleItem = item => () => {\n    const {\n      disabled,\n      selected\n    } = getItemState(item);\n    if (disabled || selectionType === 'single' && selected) {\n      return;\n    }\n    if (selectionType === 'single') {\n      fireNonCancelableEvent(onSelectionChange, {\n        selectedItems: [item]\n      });\n    } else {\n      const requestedItems = getRequestedItems(item);\n      const selectedItems = selected ? deselectItems(requestedItems) : selectItems(requestedItems);\n      fireNonCancelableEvent(onSelectionChange, {\n        selectedItems\n      });\n      setLastClickedItem(item);\n    }\n  };\n  return {\n    isItemSelected,\n    getSelectAllProps: () => {\n      var _a;\n      if (!selectionType) {\n        throw new Error('Invariant violation: calling selection props with missing selection type.');\n      }\n      return {\n        name: selectionName,\n        disabled: allDisabled || !!loading,\n        selectionType: selectionType,\n        indeterminate: hasSelected && !allEnabledSelected,\n        checked: hasSelected && allEnabledSelected,\n        onChange: handleToggleAll,\n        ariaLabel: joinStrings(ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.selectionGroupLabel, (_a = ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.allItemsSelectionLabel) === null || _a === void 0 ? void 0 : _a.call(ariaLabels, {\n          selectedItems\n        }))\n      };\n    },\n    getItemSelectionProps: item => {\n      var _a;\n      if (!selectionType) {\n        throw new Error('Invariant violation: calling selection props with missing selection type.');\n      }\n      return {\n        name: selectionName,\n        selectionType: selectionType,\n        ariaLabel: joinStrings(ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.selectionGroupLabel, (_a = ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.itemSelectionLabel) === null || _a === void 0 ? void 0 : _a.call(ariaLabels, {\n          selectedItems\n        }, item)),\n        onChange: handleToggleItem(item),\n        checked: isItemSelected(item),\n        disabled: isItemDisabled(item)\n      };\n    },\n    updateShiftToggle: value => {\n      setShiftPressed(value);\n    }\n  };\n}","map":{"version":3,"mappings":"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","names":["useState","fireNonCancelableEvent","useUniqueId","getTrackableValue","joinStrings","ItemSet","useSelection","items","selectedItems","selectionType","isItemDisabled","trackBy","onSelectionChange","ariaLabels","loading","shiftPressed","setShiftPressed","lastClickedItem","setLastClickedItem","selectionName","finalSelectedItems","slice","selectedSet","itemIndexesMap","Map","forEach","item","i","set","isItemSelected","has","bind","getItemState","disabled","selected","allDisabled","allEnabledSelected","reduce","hasSelected","length","handleToggleAll","requestedItems","newSelectedItems","deselectItems","selectItems","getRequestedItems","lastClickedItemIndex","get","undefined","currentItemIndex","start","Math","min","end","max","put","selectedItem","toUnselect","push","newItem","handleToggleItem","getSelectAllProps","Error","name","indeterminate","checked","onChange","ariaLabel","selectionGroupLabel","allItemsSelectionLabel","getItemSelectionProps","itemSelectionLabel","updateShiftToggle","value"],"sources":["/Users/tangyizhi/Desktop/Assignment2/frontend/node_modules/@cloudscape-design/components/table/selection/lib/default/table/selection/use-selection.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { useState } from 'react';\nimport { fireNonCancelableEvent } from '../../internal/events';\nimport { useUniqueId } from '../../internal/hooks/use-unique-id';\nimport { TableProps } from '../interfaces';\nimport { getTrackableValue } from '../utils';\nimport { joinStrings } from '../../internal/utils/strings';\nimport { SelectionProps } from './interfaces';\nimport { ItemSet } from './utils';\n\nexport function useSelection<T>({\n  items,\n  selectedItems = [],\n  selectionType,\n  isItemDisabled = () => false,\n  trackBy,\n  onSelectionChange,\n  ariaLabels,\n  loading,\n}: Pick<\n  TableProps<T>,\n  | 'ariaLabels'\n  | 'items'\n  | 'selectedItems'\n  | 'selectionType'\n  | 'isItemDisabled'\n  | 'trackBy'\n  | 'onSelectionChange'\n  | 'loading'\n>) {\n  const [shiftPressed, setShiftPressed] = useState(false);\n  const [lastClickedItem, setLastClickedItem] = useState<T | null>(null);\n  const selectionName = useUniqueId();\n  const finalSelectedItems = selectionType === 'single' ? selectedItems.slice(0, 1) : selectedItems;\n  const selectedSet = new ItemSet(trackBy, finalSelectedItems);\n  const itemIndexesMap = new Map();\n  items.forEach((item, i) => itemIndexesMap.set(getTrackableValue(trackBy, item), i));\n  const isItemSelected = selectedSet.has.bind(selectedSet);\n  const getItemState = (item: T) => ({\n    disabled: isItemDisabled(item),\n    selected: isItemSelected(item),\n  });\n  const [allDisabled, allEnabledSelected] = selectionType\n    ? items.reduce(\n        ([allDisabled, allEnabledSelected], item) => {\n          const { disabled, selected } = getItemState(item);\n          return [\n            // all items are disabled (or none are present)\n            allDisabled && disabled,\n            // all enabled items are selected (or none are present)\n            allEnabledSelected && (selected || disabled),\n          ];\n        },\n        [true, true]\n      )\n    : [true, true];\n\n  // the page has at least one selected item\n  const hasSelected = finalSelectedItems.length > 0;\n\n  const handleToggleAll = () => {\n    const requestedItems = new ItemSet(trackBy, items);\n    const newSelectedItems = allEnabledSelected ? deselectItems(requestedItems) : selectItems(requestedItems);\n    fireNonCancelableEvent(onSelectionChange, { selectedItems: newSelectedItems });\n  };\n\n  const getRequestedItems = (item: T) => {\n    const requestedItems = new ItemSet(trackBy, [item]);\n    let lastClickedItemIndex = lastClickedItem ? itemIndexesMap.get(getTrackableValue(trackBy, lastClickedItem)) : -1;\n    if (lastClickedItemIndex === undefined) {\n      lastClickedItemIndex = -1;\n    }\n    // we use lastClickedItemIndex to determine if filtering/sorting/pagination\n    // made previously selected item invisible, therefore we reset state for shift-select\n    if (shiftPressed && lastClickedItemIndex !== -1) {\n      // item is always in items\n      const currentItemIndex = itemIndexesMap.get(getTrackableValue(trackBy, item)) as number;\n      const start = Math.min(currentItemIndex, lastClickedItemIndex);\n      const end = Math.max(currentItemIndex, lastClickedItemIndex);\n      items.slice(start, end + 1).forEach(item => requestedItems.put(item));\n    }\n    return requestedItems;\n  };\n\n  const deselectItems = (requestedItems: ItemSet<T>) => {\n    const newSelectedItems: Array<T> = [];\n    selectedItems.forEach(selectedItem => {\n      const toUnselect = requestedItems.has(selectedItem);\n      if (!toUnselect || isItemDisabled(selectedItem)) {\n        newSelectedItems.push(selectedItem);\n      }\n    });\n    return newSelectedItems;\n  };\n\n  const selectItems = (requestedItems: ItemSet<T>) => {\n    const newSelectedItems = [...selectedItems];\n    requestedItems.forEach(newItem => {\n      const { selected, disabled } = getItemState(newItem);\n      if (!selected && !disabled) {\n        newSelectedItems.push(newItem);\n      }\n    });\n    return newSelectedItems;\n  };\n\n  const handleToggleItem = (item: T) => () => {\n    const { disabled, selected } = getItemState(item);\n    if (disabled || (selectionType === 'single' && selected)) {\n      return;\n    }\n    if (selectionType === 'single') {\n      fireNonCancelableEvent(onSelectionChange, { selectedItems: [item] });\n    } else {\n      const requestedItems = getRequestedItems(item);\n      const selectedItems = selected ? deselectItems(requestedItems) : selectItems(requestedItems);\n      fireNonCancelableEvent(onSelectionChange, { selectedItems });\n      setLastClickedItem(item);\n    }\n  };\n\n  return {\n    isItemSelected,\n    getSelectAllProps: (): SelectionProps => {\n      if (!selectionType) {\n        throw new Error('Invariant violation: calling selection props with missing selection type.');\n      }\n      return {\n        name: selectionName,\n        disabled: allDisabled || !!loading,\n        selectionType: selectionType,\n        indeterminate: hasSelected && !allEnabledSelected,\n        checked: hasSelected && allEnabledSelected,\n        onChange: handleToggleAll,\n        ariaLabel: joinStrings(\n          ariaLabels?.selectionGroupLabel,\n          ariaLabels?.allItemsSelectionLabel?.({ selectedItems })\n        ),\n      };\n    },\n    getItemSelectionProps: (item: T): SelectionProps => {\n      if (!selectionType) {\n        throw new Error('Invariant violation: calling selection props with missing selection type.');\n      }\n      return {\n        name: selectionName,\n        selectionType: selectionType,\n        ariaLabel: joinStrings(\n          ariaLabels?.selectionGroupLabel,\n          ariaLabels?.itemSelectionLabel?.({ selectedItems }, item)\n        ),\n        onChange: handleToggleItem(item),\n        checked: isItemSelected(item),\n        disabled: isItemDisabled(item),\n      };\n    },\n    updateShiftToggle: (value: boolean) => {\n      setShiftPressed(value);\n    },\n  };\n}\n"]},"metadata":{},"sourceType":"module"}