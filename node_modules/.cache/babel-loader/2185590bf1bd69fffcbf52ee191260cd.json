{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport React, { useCallback, useEffect, useImperativeHandle, useRef, useState } from 'react';\nimport { useMergeRefs } from '../../hooks/use-merge-refs';\nimport TabTrap from '../tab-trap/index';\nimport { getFirstFocusable, getLastFocusable } from './utils';\nfunction FocusLock(_ref, ref) {\n  let {\n    className,\n    disabled,\n    autoFocus,\n    restoreFocus,\n    children\n  } = _ref;\n  const returnFocusToRef = useRef(null);\n  const containerRef = useRef(null);\n  const focusFirst = () => {\n    var _a;\n    if (containerRef.current) {\n      (_a = getFirstFocusable(containerRef.current)) === null || _a === void 0 ? void 0 : _a.focus();\n    }\n  };\n  const focusLast = () => {\n    var _a;\n    if (containerRef.current) {\n      (_a = getLastFocusable(containerRef.current)) === null || _a === void 0 ? void 0 : _a.focus();\n    }\n  };\n  // Captures focus when `autoFocus` is set, and the component is mounted or\n  // `disabled` changes from true to false.\n  useEffect(() => {\n    if (autoFocus && !disabled) {\n      returnFocusToRef.current = document.activeElement;\n      focusFirst();\n    }\n  }, [autoFocus, disabled]);\n  // Restore focus if `restoreFocus` is set, and `disabled` changes from false\n  // to true.\n  const [previouslyDisabled, setPreviouslyDisabled] = useState(!!disabled);\n  useEffect(() => {\n    var _a;\n    if (previouslyDisabled !== !!disabled) {\n      setPreviouslyDisabled(!!disabled);\n      if (restoreFocus && disabled) {\n        (_a = returnFocusToRef.current) === null || _a === void 0 ? void 0 : _a.focus();\n        returnFocusToRef.current = null;\n      }\n    }\n  }, [previouslyDisabled, disabled, restoreFocus]);\n  // Restore focus if `restoreFocus` is set and the component is unmounted.\n  // Using a callback ref for this is safer than using useEffect cleanups.\n  const restoreFocusHandler = useCallback(elem => {\n    var _a;\n    if (elem === null && restoreFocus) {\n      (_a = returnFocusToRef.current) === null || _a === void 0 ? void 0 : _a.focus();\n      returnFocusToRef.current = null;\n    }\n  }, [restoreFocus]);\n  useImperativeHandle(ref, () => ({\n    focusFirst\n  }));\n  const mergedRef = useMergeRefs(containerRef, restoreFocusHandler);\n  return React.createElement(React.Fragment, null, React.createElement(TabTrap, {\n    disabled: disabled,\n    focusNextCallback: focusLast\n  }), React.createElement(\"div\", {\n    className: className,\n    ref: mergedRef\n  }, children), React.createElement(TabTrap, {\n    disabled: disabled,\n    focusNextCallback: focusFirst\n  }));\n}\nexport default React.forwardRef(FocusLock);","map":{"version":3,"mappings":"AAAA;AACA;AACA,OAAOA,KAAK,IAAIC,WAAW,EAAEC,SAAS,EAAEC,mBAAmB,EAAEC,MAAM,EAAEC,QAAQ,QAAQ,OAAO;AAC5F,SAASC,YAAY,QAAQ,4BAA4B;AAEzD,OAAOC,OAAO,MAAM,mBAAmB;AACvC,SAASC,iBAAiB,EAAEC,gBAAgB,QAAQ,SAAS;AAiB7D,SAASC,SAAS,OAEhBC,GAA4B;EAAA,IAD5B;IAAEC,SAAS;IAAEC,QAAQ;IAAEC,SAAS;IAAEC,YAAY;IAAEC;EAAQ,CAAkB;EAG1E,MAAMC,gBAAgB,GAAGb,MAAM,CAA0B,IAAI,CAAC;EAC9D,MAAMc,YAAY,GAAGd,MAAM,CAAwB,IAAI,CAAC;EAExD,MAAMe,UAAU,GAAG,MAAK;;IACtB,IAAID,YAAY,CAACE,OAAO,EAAE;MACxB,uBAAiB,CAACF,YAAY,CAACE,OAAO,CAAC,0CAAEC,KAAK,EAAE;;EAEpD,CAAC;EAED,MAAMC,SAAS,GAAG,MAAK;;IACrB,IAAIJ,YAAY,CAACE,OAAO,EAAE;MACxB,sBAAgB,CAACF,YAAY,CAACE,OAAO,CAAC,0CAAEC,KAAK,EAAE;;EAEnD,CAAC;EAED;EACA;EACAnB,SAAS,CAAC,MAAK;IACb,IAAIY,SAAS,IAAI,CAACD,QAAQ,EAAE;MAC1BI,gBAAgB,CAACG,OAAO,GAAGG,QAAQ,CAACC,aAAwC;MAC5EL,UAAU,EAAE;;EAEhB,CAAC,EAAE,CAACL,SAAS,EAAED,QAAQ,CAAC,CAAC;EAEzB;EACA;EACA,MAAM,CAACY,kBAAkB,EAAEC,qBAAqB,CAAC,GAAGrB,QAAQ,CAAC,CAAC,CAACQ,QAAQ,CAAC;EACxEX,SAAS,CAAC,MAAK;;IACb,IAAIuB,kBAAkB,KAAK,CAAC,CAACZ,QAAQ,EAAE;MACrCa,qBAAqB,CAAC,CAAC,CAACb,QAAQ,CAAC;MACjC,IAAIE,YAAY,IAAIF,QAAQ,EAAE;QAC5B,sBAAgB,CAACO,OAAO,0CAAEC,KAAK,EAAE;QACjCJ,gBAAgB,CAACG,OAAO,GAAG,IAAI;;;EAGrC,CAAC,EAAE,CAACK,kBAAkB,EAAEZ,QAAQ,EAAEE,YAAY,CAAC,CAAC;EAEhD;EACA;EACA,MAAMY,mBAAmB,GAAG1B,WAAW,CACpC2B,IAA2B,IAAI;;IAC9B,IAAIA,IAAI,KAAK,IAAI,IAAIb,YAAY,EAAE;MACjC,sBAAgB,CAACK,OAAO,0CAAEC,KAAK,EAAE;MACjCJ,gBAAgB,CAACG,OAAO,GAAG,IAAI;;EAEnC,CAAC,EACD,CAACL,YAAY,CAAC,CACf;EAEDZ,mBAAmB,CAACQ,GAAG,EAAE,OAAO;IAAEQ;EAAU,CAAE,CAAC,CAAC;EAChD,MAAMU,SAAS,GAAGvB,YAAY,CAACY,YAAY,EAAES,mBAAmB,CAAC;EAEjE,OACE3B,0CACEA,oBAACO,OAAO;IAACM,QAAQ,EAAEA,QAAQ;IAAEiB,iBAAiB,EAAER;EAAS,EAAI,EAC7DtB;IAAKY,SAAS,EAAEA,SAAS;IAAED,GAAG,EAAEkB;EAAS,GACtCb,QAAQ,CACL,EACNhB,oBAACO,OAAO;IAACM,QAAQ,EAAEA,QAAQ;IAAEiB,iBAAiB,EAAEX;EAAU,EAAI,CAC7D;AAEP;AAEA,eAAenB,KAAK,CAAC+B,UAAU,CAACrB,SAAS,CAAC","names":["React","useCallback","useEffect","useImperativeHandle","useRef","useState","useMergeRefs","TabTrap","getFirstFocusable","getLastFocusable","FocusLock","ref","className","disabled","autoFocus","restoreFocus","children","returnFocusToRef","containerRef","focusFirst","current","focus","focusLast","document","activeElement","previouslyDisabled","setPreviouslyDisabled","restoreFocusHandler","elem","mergedRef","focusNextCallback","forwardRef"],"sources":["/Users/tangyizhi/Desktop/Assignment2/frontend/node_modules/@cloudscape-design/components/internal/components/focus-lock/lib/default/internal/components/focus-lock/index.tsx"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport React, { useCallback, useEffect, useImperativeHandle, useRef, useState } from 'react';\nimport { useMergeRefs } from '../../hooks/use-merge-refs';\n\nimport TabTrap from '../tab-trap/index';\nimport { getFirstFocusable, getLastFocusable } from './utils';\n\nexport interface FocusLockProps {\n  className?: string;\n  disabled?: boolean;\n  autoFocus?: boolean;\n  restoreFocus?: boolean;\n  children: React.ReactNode;\n}\n\nexport interface FocusLockRef {\n  /**\n   * Focuses the first element in the component.\n   */\n  focusFirst(): void;\n}\n\nfunction FocusLock(\n  { className, disabled, autoFocus, restoreFocus, children }: FocusLockProps,\n  ref: React.Ref<FocusLockRef>\n) {\n  const returnFocusToRef = useRef<HTMLOrSVGElement | null>(null);\n  const containerRef = useRef<HTMLDivElement | null>(null);\n\n  const focusFirst = () => {\n    if (containerRef.current) {\n      getFirstFocusable(containerRef.current)?.focus();\n    }\n  };\n\n  const focusLast = () => {\n    if (containerRef.current) {\n      getLastFocusable(containerRef.current)?.focus();\n    }\n  };\n\n  // Captures focus when `autoFocus` is set, and the component is mounted or\n  // `disabled` changes from true to false.\n  useEffect(() => {\n    if (autoFocus && !disabled) {\n      returnFocusToRef.current = document.activeElement as HTMLOrSVGElement | null;\n      focusFirst();\n    }\n  }, [autoFocus, disabled]);\n\n  // Restore focus if `restoreFocus` is set, and `disabled` changes from false\n  // to true.\n  const [previouslyDisabled, setPreviouslyDisabled] = useState(!!disabled);\n  useEffect(() => {\n    if (previouslyDisabled !== !!disabled) {\n      setPreviouslyDisabled(!!disabled);\n      if (restoreFocus && disabled) {\n        returnFocusToRef.current?.focus();\n        returnFocusToRef.current = null;\n      }\n    }\n  }, [previouslyDisabled, disabled, restoreFocus]);\n\n  // Restore focus if `restoreFocus` is set and the component is unmounted.\n  // Using a callback ref for this is safer than using useEffect cleanups.\n  const restoreFocusHandler = useCallback(\n    (elem: HTMLDivElement | null) => {\n      if (elem === null && restoreFocus) {\n        returnFocusToRef.current?.focus();\n        returnFocusToRef.current = null;\n      }\n    },\n    [restoreFocus]\n  );\n\n  useImperativeHandle(ref, () => ({ focusFirst }));\n  const mergedRef = useMergeRefs(containerRef, restoreFocusHandler);\n\n  return (\n    <>\n      <TabTrap disabled={disabled} focusNextCallback={focusLast} />\n      <div className={className} ref={mergedRef}>\n        {children}\n      </div>\n      <TabTrap disabled={disabled} focusNextCallback={focusFirst} />\n    </>\n  );\n}\n\nexport default React.forwardRef(FocusLock);\n"]},"metadata":{},"sourceType":"module"}