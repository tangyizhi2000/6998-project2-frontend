{"ast":null,"code":"import _classCallCheck from \"/Users/tangyizhi/Desktop/Assignment2/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/tangyizhi/Desktop/Assignment2/frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/Users/tangyizhi/Desktop/Assignment2/frontend/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/tangyizhi/Desktop/Assignment2/frontend/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { useCallback, useEffect, useMemo, useRef } from 'react';\nimport AsyncStore from '../../area-chart/async-store';\nimport clsx from 'clsx';\nimport { useResizeObserver, useStableCallback } from '@cloudscape-design/component-toolkit/internal';\nimport { isCellStatesEqual, isWrapperStatesEqual, updateCellOffsets } from './utils';\n// We allow the table to have a minimum of 148px of available space besides the sum of the widths of the sticky columns\n// This value is an UX recommendation and is approximately 1/3 of our smallest breakpoint (465px)\nvar MINIMUM_SCROLLABLE_SPACE = 148;\nexport function useStickyColumns(_ref) {\n  var visibleColumns = _ref.visibleColumns,\n    stickyColumnsFirst = _ref.stickyColumnsFirst,\n    stickyColumnsLast = _ref.stickyColumnsLast;\n  var store = useMemo(function () {\n    return new StickyColumnsStore();\n  }, []);\n  var wrapperRef = useRef(null);\n  var tableRef = useRef(null);\n  var cellsRef = useRef({});\n  var hasStickyColumns = stickyColumnsFirst + stickyColumnsLast > 0;\n  var updateStickyStyles = useStableCallback(function () {\n    if (wrapperRef.current && tableRef.current) {\n      store.updateCellStyles({\n        wrapper: wrapperRef.current,\n        table: tableRef.current,\n        cells: cellsRef.current,\n        visibleColumns: visibleColumns,\n        stickyColumnsFirst: stickyColumnsFirst,\n        stickyColumnsLast: stickyColumnsLast\n      });\n    }\n  });\n  useResizeObserver(wrapperRef, updateStickyStyles);\n  useResizeObserver(tableRef, updateStickyStyles);\n  useEffect(function () {\n    if (wrapperRef.current && tableRef.current) {\n      store.updateCellStyles({\n        wrapper: wrapperRef.current,\n        table: tableRef.current,\n        cells: cellsRef.current,\n        visibleColumns: visibleColumns,\n        stickyColumnsFirst: stickyColumnsFirst,\n        stickyColumnsLast: stickyColumnsLast\n      });\n    }\n  }, [store, stickyColumnsFirst, stickyColumnsLast, visibleColumns]);\n  // Update wrapper styles imperatively to avoid unnecessary re-renders.\n  useEffect(function () {\n    if (!hasStickyColumns) {\n      return;\n    }\n    var selector = function selector(state) {\n      return state.wrapperState;\n    };\n    var updateWrapperStyles = function updateWrapperStyles(state, prev) {\n      if (isWrapperStatesEqual(state, prev)) {\n        return;\n      }\n      if (wrapperRef.current) {\n        wrapperRef.current.style.scrollPaddingLeft = state.scrollPaddingLeft + 'px';\n        wrapperRef.current.style.scrollPaddingRight = state.scrollPaddingRight + 'px';\n      }\n    };\n    var unsubscribe = store.subscribe(selector, function (newState, prevState) {\n      return updateWrapperStyles(selector(newState), selector(prevState));\n    });\n    return unsubscribe;\n  }, [store, hasStickyColumns]);\n  var setWrapper = useCallback(function (node) {\n    if (wrapperRef.current) {\n      wrapperRef.current.removeEventListener('scroll', updateStickyStyles);\n    }\n    if (node && hasStickyColumns) {\n      node.addEventListener('scroll', updateStickyStyles);\n    }\n    wrapperRef.current = node;\n  }, [hasStickyColumns, updateStickyStyles]);\n  var setTable = useCallback(function (node) {\n    tableRef.current = node;\n  }, []);\n  var setCell = useCallback(function (columnId, node) {\n    if (node) {\n      cellsRef.current[columnId] = node;\n    } else {\n      delete cellsRef.current[columnId];\n    }\n  }, []);\n  return {\n    store: store,\n    style: {\n      // Provide wrapper styles as props so that a re-render won't cause invalidation.\n      wrapper: hasStickyColumns ? Object.assign({}, store.get().wrapperState) : undefined\n    },\n    refs: {\n      wrapper: setWrapper,\n      table: setTable,\n      cell: setCell\n    }\n  };\n}\nexport function useStickyCellStyles(_ref2) {\n  var stickyColumns = _ref2.stickyColumns,\n    columnId = _ref2.columnId,\n    getClassName = _ref2.getClassName;\n  var _a;\n  var setCell = stickyColumns.refs.cell;\n  // unsubscribeRef to hold the function to unsubscribe from the store's updates\n  var unsubscribeRef = useRef(null);\n  // refCallback updates the cell ref and sets up the store subscription\n  var refCallback = useCallback(function (cellElement) {\n    if (unsubscribeRef.current) {\n      // Unsubscribe before we do any updates to avoid leaving any subscriptions hanging\n      unsubscribeRef.current();\n    }\n    // Update cellRef and the store's state to point to the new DOM node\n    setCell(columnId, cellElement);\n    // Update cell styles imperatively to avoid unnecessary re-renders.\n    var selector = function selector(state) {\n      return state.cellState[columnId];\n    };\n    var updateCellStyles = function updateCellStyles(state, prev) {\n      if (isCellStatesEqual(state, prev)) {\n        return;\n      }\n      var className = getClassName(state);\n      if (cellElement) {\n        Object.keys(className).forEach(function (key) {\n          if (className[key]) {\n            cellElement.classList.add(key);\n          } else {\n            cellElement.classList.remove(key);\n          }\n        });\n        cellElement.style.left = (state === null || state === void 0 ? void 0 : state.offset.left) !== undefined ? \"\".concat(state.offset.left, \"px\") : '';\n        cellElement.style.right = (state === null || state === void 0 ? void 0 : state.offset.right) !== undefined ? \"\".concat(state.offset.right, \"px\") : '';\n      }\n    };\n    // If the node is not null (i.e., the table cell is being mounted or updated, not unmounted),\n    // set up a new subscription to the store's updates\n    if (cellElement) {\n      unsubscribeRef.current = stickyColumns.store.subscribe(selector, function (newState, prevState) {\n        updateCellStyles(selector(newState), selector(prevState));\n      });\n    }\n  },\n  // getClassName is expected to be pure\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  [columnId, setCell, stickyColumns.store]);\n  // Provide cell styles as props so that a re-render won't cause invalidation.\n  var cellStyles = stickyColumns.store.get().cellState[columnId];\n  return {\n    ref: refCallback,\n    className: cellStyles ? clsx(getClassName(cellStyles)) : undefined,\n    style: (_a = cellStyles === null || cellStyles === void 0 ? void 0 : cellStyles.offset) !== null && _a !== void 0 ? _a : undefined\n  };\n}\nvar StickyColumnsStore = /*#__PURE__*/function (_AsyncStore) {\n  _inherits(StickyColumnsStore, _AsyncStore);\n  var _super = _createSuper(StickyColumnsStore);\n  function StickyColumnsStore() {\n    var _this;\n    _classCallCheck(this, StickyColumnsStore);\n    _this = _super.call(this, {\n      cellState: {},\n      wrapperState: {\n        scrollPaddingLeft: 0,\n        scrollPaddingRight: 0\n      }\n    });\n    _this.cellOffsets = {\n      offsets: new Map(),\n      stickyWidthLeft: 0,\n      stickyWidthRight: 0\n    };\n    _this.isStuckToTheLeft = false;\n    _this.isStuckToTheRight = false;\n    _this.padLeft = false;\n    _this.generateCellStyles = function (props) {\n      var isEnabled = _this.isEnabled(props);\n      var lastLeftStickyColumnIndex = props.stickyColumnsFirst - 1;\n      var lastRightStickyColumnIndex = props.visibleColumns.length - props.stickyColumnsLast;\n      return props.visibleColumns.reduce(function (acc, columnId, index) {\n        var _a, _b, _c, _d;\n        var stickySide = 'non-sticky';\n        if (index < props.stickyColumnsFirst) {\n          stickySide = 'left';\n        } else if (index >= props.visibleColumns.length - props.stickyColumnsLast) {\n          stickySide = 'right';\n        }\n        if (!isEnabled || stickySide === 'non-sticky') {\n          acc[columnId] = null;\n          return acc;\n        }\n        // Determine the offset of the sticky column using the `cellOffsets` state object\n        var isFirstColumn = index === 0;\n        var stickyColumnOffsetLeft = (_b = (_a = _this.cellOffsets.offsets.get(columnId)) === null || _a === void 0 ? void 0 : _a.first) !== null && _b !== void 0 ? _b : 0;\n        var stickyColumnOffsetRight = (_d = (_c = _this.cellOffsets.offsets.get(columnId)) === null || _c === void 0 ? void 0 : _c.last) !== null && _d !== void 0 ? _d : 0;\n        acc[columnId] = {\n          padLeft: isFirstColumn && _this.padLeft,\n          lastLeft: _this.isStuckToTheLeft && lastLeftStickyColumnIndex === index,\n          lastRight: _this.isStuckToTheRight && lastRightStickyColumnIndex === index,\n          offset: {\n            left: stickySide === 'left' ? stickyColumnOffsetLeft : undefined,\n            right: stickySide === 'right' ? stickyColumnOffsetRight : undefined\n          }\n        };\n        return acc;\n      }, {});\n    };\n    _this.updateCellOffsets = function (props) {\n      _this.cellOffsets = updateCellOffsets(props.cells, props);\n    };\n    _this.isEnabled = function (props) {\n      var noStickyColumns = props.stickyColumnsFirst + props.stickyColumnsLast === 0;\n      if (noStickyColumns) {\n        return false;\n      }\n      var wrapperWidth = props.wrapper.getBoundingClientRect().width;\n      var tableWidth = props.table.getBoundingClientRect().width;\n      var isWrapperScrollable = tableWidth > wrapperWidth;\n      if (!isWrapperScrollable) {\n        return false;\n      }\n      var totalStickySpace = _this.cellOffsets.stickyWidthLeft + _this.cellOffsets.stickyWidthRight;\n      var tablePaddingLeft = parseFloat(getComputedStyle(props.table).paddingLeft) || 0;\n      var tablePaddingRight = parseFloat(getComputedStyle(props.table).paddingRight) || 0;\n      var hasEnoughScrollableSpace = totalStickySpace + MINIMUM_SCROLLABLE_SPACE + tablePaddingLeft + tablePaddingRight < wrapperWidth;\n      if (!hasEnoughScrollableSpace) {\n        return false;\n      }\n      return true;\n    };\n    return _this;\n  }\n  _createClass(StickyColumnsStore, [{\n    key: \"updateCellStyles\",\n    value: function updateCellStyles(props) {\n      var _this2 = this;\n      var hasStickyColumns = props.stickyColumnsFirst + props.stickyColumnsLast > 0;\n      var hadStickyColumns = this.cellOffsets.offsets.size > 0;\n      if (hasStickyColumns || hadStickyColumns) {\n        this.updateScroll(props);\n        this.updateCellOffsets(props);\n        this.set(function () {\n          return {\n            cellState: _this2.generateCellStyles(props),\n            wrapperState: {\n              scrollPaddingLeft: _this2.cellOffsets.stickyWidthLeft,\n              scrollPaddingRight: _this2.cellOffsets.stickyWidthRight\n            }\n          };\n        });\n      }\n    }\n  }, {\n    key: \"updateScroll\",\n    value: function updateScroll(props) {\n      var wrapperScrollLeft = props.wrapper.scrollLeft;\n      var wrapperScrollWidth = props.wrapper.scrollWidth;\n      var wrapperClientWidth = props.wrapper.clientWidth;\n      var tablePaddingLeft = parseFloat(getComputedStyle(props.table).paddingLeft) || 0;\n      var tablePaddingRight = parseFloat(getComputedStyle(props.table).paddingRight) || 0;\n      this.isStuckToTheLeft = wrapperScrollLeft > tablePaddingLeft;\n      // Math.ceil() is used here to address an edge-case in certain browsers, where they return non-integer wrapperScrollLeft values\n      // which are lower than expected (sub-pixel difference), resulting in the table always being in the \"stuck to the right\" state\n      this.isStuckToTheRight = Math.ceil(wrapperScrollLeft) < wrapperScrollWidth - wrapperClientWidth - tablePaddingRight;\n      this.padLeft = tablePaddingLeft !== 0 && this.isStuckToTheLeft;\n    }\n  }]);\n  return StickyColumnsStore;\n}(AsyncStore);\nexport { StickyColumnsStore as default };","map":{"version":3,"mappings":"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","names":["useCallback","useEffect","useMemo","useRef","AsyncStore","clsx","useResizeObserver","useStableCallback","isCellStatesEqual","isWrapperStatesEqual","updateCellOffsets","MINIMUM_SCROLLABLE_SPACE","useStickyColumns","visibleColumns","stickyColumnsFirst","stickyColumnsLast","store","StickyColumnsStore","wrapperRef","tableRef","cellsRef","hasStickyColumns","updateStickyStyles","current","updateCellStyles","wrapper","table","cells","selector","state","wrapperState","updateWrapperStyles","prev","style","scrollPaddingLeft","scrollPaddingRight","unsubscribe","subscribe","newState","prevState","setWrapper","node","removeEventListener","addEventListener","setTable","setCell","columnId","Object","get","undefined","refs","cell","useStickyCellStyles","stickyColumns","getClassName","unsubscribeRef","refCallback","cellElement","cellState","className","keys","forEach","key","classList","add","remove","left","offset","right","cellStyles","ref","offsets","Map","stickyWidthLeft","stickyWidthRight","props","isEnabled","lastLeftStickyColumnIndex","lastRightStickyColumnIndex","length","reduce","acc","index","stickySide","isFirstColumn","stickyColumnOffsetLeft","cellOffsets","first","stickyColumnOffsetRight","last","padLeft","lastLeft","isStuckToTheLeft","lastRight","isStuckToTheRight","noStickyColumns","wrapperWidth","getBoundingClientRect","width","tableWidth","isWrapperScrollable","totalStickySpace","tablePaddingLeft","parseFloat","getComputedStyle","paddingLeft","tablePaddingRight","paddingRight","hasEnoughScrollableSpace","hadStickyColumns","size","updateScroll","set","generateCellStyles","wrapperScrollLeft","scrollLeft","wrapperScrollWidth","scrollWidth","wrapperClientWidth","clientWidth","Math","ceil"],"sources":["/Users/tangyizhi/Desktop/Assignment2/frontend/node_modules/@cloudscape-design/components/table/sticky-columns/lib/default/table/sticky-columns/use-sticky-columns.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport React, { useCallback, useEffect, useMemo, useRef } from 'react';\nimport AsyncStore, { ReadonlyAsyncStore } from '../../area-chart/async-store';\nimport clsx from 'clsx';\nimport { useResizeObserver, useStableCallback } from '@cloudscape-design/component-toolkit/internal';\nimport {\n  CellOffsets,\n  StickyColumnsCellState,\n  StickyColumnsProps,\n  StickyColumnsState,\n  StickyColumnsWrapperState,\n} from './interfaces';\nimport { isCellStatesEqual, isWrapperStatesEqual, updateCellOffsets } from './utils';\n\n// We allow the table to have a minimum of 148px of available space besides the sum of the widths of the sticky columns\n// This value is an UX recommendation and is approximately 1/3 of our smallest breakpoint (465px)\nconst MINIMUM_SCROLLABLE_SPACE = 148;\n\nexport interface StickyColumnsModel {\n  store: ReadonlyAsyncStore<StickyColumnsState>;\n  style: {\n    wrapper?: React.CSSProperties;\n  };\n  refs: {\n    table: React.RefCallback<HTMLElement>;\n    wrapper: React.RefCallback<HTMLElement>;\n    cell: (columnId: PropertyKey, node: null | HTMLElement) => void;\n  };\n}\n\nexport function useStickyColumns({\n  visibleColumns,\n  stickyColumnsFirst,\n  stickyColumnsLast,\n}: StickyColumnsProps): StickyColumnsModel {\n  const store = useMemo(() => new StickyColumnsStore(), []);\n  const wrapperRef = useRef<HTMLElement>(null) as React.MutableRefObject<null | HTMLElement>;\n  const tableRef = useRef<HTMLElement>(null) as React.MutableRefObject<null | HTMLElement>;\n  const cellsRef = useRef<Record<PropertyKey, HTMLElement>>({});\n\n  const hasStickyColumns = stickyColumnsFirst + stickyColumnsLast > 0;\n\n  const updateStickyStyles = useStableCallback(() => {\n    if (wrapperRef.current && tableRef.current) {\n      store.updateCellStyles({\n        wrapper: wrapperRef.current,\n        table: tableRef.current,\n        cells: cellsRef.current,\n        visibleColumns,\n        stickyColumnsFirst,\n        stickyColumnsLast,\n      });\n    }\n  });\n\n  useResizeObserver(wrapperRef, updateStickyStyles);\n\n  useResizeObserver(tableRef, updateStickyStyles);\n\n  useEffect(() => {\n    if (wrapperRef.current && tableRef.current) {\n      store.updateCellStyles({\n        wrapper: wrapperRef.current,\n        table: tableRef.current,\n        cells: cellsRef.current,\n        visibleColumns,\n        stickyColumnsFirst,\n        stickyColumnsLast,\n      });\n    }\n  }, [store, stickyColumnsFirst, stickyColumnsLast, visibleColumns]);\n\n  // Update wrapper styles imperatively to avoid unnecessary re-renders.\n  useEffect(() => {\n    if (!hasStickyColumns) {\n      return;\n    }\n\n    const selector = (state: StickyColumnsState) => state.wrapperState;\n\n    const updateWrapperStyles = (state: StickyColumnsWrapperState, prev: StickyColumnsWrapperState) => {\n      if (isWrapperStatesEqual(state, prev)) {\n        return;\n      }\n\n      if (wrapperRef.current) {\n        wrapperRef.current.style.scrollPaddingLeft = state.scrollPaddingLeft + 'px';\n        wrapperRef.current.style.scrollPaddingRight = state.scrollPaddingRight + 'px';\n      }\n    };\n\n    const unsubscribe = store.subscribe(selector, (newState, prevState) =>\n      updateWrapperStyles(selector(newState), selector(prevState))\n    );\n    return unsubscribe;\n  }, [store, hasStickyColumns]);\n\n  const setWrapper = useCallback(\n    (node: null | HTMLElement) => {\n      if (wrapperRef.current) {\n        wrapperRef.current.removeEventListener('scroll', updateStickyStyles);\n      }\n      if (node && hasStickyColumns) {\n        node.addEventListener('scroll', updateStickyStyles);\n      }\n      wrapperRef.current = node;\n    },\n    [hasStickyColumns, updateStickyStyles]\n  );\n\n  const setTable = useCallback((node: null | HTMLElement) => {\n    tableRef.current = node;\n  }, []);\n\n  const setCell = useCallback((columnId: PropertyKey, node: null | HTMLElement) => {\n    if (node) {\n      cellsRef.current[columnId] = node;\n    } else {\n      delete cellsRef.current[columnId];\n    }\n  }, []);\n\n  return {\n    store,\n    style: {\n      // Provide wrapper styles as props so that a re-render won't cause invalidation.\n      wrapper: hasStickyColumns ? { ...store.get().wrapperState } : undefined,\n    },\n    refs: { wrapper: setWrapper, table: setTable, cell: setCell },\n  };\n}\n\ninterface UseStickyCellStylesProps {\n  stickyColumns: StickyColumnsModel;\n  columnId: PropertyKey;\n  getClassName: (styles: null | StickyColumnsCellState) => Record<string, boolean>;\n}\n\ninterface StickyCellStyles {\n  ref: React.RefCallback<HTMLElement>;\n  className?: string;\n  style?: React.CSSProperties;\n}\n\nexport function useStickyCellStyles({\n  stickyColumns,\n  columnId,\n  getClassName,\n}: UseStickyCellStylesProps): StickyCellStyles {\n  const setCell = stickyColumns.refs.cell;\n\n  // unsubscribeRef to hold the function to unsubscribe from the store's updates\n  const unsubscribeRef = useRef<null | (() => void)>(null);\n\n  // refCallback updates the cell ref and sets up the store subscription\n  const refCallback = useCallback(\n    cellElement => {\n      if (unsubscribeRef.current) {\n        // Unsubscribe before we do any updates to avoid leaving any subscriptions hanging\n        unsubscribeRef.current();\n      }\n\n      // Update cellRef and the store's state to point to the new DOM node\n      setCell(columnId, cellElement);\n\n      // Update cell styles imperatively to avoid unnecessary re-renders.\n      const selector = (state: StickyColumnsState) => state.cellState[columnId];\n\n      const updateCellStyles = (state: null | StickyColumnsCellState, prev: null | StickyColumnsCellState) => {\n        if (isCellStatesEqual(state, prev)) {\n          return;\n        }\n\n        const className = getClassName(state);\n        if (cellElement) {\n          Object.keys(className).forEach(key => {\n            if (className[key]) {\n              cellElement.classList.add(key);\n            } else {\n              cellElement.classList.remove(key);\n            }\n          });\n          cellElement.style.left = state?.offset.left !== undefined ? `${state.offset.left}px` : '';\n          cellElement.style.right = state?.offset.right !== undefined ? `${state.offset.right}px` : '';\n        }\n      };\n\n      // If the node is not null (i.e., the table cell is being mounted or updated, not unmounted),\n      // set up a new subscription to the store's updates\n      if (cellElement) {\n        unsubscribeRef.current = stickyColumns.store.subscribe(selector, (newState, prevState) => {\n          updateCellStyles(selector(newState), selector(prevState));\n        });\n      }\n    },\n\n    // getClassName is expected to be pure\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [columnId, setCell, stickyColumns.store]\n  );\n\n  // Provide cell styles as props so that a re-render won't cause invalidation.\n  const cellStyles = stickyColumns.store.get().cellState[columnId];\n  return {\n    ref: refCallback,\n    className: cellStyles ? clsx(getClassName(cellStyles)) : undefined,\n    style: cellStyles?.offset ?? undefined,\n  };\n}\n\ninterface UpdateCellStylesProps {\n  wrapper: HTMLElement;\n  table: HTMLElement;\n  cells: Record<PropertyKey, HTMLElement>;\n  visibleColumns: readonly PropertyKey[];\n  stickyColumnsFirst: number;\n  stickyColumnsLast: number;\n}\n\nexport default class StickyColumnsStore extends AsyncStore<StickyColumnsState> {\n  private cellOffsets: CellOffsets = {\n    offsets: new Map(),\n    stickyWidthLeft: 0,\n    stickyWidthRight: 0,\n  };\n  private isStuckToTheLeft = false;\n  private isStuckToTheRight = false;\n  private padLeft = false;\n\n  constructor() {\n    super({ cellState: {}, wrapperState: { scrollPaddingLeft: 0, scrollPaddingRight: 0 } });\n  }\n\n  public updateCellStyles(props: UpdateCellStylesProps) {\n    const hasStickyColumns = props.stickyColumnsFirst + props.stickyColumnsLast > 0;\n    const hadStickyColumns = this.cellOffsets.offsets.size > 0;\n\n    if (hasStickyColumns || hadStickyColumns) {\n      this.updateScroll(props);\n      this.updateCellOffsets(props);\n      this.set(() => ({\n        cellState: this.generateCellStyles(props),\n        wrapperState: {\n          scrollPaddingLeft: this.cellOffsets.stickyWidthLeft,\n          scrollPaddingRight: this.cellOffsets.stickyWidthRight,\n        },\n      }));\n    }\n  }\n\n  private updateScroll(props: UpdateCellStylesProps) {\n    const wrapperScrollLeft = props.wrapper.scrollLeft;\n    const wrapperScrollWidth = props.wrapper.scrollWidth;\n    const wrapperClientWidth = props.wrapper.clientWidth;\n    const tablePaddingLeft = parseFloat(getComputedStyle(props.table).paddingLeft) || 0;\n    const tablePaddingRight = parseFloat(getComputedStyle(props.table).paddingRight) || 0;\n\n    this.isStuckToTheLeft = wrapperScrollLeft > tablePaddingLeft;\n\n    // Math.ceil() is used here to address an edge-case in certain browsers, where they return non-integer wrapperScrollLeft values\n    // which are lower than expected (sub-pixel difference), resulting in the table always being in the \"stuck to the right\" state\n    this.isStuckToTheRight = Math.ceil(wrapperScrollLeft) < wrapperScrollWidth - wrapperClientWidth - tablePaddingRight;\n\n    this.padLeft = tablePaddingLeft !== 0 && this.isStuckToTheLeft;\n  }\n\n  private generateCellStyles = (props: UpdateCellStylesProps): Record<PropertyKey, null | StickyColumnsCellState> => {\n    const isEnabled = this.isEnabled(props);\n    const lastLeftStickyColumnIndex = props.stickyColumnsFirst - 1;\n    const lastRightStickyColumnIndex = props.visibleColumns.length - props.stickyColumnsLast;\n\n    return props.visibleColumns.reduce((acc, columnId, index) => {\n      let stickySide = 'non-sticky';\n      if (index < props.stickyColumnsFirst) {\n        stickySide = 'left';\n      } else if (index >= props.visibleColumns.length - props.stickyColumnsLast) {\n        stickySide = 'right';\n      }\n\n      if (!isEnabled || stickySide === 'non-sticky') {\n        acc[columnId] = null;\n        return acc;\n      }\n\n      // Determine the offset of the sticky column using the `cellOffsets` state object\n      const isFirstColumn = index === 0;\n      const stickyColumnOffsetLeft = this.cellOffsets.offsets.get(columnId)?.first ?? 0;\n      const stickyColumnOffsetRight = this.cellOffsets.offsets.get(columnId)?.last ?? 0;\n\n      acc[columnId] = {\n        padLeft: isFirstColumn && this.padLeft,\n        lastLeft: this.isStuckToTheLeft && lastLeftStickyColumnIndex === index,\n        lastRight: this.isStuckToTheRight && lastRightStickyColumnIndex === index,\n        offset: {\n          left: stickySide === 'left' ? stickyColumnOffsetLeft : undefined,\n          right: stickySide === 'right' ? stickyColumnOffsetRight : undefined,\n        },\n      };\n      return acc;\n    }, {} as Record<PropertyKey, null | StickyColumnsCellState>);\n  };\n\n  private updateCellOffsets = (props: UpdateCellStylesProps): void => {\n    this.cellOffsets = updateCellOffsets(props.cells, props);\n  };\n\n  private isEnabled = (props: UpdateCellStylesProps): boolean => {\n    const noStickyColumns = props.stickyColumnsFirst + props.stickyColumnsLast === 0;\n    if (noStickyColumns) {\n      return false;\n    }\n\n    const wrapperWidth = props.wrapper.getBoundingClientRect().width;\n    const tableWidth = props.table.getBoundingClientRect().width;\n    const isWrapperScrollable = tableWidth > wrapperWidth;\n    if (!isWrapperScrollable) {\n      return false;\n    }\n\n    const totalStickySpace = this.cellOffsets.stickyWidthLeft + this.cellOffsets.stickyWidthRight;\n    const tablePaddingLeft = parseFloat(getComputedStyle(props.table).paddingLeft) || 0;\n    const tablePaddingRight = parseFloat(getComputedStyle(props.table).paddingRight) || 0;\n    const hasEnoughScrollableSpace =\n      totalStickySpace + MINIMUM_SCROLLABLE_SPACE + tablePaddingLeft + tablePaddingRight < wrapperWidth;\n    if (!hasEnoughScrollableSpace) {\n      return false;\n    }\n\n    return true;\n  };\n}\n"]},"metadata":{},"sourceType":"module"}