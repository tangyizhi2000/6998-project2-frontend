{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { Position } from \"../utils/position\";\nexport function sortGridItems(items) {\n  return items.sort((a, b) => b.y - a.y === 0 ? b.x - a.x : b.y - a.y);\n}\nexport function normalizeMovePath(origin, path) {\n  path = normalizePathOrigin(origin, path);\n  // Store last visited indexes per position.\n  const positionToLastIndex = new Map();\n  for (let index = 0; index < path.length; index++) {\n    positionToLastIndex.set(`${path[index].x}:${path[index].y}`, index);\n  }\n  // Compose path from last visited indices only.\n  const normalizedPath = [];\n  let index = 0;\n  while (index < path.length) {\n    const lastVisitedIndex = positionToLastIndex.get(`${path[index].x}:${path[index].y}`);\n    normalizedPath.push(path[lastVisitedIndex]);\n    index = lastVisitedIndex + 1;\n  }\n  return normalizePathSteps(origin, normalizedPath);\n}\nexport function normalizeResizePath(origin, path) {\n  path = normalizePathOrigin(origin, path);\n  if (path.length === 0) {\n    return [];\n  }\n  const normalizedPath = [path[path.length - 1]];\n  for (let stepIndex = path.length - 2; stepIndex >= 0; stepIndex--) {\n    const prev = normalizedPath[normalizedPath.length - 1];\n    const current = path[stepIndex];\n    if (current.x < prev.x || current.y < prev.y) {\n      normalizedPath.push(current);\n    }\n  }\n  normalizedPath.reverse();\n  return normalizePathSteps(origin, normalizedPath);\n}\nexport function createMove(type, item, next) {\n  let score = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  const distanceX = type === \"RESIZE\" ? next.x - item.width : next.x - item.x;\n  const distanceY = type === \"RESIZE\" ? next.y - item.height : next.y - item.y;\n  return {\n    type,\n    itemId: item.id,\n    x: type !== \"RESIZE\" ? next.x : item.x,\n    y: type !== \"RESIZE\" ? next.y : item.y,\n    width: type === \"RESIZE\" ? next.x : item.width,\n    height: type === \"RESIZE\" ? next.y : item.height,\n    direction: distanceX > 0 ? \"right\" : distanceX < 0 ? \"left\" : distanceY < 0 ? \"up\" : \"down\",\n    distanceX,\n    distanceY,\n    score\n  };\n}\nexport function getMoveOriginalRect(move) {\n  return {\n    left: move.x - move.distanceX,\n    right: move.x - move.distanceX + move.width - 1,\n    top: move.y - move.distanceY,\n    bottom: move.y - move.distanceY + move.height - 1\n  };\n}\nexport function getMoveRect(move) {\n  return {\n    left: move.x,\n    right: move.x + move.width - 1,\n    top: move.y,\n    bottom: move.y + move.height - 1\n  };\n}\nexport function checkItemsIntersection(i1, i2) {\n  if (i1.id === i2.id) {\n    return false;\n  }\n  return i1.x <= i2.x + i2.width - 1 && i2.x <= i1.x + i1.width - 1 && i1.y <= i2.y + i2.height - 1 && i2.y <= i1.y + i1.height - 1;\n}\nexport function checkOppositeDirections(d1, d2) {\n  return d1 === \"down\" && d2 === \"up\" || d1 === \"up\" && d2 === \"down\" || d1 === \"left\" && d2 === \"right\" || d1 === \"right\" && d2 === \"left\";\n}\n// Removes path prefixes that return to the original location.\nfunction normalizePathOrigin(origin, path) {\n  let lastOriginIndex = -1;\n  for (let i = 0; i < path.length; i++) {\n    if (path[i].x === origin.x && path[i].y === origin.y) {\n      lastOriginIndex = i;\n    }\n  }\n  return path.slice(lastOriginIndex + 1);\n}\n// Ensures path only includes single-length steps.\nfunction normalizePathSteps(origin, path) {\n  const normalizedPath = [];\n  let prevX = origin.x;\n  let prevY = origin.y;\n  for (const step of path) {\n    const vx = Math.sign(step.x - prevX);\n    const vy = Math.sign(step.y - prevY);\n    for (let x = prevX, y = prevY; x !== step.x || y !== step.y;) {\n      if (x !== step.x) {\n        x += vx;\n      } else {\n        y += vy;\n      }\n      normalizedPath.push(new Position({\n        x,\n        y\n      }));\n    }\n    prevX = step.x;\n    prevY = step.y;\n  }\n  return normalizedPath;\n}","map":{"version":3,"names":["Position","sortGridItems","items","sort","a","b","y","x","normalizeMovePath","origin","path","normalizePathOrigin","positionToLastIndex","Map","index","length","set","normalizedPath","lastVisitedIndex","get","push","normalizePathSteps","normalizeResizePath","stepIndex","prev","current","reverse","createMove","type","item","next","score","distanceX","width","distanceY","height","itemId","id","direction","getMoveOriginalRect","move","left","right","top","bottom","getMoveRect","checkItemsIntersection","i1","i2","checkOppositeDirections","d1","d2","lastOriginIndex","i","slice","prevX","prevY","step","vx","Math","sign","vy"],"sources":["/Users/tangyizhi/Desktop/Assignment 2/frontend/node_modules/@cloudscape-design/board-components/internal/layout-engine/utils.js"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { Position } from \"../utils/position\";\nexport function sortGridItems(items) {\n    return items.sort((a, b) => (b.y - a.y === 0 ? b.x - a.x : b.y - a.y));\n}\nexport function normalizeMovePath(origin, path) {\n    path = normalizePathOrigin(origin, path);\n    // Store last visited indexes per position.\n    const positionToLastIndex = new Map();\n    for (let index = 0; index < path.length; index++) {\n        positionToLastIndex.set(`${path[index].x}:${path[index].y}`, index);\n    }\n    // Compose path from last visited indices only.\n    const normalizedPath = [];\n    let index = 0;\n    while (index < path.length) {\n        const lastVisitedIndex = positionToLastIndex.get(`${path[index].x}:${path[index].y}`);\n        normalizedPath.push(path[lastVisitedIndex]);\n        index = lastVisitedIndex + 1;\n    }\n    return normalizePathSteps(origin, normalizedPath);\n}\nexport function normalizeResizePath(origin, path) {\n    path = normalizePathOrigin(origin, path);\n    if (path.length === 0) {\n        return [];\n    }\n    const normalizedPath = [path[path.length - 1]];\n    for (let stepIndex = path.length - 2; stepIndex >= 0; stepIndex--) {\n        const prev = normalizedPath[normalizedPath.length - 1];\n        const current = path[stepIndex];\n        if (current.x < prev.x || current.y < prev.y) {\n            normalizedPath.push(current);\n        }\n    }\n    normalizedPath.reverse();\n    return normalizePathSteps(origin, normalizedPath);\n}\nexport function createMove(type, item, next, score = 0) {\n    const distanceX = type === \"RESIZE\" ? next.x - item.width : next.x - item.x;\n    const distanceY = type === \"RESIZE\" ? next.y - item.height : next.y - item.y;\n    return {\n        type,\n        itemId: item.id,\n        x: type !== \"RESIZE\" ? next.x : item.x,\n        y: type !== \"RESIZE\" ? next.y : item.y,\n        width: type === \"RESIZE\" ? next.x : item.width,\n        height: type === \"RESIZE\" ? next.y : item.height,\n        direction: distanceX > 0 ? \"right\" : distanceX < 0 ? \"left\" : distanceY < 0 ? \"up\" : \"down\",\n        distanceX,\n        distanceY,\n        score,\n    };\n}\nexport function getMoveOriginalRect(move) {\n    return {\n        left: move.x - move.distanceX,\n        right: move.x - move.distanceX + move.width - 1,\n        top: move.y - move.distanceY,\n        bottom: move.y - move.distanceY + move.height - 1,\n    };\n}\nexport function getMoveRect(move) {\n    return {\n        left: move.x,\n        right: move.x + move.width - 1,\n        top: move.y,\n        bottom: move.y + move.height - 1,\n    };\n}\nexport function checkItemsIntersection(i1, i2) {\n    if (i1.id === i2.id) {\n        return false;\n    }\n    return (i1.x <= i2.x + i2.width - 1 &&\n        i2.x <= i1.x + i1.width - 1 &&\n        i1.y <= i2.y + i2.height - 1 &&\n        i2.y <= i1.y + i1.height - 1);\n}\nexport function checkOppositeDirections(d1, d2) {\n    return ((d1 === \"down\" && d2 === \"up\") ||\n        (d1 === \"up\" && d2 === \"down\") ||\n        (d1 === \"left\" && d2 === \"right\") ||\n        (d1 === \"right\" && d2 === \"left\"));\n}\n// Removes path prefixes that return to the original location.\nfunction normalizePathOrigin(origin, path) {\n    let lastOriginIndex = -1;\n    for (let i = 0; i < path.length; i++) {\n        if (path[i].x === origin.x && path[i].y === origin.y) {\n            lastOriginIndex = i;\n        }\n    }\n    return path.slice(lastOriginIndex + 1);\n}\n// Ensures path only includes single-length steps.\nfunction normalizePathSteps(origin, path) {\n    const normalizedPath = [];\n    let prevX = origin.x;\n    let prevY = origin.y;\n    for (const step of path) {\n        const vx = Math.sign(step.x - prevX);\n        const vy = Math.sign(step.y - prevY);\n        for (let x = prevX, y = prevY; x !== step.x || y !== step.y;) {\n            if (x !== step.x) {\n                x += vx;\n            }\n            else {\n                y += vy;\n            }\n            normalizedPath.push(new Position({ x, y }));\n        }\n        prevX = step.x;\n        prevY = step.y;\n    }\n    return normalizedPath;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}