{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n// Finds the longest property the filtering text starts from.\nexport function matchFilteringProperty(filteringProperties, filteringText) {\n  let maxLength = 0;\n  let matchedProperty = null;\n  for (const property of filteringProperties) {\n    if (property.propertyLabel.length >= maxLength && startsWith(filteringText, property.propertyLabel) || property.propertyLabel.length > maxLength && startsWith(filteringText.toLowerCase(), property.propertyLabel.toLowerCase())) {\n      maxLength = property.propertyLabel.length;\n      matchedProperty = property;\n    }\n  }\n  return matchedProperty;\n}\n// Finds the longest operator the filtering text starts from.\nexport function matchOperator(allowedOperators, filteringText) {\n  filteringText = filteringText.toLowerCase();\n  let maxLength = 0;\n  let matchedOperator = null;\n  for (const operator of allowedOperators) {\n    if (operator.length > maxLength && startsWith(filteringText, operator.toLowerCase())) {\n      maxLength = operator.length;\n      matchedOperator = operator;\n    }\n  }\n  return matchedOperator;\n}\n// Finds if the filtering text matches any operator prefix.\nexport function matchOperatorPrefix(allowedOperators, filteringText) {\n  if (filteringText.trim().length === 0) {\n    return '';\n  }\n  for (const operator of allowedOperators) {\n    if (startsWith(operator.toLowerCase(), filteringText.toLowerCase())) {\n      return filteringText;\n    }\n  }\n  return null;\n}\nexport function matchTokenValue(_ref, filteringOptions) {\n  let {\n    property,\n    operator,\n    value\n  } = _ref;\n  var _a, _b;\n  const propertyOptions = filteringOptions.filter(option => option.property === property);\n  const bestMatch = {\n    propertyKey: property === null || property === void 0 ? void 0 : property.propertyKey,\n    operator,\n    value\n  };\n  for (const option of propertyOptions) {\n    if (option.label && option.label === value || !option.label && option.value === value) {\n      // exact match found: return it\n      return {\n        propertyKey: property === null || property === void 0 ? void 0 : property.propertyKey,\n        operator,\n        value: option.value\n      };\n    }\n    // By default, the token value is a string, but when a custom property is used,\n    // the token value can be any, therefore we need to check for its type before calling toLowerCase()\n    if (typeof value === 'string' && value.toLowerCase() === ((_b = (_a = option.label) !== null && _a !== void 0 ? _a : option.value) !== null && _b !== void 0 ? _b : '').toLowerCase()) {\n      // non-exact match: save and keep running in case exact match found later\n      bestMatch.value = option.value;\n    }\n  }\n  return bestMatch;\n}\nexport function getFormattedToken(token) {\n  var _a;\n  const valueFormatter = (_a = token.property) === null || _a === void 0 ? void 0 : _a.getValueFormatter(token.operator);\n  const propertyLabel = token.property && token.property.propertyLabel;\n  const tokenValue = valueFormatter ? valueFormatter(token.value) : token.value;\n  const label = `${propertyLabel !== null && propertyLabel !== void 0 ? propertyLabel : ''} ${token.operator} ${tokenValue}`;\n  return {\n    property: propertyLabel !== null && propertyLabel !== void 0 ? propertyLabel : '',\n    operator: token.operator,\n    value: tokenValue,\n    label\n  };\n}\nexport function trimStart(source) {\n  let spacesLength = 0;\n  for (let i = 0; i < source.length; i++) {\n    if (source[i] === ' ') {\n      spacesLength++;\n    } else {\n      break;\n    }\n  }\n  return source.slice(spacesLength);\n}\nexport function trimFirstSpace(source) {\n  return source[0] === ' ' ? source.slice(1) : source;\n}\nfunction startsWith(source, target) {\n  return source.indexOf(target) === 0;\n}","map":{"version":3,"mappings":"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","names":["matchFilteringProperty","filteringProperties","filteringText","maxLength","matchedProperty","property","propertyLabel","length","startsWith","toLowerCase","matchOperator","allowedOperators","matchedOperator","operator","matchOperatorPrefix","trim","matchTokenValue","filteringOptions","value","propertyOptions","filter","option","bestMatch","propertyKey","label","getFormattedToken","token","valueFormatter","getValueFormatter","tokenValue","trimStart","source","spacesLength","i","slice","trimFirstSpace","target","indexOf"],"sources":["/Users/tangyizhi/Desktop/Assignment2/frontend/node_modules/@cloudscape-design/components/property-filter/lib/default/property-filter/utils.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n  ComparisonOperator,\n  InternalFilteringOption,\n  InternalFilteringProperty,\n  InternalToken,\n  Token,\n} from './interfaces';\n\n// Finds the longest property the filtering text starts from.\nexport function matchFilteringProperty(\n  filteringProperties: readonly InternalFilteringProperty[],\n  filteringText: string\n): null | InternalFilteringProperty {\n  let maxLength = 0;\n  let matchedProperty: null | InternalFilteringProperty = null;\n\n  for (const property of filteringProperties) {\n    if (\n      (property.propertyLabel.length >= maxLength && startsWith(filteringText, property.propertyLabel)) ||\n      (property.propertyLabel.length > maxLength &&\n        startsWith(filteringText.toLowerCase(), property.propertyLabel.toLowerCase()))\n    ) {\n      maxLength = property.propertyLabel.length;\n      matchedProperty = property;\n    }\n  }\n\n  return matchedProperty;\n}\n\n// Finds the longest operator the filtering text starts from.\nexport function matchOperator(\n  allowedOperators: readonly ComparisonOperator[],\n  filteringText: string\n): null | ComparisonOperator {\n  filteringText = filteringText.toLowerCase();\n\n  let maxLength = 0;\n  let matchedOperator: null | ComparisonOperator = null;\n\n  for (const operator of allowedOperators) {\n    if (operator.length > maxLength && startsWith(filteringText, operator.toLowerCase())) {\n      maxLength = operator.length;\n      matchedOperator = operator;\n    }\n  }\n\n  return matchedOperator;\n}\n\n// Finds if the filtering text matches any operator prefix.\nexport function matchOperatorPrefix(\n  allowedOperators: readonly ComparisonOperator[],\n  filteringText: string\n): null | string {\n  if (filteringText.trim().length === 0) {\n    return '';\n  }\n  for (const operator of allowedOperators) {\n    if (startsWith(operator.toLowerCase(), filteringText.toLowerCase())) {\n      return filteringText;\n    }\n  }\n  return null;\n}\n\nexport function matchTokenValue(\n  { property, operator, value }: InternalToken,\n  filteringOptions: readonly InternalFilteringOption[]\n): Token {\n  const propertyOptions = filteringOptions.filter(option => option.property === property);\n  const bestMatch: Token = { propertyKey: property?.propertyKey, operator, value };\n  for (const option of propertyOptions) {\n    if ((option.label && option.label === value) || (!option.label && option.value === value)) {\n      // exact match found: return it\n      return { propertyKey: property?.propertyKey, operator, value: option.value };\n    }\n\n    // By default, the token value is a string, but when a custom property is used,\n    // the token value can be any, therefore we need to check for its type before calling toLowerCase()\n    if (typeof value === 'string' && value.toLowerCase() === (option.label ?? option.value ?? '').toLowerCase()) {\n      // non-exact match: save and keep running in case exact match found later\n      bestMatch.value = option.value;\n    }\n  }\n\n  return bestMatch;\n}\n\nexport function getFormattedToken(token: InternalToken) {\n  const valueFormatter = token.property?.getValueFormatter(token.operator);\n  const propertyLabel = token.property && token.property.propertyLabel;\n  const tokenValue = valueFormatter ? valueFormatter(token.value) : token.value;\n  const label = `${propertyLabel ?? ''} ${token.operator} ${tokenValue}`;\n  return { property: propertyLabel ?? '', operator: token.operator, value: tokenValue, label };\n}\n\nexport function trimStart(source: string): string {\n  let spacesLength = 0;\n  for (let i = 0; i < source.length; i++) {\n    if (source[i] === ' ') {\n      spacesLength++;\n    } else {\n      break;\n    }\n  }\n  return source.slice(spacesLength);\n}\n\nexport function trimFirstSpace(source: string): string {\n  return source[0] === ' ' ? source.slice(1) : source;\n}\n\nfunction startsWith(source: string, target: string): boolean {\n  return source.indexOf(target) === 0;\n}\n"]},"metadata":{},"sourceType":"module"}