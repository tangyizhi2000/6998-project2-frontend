{"ast":null,"code":"import { KeyCode } from '../../keycode';\nimport { warnOnce } from '@cloudscape-design/component-toolkit/internal';\nimport { isCommand, isDigit } from './utils/keys';\nimport { backspaceHandler, keyHandler, enterHandler } from './keyboard-handler';\nconst onAutoComplete = (value, onChange, maskFormat) => {\n  // Do not autocomplete if input is empty\n  if (!value) {\n    return;\n  }\n  const autoCompletedValue = maskFormat.autoComplete(value);\n  if (autoCompletedValue !== value) {\n    onChange(autoCompletedValue);\n  }\n};\nconst preventDefault = (event, result) => result && event.preventDefault();\nconst useMask = _ref => {\n  let {\n    value = '',\n    onBlur,\n    onChange,\n    onKeyDown,\n    format,\n    inputRef,\n    autofix = false,\n    disableAutocompleteOnBlur = false,\n    setPosition\n  } = _ref;\n  if (!format.isValid(value)) {\n    warnOnce('useMask', `Invalid string \"${value}\" provided`);\n  }\n  const onMaskChange = updatedValue => {\n    const autofixedUpdatedValue = autofix ? format.correctMinMaxValues(updatedValue) : updatedValue;\n    if (autofixedUpdatedValue === value || !format.isValid(autofixedUpdatedValue)) {\n      return;\n    }\n    onChange(autofixedUpdatedValue);\n  };\n  const initialValue = autofix ? format.correctMinMaxValues(value) : value;\n  const maskedValue = format.getValidValue(initialValue);\n  return {\n    value: maskedValue,\n    onKeyDown: event => {\n      var _a, _b;\n      const selectionStart = ((_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.selectionStart) || 0;\n      const selectionEnd = ((_b = inputRef.current) === null || _b === void 0 ? void 0 : _b.selectionEnd) || 0;\n      let result;\n      const {\n        keyCode,\n        key,\n        ctrlKey,\n        metaKey\n      } = event.detail;\n      if (isDigit(key) || format.isSeparator(key)) {\n        result = keyHandler(maskedValue, key, format, selectionStart, selectionEnd);\n        preventDefault(event, result);\n      } else if (keyCode === KeyCode.backspace) {\n        result = backspaceHandler(maskedValue, format, selectionStart, selectionEnd);\n        preventDefault(event, result);\n      } else if (keyCode === KeyCode.enter) {\n        result = enterHandler(maskedValue, format);\n      } else if (!isCommand(keyCode, ctrlKey, metaKey)) {\n        event.preventDefault();\n      }\n      if (result) {\n        const {\n          value,\n          position\n        } = result;\n        onMaskChange(value);\n        setPosition(position);\n      }\n      // Proxy original event\n      onKeyDown && onKeyDown(event);\n    },\n    onChange: _ref2 => {\n      let {\n        detail\n      } = _ref2;\n      return onMaskChange(detail.value);\n    },\n    onBlur: () => {\n      if (!disableAutocompleteOnBlur) {\n        onAutoComplete(maskedValue, onChange, format);\n      }\n      onBlur && onBlur();\n    },\n    onPaste: event => {\n      var _a, _b;\n      const text = (event.clipboardData || window.clipboardData).getData('text');\n      const selectionStart = ((_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.selectionStart) || 0;\n      const selectionEnd = ((_b = inputRef.current) === null || _b === void 0 ? void 0 : _b.selectionEnd) || 0;\n      const formattedText = format.formatPastedText(text, maskedValue, selectionStart, selectionEnd);\n      onMaskChange(formattedText);\n    }\n  };\n};\nexport default useMask;","map":{"version":3,"mappings":"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","names":["KeyCode","warnOnce","isCommand","isDigit","backspaceHandler","keyHandler","enterHandler","onAutoComplete","value","onChange","maskFormat","autoCompletedValue","autoComplete","preventDefault","event","result","useMask","onBlur","onKeyDown","format","inputRef","autofix","disableAutocompleteOnBlur","setPosition","isValid","onMaskChange","updatedValue","autofixedUpdatedValue","correctMinMaxValues","initialValue","maskedValue","getValidValue","selectionStart","current","selectionEnd","keyCode","key","ctrlKey","metaKey","detail","isSeparator","backspace","enter","position","onPaste","text","clipboardData","window","getData","formattedText","formatPastedText"],"sources":["/Users/tangyizhi/Desktop/Assignment 2/frontend/node_modules/@cloudscape-design/components/internal/components/masked-input/lib/default/internal/components/masked-input/use-mask.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { RefObject } from 'react';\nimport { InputProps } from '../../../input/interfaces';\nimport { NonCancelableEventHandler, CancelableEventHandler } from '../../events';\nimport { KeyCode } from '../../keycode';\n\nimport { warnOnce } from '@cloudscape-design/component-toolkit/internal';\nimport { isCommand, isDigit } from './utils/keys';\n\nimport MaskFormat from './utils/mask-format';\nimport { backspaceHandler, HandlerResult, keyHandler, enterHandler } from './keyboard-handler';\n\ninterface UseMaskHook {\n  value: string;\n  onChange: NonCancelableEventHandler<InputProps.ChangeDetail>;\n  onKeyDown: CancelableEventHandler<InputProps.KeyDetail>;\n  onBlur: NonCancelableEventHandler<null>;\n  onPaste: (event: ClipboardEvent) => void;\n}\n\ninterface UseMaskProps {\n  value: string;\n  onChange: (value: string) => void;\n  onKeyDown?: (event: CustomEvent) => void;\n  onBlur?: () => void;\n  format: MaskFormat;\n  autofix?: boolean;\n  inputRef: RefObject<HTMLInputElement>;\n  disableAutocompleteOnBlur?: boolean;\n  setPosition: (position: number | null) => void;\n}\n\nconst onAutoComplete = (value: string, onChange: UseMaskProps['onChange'], maskFormat: MaskFormat) => {\n  // Do not autocomplete if input is empty\n  if (!value) {\n    return;\n  }\n\n  const autoCompletedValue = maskFormat.autoComplete(value);\n  if (autoCompletedValue !== value) {\n    onChange(autoCompletedValue);\n  }\n};\n\nconst preventDefault = (event: CustomEvent, result?: HandlerResult | null) => result && event.preventDefault();\n\nconst useMask = ({\n  value = '',\n  onBlur,\n  onChange,\n  onKeyDown,\n  format,\n  inputRef,\n  autofix = false,\n  disableAutocompleteOnBlur = false,\n  setPosition,\n}: UseMaskProps): UseMaskHook => {\n  if (!format.isValid(value)) {\n    warnOnce('useMask', `Invalid string \"${value}\" provided`);\n  }\n\n  const onMaskChange = (updatedValue: string) => {\n    const autofixedUpdatedValue = autofix ? format.correctMinMaxValues(updatedValue) : updatedValue;\n    if (autofixedUpdatedValue === value || !format.isValid(autofixedUpdatedValue)) {\n      return;\n    }\n\n    onChange(autofixedUpdatedValue);\n  };\n\n  const initialValue = autofix ? format.correctMinMaxValues(value) : value;\n  const maskedValue = format.getValidValue(initialValue);\n\n  return {\n    value: maskedValue,\n    onKeyDown: (event: CustomEvent) => {\n      const selectionStart = inputRef.current?.selectionStart || 0;\n      const selectionEnd = inputRef.current?.selectionEnd || 0;\n\n      let result: HandlerResult | undefined;\n      const { keyCode, key, ctrlKey, metaKey } = event.detail;\n      if (isDigit(key) || format.isSeparator(key)) {\n        result = keyHandler(maskedValue, key, format, selectionStart, selectionEnd);\n        preventDefault(event, result);\n      } else if (keyCode === KeyCode.backspace) {\n        result = backspaceHandler(maskedValue, format, selectionStart, selectionEnd);\n        preventDefault(event, result);\n      } else if (keyCode === KeyCode.enter) {\n        result = enterHandler(maskedValue, format);\n      } else if (!isCommand(keyCode, ctrlKey, metaKey)) {\n        event.preventDefault();\n      }\n\n      if (result) {\n        const { value, position } = result;\n\n        onMaskChange(value);\n        setPosition(position);\n      }\n\n      // Proxy original event\n      onKeyDown && onKeyDown(event);\n    },\n    onChange: ({ detail }) => onMaskChange(detail.value),\n    onBlur: () => {\n      if (!disableAutocompleteOnBlur) {\n        onAutoComplete(maskedValue, onChange, format);\n      }\n\n      onBlur && onBlur();\n    },\n    onPaste: (event: ClipboardEvent) => {\n      const text = (event.clipboardData || (window as any).clipboardData).getData('text');\n\n      const selectionStart = inputRef.current?.selectionStart || 0;\n      const selectionEnd = inputRef.current?.selectionEnd || 0;\n\n      const formattedText = format.formatPastedText(text, maskedValue, selectionStart, selectionEnd);\n      onMaskChange(formattedText);\n    },\n  };\n};\n\nexport default useMask;\n"]},"metadata":{},"sourceType":"module"}