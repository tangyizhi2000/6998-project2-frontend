{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { Position } from \"../utils/position\";\nimport { LayoutEngineCacheNode } from \"./engine-cache\";\nimport { LayoutEngineState } from \"./engine-state\";\nimport { resolveOverlaps } from \"./engine-step\";\nimport { LayoutEngineGrid } from \"./grid\";\nimport { createMove, normalizeMovePath, normalizeResizePath, sortGridItems } from \"./utils\";\n/**\n * Layout engine is an abstraction to compute effects of user actions (move, resize, insert, remove).\n * The engine is initialized with the board state and then takes a command to calculate the respective layout shift.\n * Use a single engine instance until the user commits their move to take advantage of the internal cache.\n * Once user move is committed the layout engine needs to be re-initialized with the updated layout state.\n */\nexport class LayoutEngine {\n  constructor(layout) {\n    this.layout = layout;\n    this.cache = new LayoutEngineCacheNode(new LayoutEngineState(new LayoutEngineGrid(layout.items, layout.columns)));\n  }\n  move(moveCommand) {\n    let cache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.cache;\n    // The validation ensures no position in the path is outside the board and updates the path so that all\n    // positions are incremental (moving one cell at a time) and no loops are present (no position can occur twice).\n    // Removing the loops guarantees that moving back to one of the previous positions including the starting one\n    // revives the previous state as is. The same behavior might cause confusion in case the user comes back\n    // to a previous position accidentally especially if the move path is long.\n    const path = this.validateMovePath({\n      ...moveCommand\n    }, cache.state);\n    // The user command is resolved one step at a time. When layout engine is reused withing one transition\n    // it is expected that all steps but the last one are already cached.\n    for (let stepIndex = 0; stepIndex < path.length; stepIndex++) {\n      const item = cache.state.grid.getItem(moveCommand.itemId);\n      const move = createMove(\"MOVE\", item, path[stepIndex]);\n      cache = cache.matches(path[stepIndex], () => resolveOverlaps(cache.state, move));\n    }\n    return this.getLayoutShift(cache.state);\n  }\n  resize(resizeCommand) {\n    // The validation ensures no position in the path is outside the board and the width/height are above 0.\n    // The resize path is updated so that all positions are incremental (moving one cell at a time) and\n    // no loops are present (no position can occur twice).\n    // Removing the loops guarantees that moving back to one of the previous positions including the starting one\n    // revives the previous state as is. The same behavior might cause confusion in case the user comes back\n    // to a previous position accidentally especially if the move path is long.\n    const path = this.validateResizePath(resizeCommand, this.cache.state);\n    // The user command is resolved one step at a time. When layout engine is reused withing one transition\n    // it is expected that all steps but the last one are already cached.\n    let cache = this.cache;\n    for (let stepIndex = 0; stepIndex < path.length; stepIndex++) {\n      const resizeTarget = cache.state.grid.getItem(resizeCommand.itemId);\n      const width = path[stepIndex].x - resizeTarget.x;\n      const height = path[stepIndex].y - resizeTarget.y;\n      const move = createMove(\"RESIZE\", resizeTarget, new Position({\n        x: width,\n        y: height\n      }));\n      cache = cache.matches(path[stepIndex], () => resolveOverlaps(cache.state, move));\n    }\n    return this.getLayoutShift(cache.state);\n  }\n  insert(_ref) {\n    let {\n      itemId,\n      width,\n      height,\n      path: [position, ...movePath]\n    } = _ref;\n    // For insert command the new item is injected to the given location first and then it can be moved\n    // the same way as the existing item would.\n    const insertMove = createMove(\"INSERT\", {\n      id: itemId,\n      x: position.x,\n      y: position.y,\n      width,\n      height\n    }, position);\n    const cache = this.cache.matches(position, () => resolveOverlaps(this.cache.state, insertMove));\n    return this.move({\n      itemId,\n      path: movePath\n    }, cache);\n  }\n  remove(itemId) {\n    // The remove command does not define the move path and is not cached. It is expected to be performed only once.\n    const {\n      x,\n      y,\n      width,\n      height\n    } = this.cache.state.grid.getItem(itemId);\n    const move = createMove(\"REMOVE\", {\n      id: itemId,\n      x,\n      y,\n      width,\n      height\n    }, new Position({\n      x,\n      y\n    }));\n    const state = resolveOverlaps(this.cache.state, move);\n    return this.getLayoutShift(state);\n  }\n  getLayoutShift(state) {\n    return {\n      current: this.layout,\n      next: {\n        items: sortGridItems(state.grid.items),\n        columns: state.grid.width,\n        rows: state.grid.height\n      },\n      moves: state.moves,\n      conflicts: state.conflicts ? [...state.conflicts.items] : []\n    };\n  }\n  validateMovePath(_ref2, state) {\n    let {\n      itemId,\n      path\n    } = _ref2;\n    const moveTarget = state.grid.getItem(itemId);\n    for (const step of path) {\n      if (step.x < 0 || step.y < 0 || step.x + moveTarget.width > state.grid.width) {\n        throw new Error(\"Invalid move: outside grid.\");\n      }\n    }\n    return normalizeMovePath(new Position({\n      x: moveTarget.x,\n      y: moveTarget.y\n    }), path);\n  }\n  validateResizePath(_ref3, state) {\n    let {\n      itemId,\n      path\n    } = _ref3;\n    const resizeTarget = state.grid.getItem(itemId);\n    const x = resizeTarget.x + resizeTarget.width;\n    const y = resizeTarget.y + resizeTarget.height;\n    for (const step of path) {\n      if (step.x < 1 || step.y < 1) {\n        throw new Error(\"Invalid resize: can't resize to 0.\");\n      }\n      if (step.x > state.grid.width) {\n        throw new Error(\"Invalid resize: outside grid.\");\n      }\n    }\n    return normalizeResizePath(new Position({\n      x,\n      y\n    }), path);\n  }\n}","map":{"version":3,"names":["Position","LayoutEngineCacheNode","LayoutEngineState","resolveOverlaps","LayoutEngineGrid","createMove","normalizeMovePath","normalizeResizePath","sortGridItems","LayoutEngine","constructor","layout","cache","items","columns","move","moveCommand","path","validateMovePath","state","stepIndex","length","item","grid","getItem","itemId","matches","getLayoutShift","resize","resizeCommand","validateResizePath","resizeTarget","width","x","height","y","insert","position","movePath","insertMove","id","remove","current","next","rows","moves","conflicts","moveTarget","step","Error"],"sources":["/Users/tangyizhi/Desktop/Assignment 2/frontend/node_modules/@cloudscape-design/board-components/internal/layout-engine/engine.js"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { Position } from \"../utils/position\";\nimport { LayoutEngineCacheNode } from \"./engine-cache\";\nimport { LayoutEngineState } from \"./engine-state\";\nimport { resolveOverlaps } from \"./engine-step\";\nimport { LayoutEngineGrid } from \"./grid\";\nimport { createMove, normalizeMovePath, normalizeResizePath, sortGridItems } from \"./utils\";\n/**\n * Layout engine is an abstraction to compute effects of user actions (move, resize, insert, remove).\n * The engine is initialized with the board state and then takes a command to calculate the respective layout shift.\n * Use a single engine instance until the user commits their move to take advantage of the internal cache.\n * Once user move is committed the layout engine needs to be re-initialized with the updated layout state.\n */\nexport class LayoutEngine {\n    constructor(layout) {\n        this.layout = layout;\n        this.cache = new LayoutEngineCacheNode(new LayoutEngineState(new LayoutEngineGrid(layout.items, layout.columns)));\n    }\n    move(moveCommand, cache = this.cache) {\n        // The validation ensures no position in the path is outside the board and updates the path so that all\n        // positions are incremental (moving one cell at a time) and no loops are present (no position can occur twice).\n        // Removing the loops guarantees that moving back to one of the previous positions including the starting one\n        // revives the previous state as is. The same behavior might cause confusion in case the user comes back\n        // to a previous position accidentally especially if the move path is long.\n        const path = this.validateMovePath({ ...moveCommand }, cache.state);\n        // The user command is resolved one step at a time. When layout engine is reused withing one transition\n        // it is expected that all steps but the last one are already cached.\n        for (let stepIndex = 0; stepIndex < path.length; stepIndex++) {\n            const item = cache.state.grid.getItem(moveCommand.itemId);\n            const move = createMove(\"MOVE\", item, path[stepIndex]);\n            cache = cache.matches(path[stepIndex], () => resolveOverlaps(cache.state, move));\n        }\n        return this.getLayoutShift(cache.state);\n    }\n    resize(resizeCommand) {\n        // The validation ensures no position in the path is outside the board and the width/height are above 0.\n        // The resize path is updated so that all positions are incremental (moving one cell at a time) and\n        // no loops are present (no position can occur twice).\n        // Removing the loops guarantees that moving back to one of the previous positions including the starting one\n        // revives the previous state as is. The same behavior might cause confusion in case the user comes back\n        // to a previous position accidentally especially if the move path is long.\n        const path = this.validateResizePath(resizeCommand, this.cache.state);\n        // The user command is resolved one step at a time. When layout engine is reused withing one transition\n        // it is expected that all steps but the last one are already cached.\n        let cache = this.cache;\n        for (let stepIndex = 0; stepIndex < path.length; stepIndex++) {\n            const resizeTarget = cache.state.grid.getItem(resizeCommand.itemId);\n            const width = path[stepIndex].x - resizeTarget.x;\n            const height = path[stepIndex].y - resizeTarget.y;\n            const move = createMove(\"RESIZE\", resizeTarget, new Position({ x: width, y: height }));\n            cache = cache.matches(path[stepIndex], () => resolveOverlaps(cache.state, move));\n        }\n        return this.getLayoutShift(cache.state);\n    }\n    insert({ itemId, width, height, path: [position, ...movePath] }) {\n        // For insert command the new item is injected to the given location first and then it can be moved\n        // the same way as the existing item would.\n        const insertMove = createMove(\"INSERT\", { id: itemId, x: position.x, y: position.y, width, height }, position);\n        const cache = this.cache.matches(position, () => resolveOverlaps(this.cache.state, insertMove));\n        return this.move({ itemId, path: movePath }, cache);\n    }\n    remove(itemId) {\n        // The remove command does not define the move path and is not cached. It is expected to be performed only once.\n        const { x, y, width, height } = this.cache.state.grid.getItem(itemId);\n        const move = createMove(\"REMOVE\", { id: itemId, x, y, width, height }, new Position({ x, y }));\n        const state = resolveOverlaps(this.cache.state, move);\n        return this.getLayoutShift(state);\n    }\n    getLayoutShift(state) {\n        return {\n            current: this.layout,\n            next: {\n                items: sortGridItems(state.grid.items),\n                columns: state.grid.width,\n                rows: state.grid.height,\n            },\n            moves: state.moves,\n            conflicts: state.conflicts ? [...state.conflicts.items] : [],\n        };\n    }\n    validateMovePath({ itemId, path }, state) {\n        const moveTarget = state.grid.getItem(itemId);\n        for (const step of path) {\n            if (step.x < 0 || step.y < 0 || step.x + moveTarget.width > state.grid.width) {\n                throw new Error(\"Invalid move: outside grid.\");\n            }\n        }\n        return normalizeMovePath(new Position({ x: moveTarget.x, y: moveTarget.y }), path);\n    }\n    validateResizePath({ itemId, path }, state) {\n        const resizeTarget = state.grid.getItem(itemId);\n        const x = resizeTarget.x + resizeTarget.width;\n        const y = resizeTarget.y + resizeTarget.height;\n        for (const step of path) {\n            if (step.x < 1 || step.y < 1) {\n                throw new Error(\"Invalid resize: can't resize to 0.\");\n            }\n            if (step.x > state.grid.width) {\n                throw new Error(\"Invalid resize: outside grid.\");\n            }\n        }\n        return normalizeResizePath(new Position({ x, y }), path);\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}