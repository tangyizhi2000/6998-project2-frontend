{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { MIN_COL_SPAN, MIN_ROW_SPAN } from \"../constants\";\n/**\n * The function produces grid layout from board items and given number of columns.\n * The positional data is taken from the items when available or the default placement is used otherwise.\n */\nexport function interpretItems(items, columns) {\n  const layoutItems = [];\n  const columnHeights = Array(columns).fill(0);\n  function getColumnSpan(item) {\n    var _a;\n    const minColumnSpan = getMinColumnSpan(item, columns);\n    const columnSpan = (_a = item.columnSpan) !== null && _a !== void 0 ? _a : getDefaultColumnSpan(item, columns);\n    return Math.min(columns, Math.max(minColumnSpan, columnSpan));\n  }\n  function getRowSpan(item) {\n    var _a;\n    const minRowSpan = getMinRowSpan(item);\n    const rowSpan = (_a = item.rowSpan) !== null && _a !== void 0 ? _a : getDefaultRowSpan(item);\n    return Math.max(minRowSpan, rowSpan);\n  }\n  function getColumnOffset(item, currentOffset) {\n    var _a, _b;\n    const columnSpan = getColumnSpan(item);\n    const rowSpan = getRowSpan(item);\n    const columnOffset = (_b = (_a = item.columnOffset) === null || _a === void 0 ? void 0 : _a[columns]) !== null && _b !== void 0 ? _b : findOptimalColumnOffset(currentOffset, columnSpan, rowSpan);\n    return columnOffset + columnSpan <= columns ? columnOffset : 0;\n  }\n  function findOptimalColumnOffset(currentColumnOffset, columnSpan, rowSpan) {\n    for (let colOffset = currentColumnOffset; colOffset + columnSpan <= columns; colOffset++) {\n      if (getRowOffset(colOffset, columnSpan) + rowSpan <= getRowOffset(0, columns)) {\n        return colOffset;\n      }\n    }\n    for (let colOffset = 0; colOffset + columnSpan <= columns; colOffset++) {\n      if (getRowOffset(colOffset, columnSpan) + rowSpan <= getRowOffset(0, columns)) {\n        return colOffset;\n      }\n    }\n    return currentColumnOffset;\n  }\n  function getRowOffset(columnOffset, columnSpan) {\n    let rowOffset = 0;\n    for (let col = columnOffset; col < columnOffset + columnSpan; col++) {\n      rowOffset = Math.max(rowOffset, columnHeights[col]);\n    }\n    return rowOffset;\n  }\n  for (let index = 0, columnOffset = 0, rowOffset = 0; index < items.length; index++, rowOffset = 0) {\n    const columnSpan = getColumnSpan(items[index]);\n    const rowSpan = getRowSpan(items[index]);\n    columnOffset = getColumnOffset(items[index], columnOffset);\n    rowOffset = getRowOffset(columnOffset, columnSpan);\n    layoutItems.push({\n      id: items[index].id,\n      width: columnSpan,\n      height: rowSpan,\n      x: columnOffset,\n      y: rowOffset\n    });\n    for (let col = columnOffset; col < columnOffset + columnSpan; col++) {\n      columnHeights[col] = rowOffset + rowSpan;\n    }\n    columnOffset += columnSpan;\n  }\n  layoutItems.sort(itemComparator);\n  return {\n    items: layoutItems,\n    columns,\n    rows: getRowOffset(0, columns)\n  };\n}\n/**\n * The function produces new items from the current state and updated grid layout.\n * The positional data for the given number of columns is preserved as is while the other layouts are partially invalidated.\n */\nexport function transformItems(sourceItems, gridLayout, resizeTarget) {\n  const itemById = new Map(sourceItems.map(item => [item.id, item]));\n  const getItem = itemId => {\n    const item = itemById.get(itemId);\n    if (!item) {\n      throw new Error(\"Invariant violation: no matching source item found.\");\n    }\n    return item;\n  };\n  const sortedLayout = gridLayout.items.slice().sort(itemComparator);\n  const items = [];\n  let changeFromIndex = sortedLayout.findIndex((_ref, index) => {\n    let {\n      id\n    } = _ref;\n    return id !== sourceItems[index].id || id === resizeTarget;\n  });\n  changeFromIndex = changeFromIndex !== -1 ? changeFromIndex : sortedLayout.length;\n  for (let index = 0; index < sortedLayout.length; index++) {\n    const {\n      id,\n      x,\n      width,\n      height\n    } = sortedLayout[index];\n    const item = {\n      ...getItem(id)\n    };\n    if (index >= changeFromIndex) {\n      item.columnOffset = undefined;\n    }\n    item.columnOffset = {\n      ...item.columnOffset,\n      [gridLayout.columns]: x\n    };\n    if (item.id === resizeTarget) {\n      item.columnSpan = width;\n      item.rowSpan = height;\n    }\n    items.push(item);\n  }\n  return items;\n}\nexport function createPlaceholdersLayout(rows, columns) {\n  const layoutItems = [];\n  for (let row = 0; row < rows; row++) {\n    for (let col = 0; col < columns; col++) {\n      layoutItems.push({\n        id: `awsui-placeholder-${row}-${col}`,\n        x: col,\n        y: row,\n        width: 1,\n        height: 1\n      });\n    }\n  }\n  return {\n    items: layoutItems,\n    columns,\n    rows\n  };\n}\nexport function getMinColumnSpan(item, columns) {\n  var _a, _b;\n  return Math.min(columns, Math.max(MIN_COL_SPAN, (_b = (_a = item.definition) === null || _a === void 0 ? void 0 : _a.minColumnSpan) !== null && _b !== void 0 ? _b : 0));\n}\nexport function getDefaultColumnSpan(item, columns) {\n  var _a, _b;\n  return Math.min(columns, Math.max(getMinColumnSpan(item, columns), (_b = (_a = item.definition) === null || _a === void 0 ? void 0 : _a.defaultColumnSpan) !== null && _b !== void 0 ? _b : 0));\n}\nexport function getMinRowSpan(item) {\n  var _a, _b;\n  return Math.max(MIN_ROW_SPAN, (_b = (_a = item.definition) === null || _a === void 0 ? void 0 : _a.minRowSpan) !== null && _b !== void 0 ? _b : 0);\n}\nexport function getDefaultRowSpan(item) {\n  var _a, _b;\n  return Math.max(getMinRowSpan(item), (_b = (_a = item.definition) === null || _a === void 0 ? void 0 : _a.defaultRowSpan) !== null && _b !== void 0 ? _b : 0);\n}\nfunction itemComparator(a, b) {\n  if (a.y !== b.y) {\n    return a.y > b.y ? 1 : -1;\n  }\n  return a.x > b.x ? 1 : -1;\n}","map":{"version":3,"names":["MIN_COL_SPAN","MIN_ROW_SPAN","interpretItems","items","columns","layoutItems","columnHeights","Array","fill","getColumnSpan","item","_a","minColumnSpan","getMinColumnSpan","columnSpan","getDefaultColumnSpan","Math","min","max","getRowSpan","minRowSpan","getMinRowSpan","rowSpan","getDefaultRowSpan","getColumnOffset","currentOffset","_b","columnOffset","findOptimalColumnOffset","currentColumnOffset","colOffset","getRowOffset","rowOffset","col","index","length","push","id","width","height","x","y","sort","itemComparator","rows","transformItems","sourceItems","gridLayout","resizeTarget","itemById","Map","map","getItem","itemId","get","Error","sortedLayout","slice","changeFromIndex","findIndex","undefined","createPlaceholdersLayout","row","definition","defaultColumnSpan","defaultRowSpan","a","b"],"sources":["/Users/tangyizhi/Desktop/Assignment 2/frontend/node_modules/@cloudscape-design/board-components/internal/utils/layout.js"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { MIN_COL_SPAN, MIN_ROW_SPAN } from \"../constants\";\n/**\n * The function produces grid layout from board items and given number of columns.\n * The positional data is taken from the items when available or the default placement is used otherwise.\n */\nexport function interpretItems(items, columns) {\n    const layoutItems = [];\n    const columnHeights = Array(columns).fill(0);\n    function getColumnSpan(item) {\n        var _a;\n        const minColumnSpan = getMinColumnSpan(item, columns);\n        const columnSpan = (_a = item.columnSpan) !== null && _a !== void 0 ? _a : getDefaultColumnSpan(item, columns);\n        return Math.min(columns, Math.max(minColumnSpan, columnSpan));\n    }\n    function getRowSpan(item) {\n        var _a;\n        const minRowSpan = getMinRowSpan(item);\n        const rowSpan = (_a = item.rowSpan) !== null && _a !== void 0 ? _a : getDefaultRowSpan(item);\n        return Math.max(minRowSpan, rowSpan);\n    }\n    function getColumnOffset(item, currentOffset) {\n        var _a, _b;\n        const columnSpan = getColumnSpan(item);\n        const rowSpan = getRowSpan(item);\n        const columnOffset = (_b = (_a = item.columnOffset) === null || _a === void 0 ? void 0 : _a[columns]) !== null && _b !== void 0 ? _b : findOptimalColumnOffset(currentOffset, columnSpan, rowSpan);\n        return columnOffset + columnSpan <= columns ? columnOffset : 0;\n    }\n    function findOptimalColumnOffset(currentColumnOffset, columnSpan, rowSpan) {\n        for (let colOffset = currentColumnOffset; colOffset + columnSpan <= columns; colOffset++) {\n            if (getRowOffset(colOffset, columnSpan) + rowSpan <= getRowOffset(0, columns)) {\n                return colOffset;\n            }\n        }\n        for (let colOffset = 0; colOffset + columnSpan <= columns; colOffset++) {\n            if (getRowOffset(colOffset, columnSpan) + rowSpan <= getRowOffset(0, columns)) {\n                return colOffset;\n            }\n        }\n        return currentColumnOffset;\n    }\n    function getRowOffset(columnOffset, columnSpan) {\n        let rowOffset = 0;\n        for (let col = columnOffset; col < columnOffset + columnSpan; col++) {\n            rowOffset = Math.max(rowOffset, columnHeights[col]);\n        }\n        return rowOffset;\n    }\n    for (let index = 0, columnOffset = 0, rowOffset = 0; index < items.length; index++, rowOffset = 0) {\n        const columnSpan = getColumnSpan(items[index]);\n        const rowSpan = getRowSpan(items[index]);\n        columnOffset = getColumnOffset(items[index], columnOffset);\n        rowOffset = getRowOffset(columnOffset, columnSpan);\n        layoutItems.push({ id: items[index].id, width: columnSpan, height: rowSpan, x: columnOffset, y: rowOffset });\n        for (let col = columnOffset; col < columnOffset + columnSpan; col++) {\n            columnHeights[col] = rowOffset + rowSpan;\n        }\n        columnOffset += columnSpan;\n    }\n    layoutItems.sort(itemComparator);\n    return { items: layoutItems, columns, rows: getRowOffset(0, columns) };\n}\n/**\n * The function produces new items from the current state and updated grid layout.\n * The positional data for the given number of columns is preserved as is while the other layouts are partially invalidated.\n */\nexport function transformItems(sourceItems, gridLayout, resizeTarget) {\n    const itemById = new Map(sourceItems.map((item) => [item.id, item]));\n    const getItem = (itemId) => {\n        const item = itemById.get(itemId);\n        if (!item) {\n            throw new Error(\"Invariant violation: no matching source item found.\");\n        }\n        return item;\n    };\n    const sortedLayout = gridLayout.items.slice().sort(itemComparator);\n    const items = [];\n    let changeFromIndex = sortedLayout.findIndex(({ id }, index) => id !== sourceItems[index].id || id === resizeTarget);\n    changeFromIndex = changeFromIndex !== -1 ? changeFromIndex : sortedLayout.length;\n    for (let index = 0; index < sortedLayout.length; index++) {\n        const { id, x, width, height } = sortedLayout[index];\n        const item = { ...getItem(id) };\n        if (index >= changeFromIndex) {\n            item.columnOffset = undefined;\n        }\n        item.columnOffset = { ...item.columnOffset, [gridLayout.columns]: x };\n        if (item.id === resizeTarget) {\n            item.columnSpan = width;\n            item.rowSpan = height;\n        }\n        items.push(item);\n    }\n    return items;\n}\nexport function createPlaceholdersLayout(rows, columns) {\n    const layoutItems = [];\n    for (let row = 0; row < rows; row++) {\n        for (let col = 0; col < columns; col++) {\n            layoutItems.push({ id: `awsui-placeholder-${row}-${col}`, x: col, y: row, width: 1, height: 1 });\n        }\n    }\n    return { items: layoutItems, columns, rows };\n}\nexport function getMinColumnSpan(item, columns) {\n    var _a, _b;\n    return Math.min(columns, Math.max(MIN_COL_SPAN, (_b = (_a = item.definition) === null || _a === void 0 ? void 0 : _a.minColumnSpan) !== null && _b !== void 0 ? _b : 0));\n}\nexport function getDefaultColumnSpan(item, columns) {\n    var _a, _b;\n    return Math.min(columns, Math.max(getMinColumnSpan(item, columns), (_b = (_a = item.definition) === null || _a === void 0 ? void 0 : _a.defaultColumnSpan) !== null && _b !== void 0 ? _b : 0));\n}\nexport function getMinRowSpan(item) {\n    var _a, _b;\n    return Math.max(MIN_ROW_SPAN, (_b = (_a = item.definition) === null || _a === void 0 ? void 0 : _a.minRowSpan) !== null && _b !== void 0 ? _b : 0);\n}\nexport function getDefaultRowSpan(item) {\n    var _a, _b;\n    return Math.max(getMinRowSpan(item), (_b = (_a = item.definition) === null || _a === void 0 ? void 0 : _a.defaultRowSpan) !== null && _b !== void 0 ? _b : 0);\n}\nfunction itemComparator(a, b) {\n    if (a.y !== b.y) {\n        return a.y > b.y ? 1 : -1;\n    }\n    return a.x > b.x ? 1 : -1;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}