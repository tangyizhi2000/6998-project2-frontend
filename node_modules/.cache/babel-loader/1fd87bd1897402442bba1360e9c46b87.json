{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nexport function isInside(rect, bounds) {\n  return rect.top >= bounds.top && rect.left >= bounds.left && rect.right <= bounds.right && rect.bottom <= bounds.bottom;\n}\nexport function isIntersecting(rect1, rect2) {\n  return getIntersectionArea(rect1, rect2) > 0;\n}\nexport function getIntersectionArea(rect1, rect2) {\n  let horizontalIntersectionLength = 0;\n  if (rect2.left <= rect1.left && rect1.left <= rect2.right) {\n    horizontalIntersectionLength = Math.min(rect1.right, rect2.right) - rect1.left;\n  } else if (rect2.left <= rect1.right && rect1.right <= rect2.right) {\n    horizontalIntersectionLength = rect1.right - Math.max(rect1.left, rect2.left);\n  } else if (rect1.left <= rect2.left && rect2.left <= rect1.right) {\n    horizontalIntersectionLength = Math.min(rect1.right, rect2.right) - rect2.left;\n  } else if (rect1.left <= rect2.right && rect2.right <= rect1.right) {\n    horizontalIntersectionLength = rect2.right - Math.max(rect1.left, rect2.left);\n  }\n  let verticalIntersectionLength = 0;\n  if (rect2.top <= rect1.top && rect1.top <= rect2.bottom) {\n    verticalIntersectionLength = Math.min(rect1.bottom, rect2.bottom) - rect1.top;\n  } else if (rect2.top <= rect1.bottom && rect1.bottom <= rect2.bottom) {\n    verticalIntersectionLength = rect1.bottom - Math.max(rect1.top, rect2.top);\n  } else if (rect1.top <= rect2.top && rect2.top <= rect1.bottom) {\n    verticalIntersectionLength = Math.min(rect1.bottom, rect2.bottom) - rect2.top;\n  } else if (rect1.top <= rect2.bottom && rect2.bottom <= rect1.bottom) {\n    verticalIntersectionLength = rect2.bottom - Math.max(rect1.top, rect2.top);\n  }\n  return horizontalIntersectionLength * verticalIntersectionLength;\n}\nexport function getGridPlacement(target, grid) {\n  function getMinDistance(min, current, collision) {\n    const minDistance = Math.abs(min - collision);\n    const currentDistance = Math.abs(current - collision);\n    return currentDistance < minDistance ? current : min;\n  }\n  let placement = {\n    top: Number.POSITIVE_INFINITY,\n    left: Number.POSITIVE_INFINITY,\n    right: Number.POSITIVE_INFINITY,\n    bottom: Number.POSITIVE_INFINITY\n  };\n  for (const rect of grid) {\n    if (isIntersecting(rect, target)) {\n      placement = {\n        top: getMinDistance(placement.top, rect.top, target.top),\n        left: getMinDistance(placement.left, rect.left, target.left),\n        right: getMinDistance(placement.right, rect.right, target.right),\n        bottom: getMinDistance(placement.bottom, rect.bottom, target.bottom)\n      };\n    }\n  }\n  return placement;\n}\nexport function getClosestNeighbor(target, sources, direction) {\n  const getFirst = rects => {\n    var _a;\n    return (_a = rects[0]) !== null && _a !== void 0 ? _a : null;\n  };\n  const verticalDiff = (r1, r2) => Math.abs(r1.top - target.top) - Math.abs(r2.top - target.top);\n  const horizontalDiff = (r1, r2) => Math.abs(r1.left - target.left) - Math.abs(r2.left - target.left);\n  switch (direction) {\n    case \"left\":\n      return getFirst(sources.filter(rect => rect.right <= target.left).sort((r1, r2) => r2.left - r1.left || verticalDiff(r1, r2)));\n    case \"right\":\n      return getFirst(sources.filter(rect => rect.left >= target.right).sort((r1, r2) => r1.left - r2.left || verticalDiff(r1, r2)));\n    case \"up\":\n      return getFirst(sources.filter(rect => rect.bottom <= target.top).sort((r1, r2) => r2.top - r1.top || horizontalDiff(r1, r2)));\n    case \"down\":\n      return getFirst(sources.filter(rect => rect.top >= target.bottom).sort((r1, r2) => r1.top - r2.top || horizontalDiff(r1, r2)));\n  }\n}","map":{"version":3,"names":["isInside","rect","bounds","top","left","right","bottom","isIntersecting","rect1","rect2","getIntersectionArea","horizontalIntersectionLength","Math","min","max","verticalIntersectionLength","getGridPlacement","target","grid","getMinDistance","current","collision","minDistance","abs","currentDistance","placement","Number","POSITIVE_INFINITY","getClosestNeighbor","sources","direction","getFirst","rects","_a","verticalDiff","r1","r2","horizontalDiff","filter","sort"],"sources":["/Users/tangyizhi/Desktop/Assignment 2/frontend/node_modules/@cloudscape-design/board-components/internal/utils/rects.js"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nexport function isInside(rect, bounds) {\n    return (rect.top >= bounds.top && rect.left >= bounds.left && rect.right <= bounds.right && rect.bottom <= bounds.bottom);\n}\nexport function isIntersecting(rect1, rect2) {\n    return getIntersectionArea(rect1, rect2) > 0;\n}\nexport function getIntersectionArea(rect1, rect2) {\n    let horizontalIntersectionLength = 0;\n    if (rect2.left <= rect1.left && rect1.left <= rect2.right) {\n        horizontalIntersectionLength = Math.min(rect1.right, rect2.right) - rect1.left;\n    }\n    else if (rect2.left <= rect1.right && rect1.right <= rect2.right) {\n        horizontalIntersectionLength = rect1.right - Math.max(rect1.left, rect2.left);\n    }\n    else if (rect1.left <= rect2.left && rect2.left <= rect1.right) {\n        horizontalIntersectionLength = Math.min(rect1.right, rect2.right) - rect2.left;\n    }\n    else if (rect1.left <= rect2.right && rect2.right <= rect1.right) {\n        horizontalIntersectionLength = rect2.right - Math.max(rect1.left, rect2.left);\n    }\n    let verticalIntersectionLength = 0;\n    if (rect2.top <= rect1.top && rect1.top <= rect2.bottom) {\n        verticalIntersectionLength = Math.min(rect1.bottom, rect2.bottom) - rect1.top;\n    }\n    else if (rect2.top <= rect1.bottom && rect1.bottom <= rect2.bottom) {\n        verticalIntersectionLength = rect1.bottom - Math.max(rect1.top, rect2.top);\n    }\n    else if (rect1.top <= rect2.top && rect2.top <= rect1.bottom) {\n        verticalIntersectionLength = Math.min(rect1.bottom, rect2.bottom) - rect2.top;\n    }\n    else if (rect1.top <= rect2.bottom && rect2.bottom <= rect1.bottom) {\n        verticalIntersectionLength = rect2.bottom - Math.max(rect1.top, rect2.top);\n    }\n    return horizontalIntersectionLength * verticalIntersectionLength;\n}\nexport function getGridPlacement(target, grid) {\n    function getMinDistance(min, current, collision) {\n        const minDistance = Math.abs(min - collision);\n        const currentDistance = Math.abs(current - collision);\n        return currentDistance < minDistance ? current : min;\n    }\n    let placement = {\n        top: Number.POSITIVE_INFINITY,\n        left: Number.POSITIVE_INFINITY,\n        right: Number.POSITIVE_INFINITY,\n        bottom: Number.POSITIVE_INFINITY,\n    };\n    for (const rect of grid) {\n        if (isIntersecting(rect, target)) {\n            placement = {\n                top: getMinDistance(placement.top, rect.top, target.top),\n                left: getMinDistance(placement.left, rect.left, target.left),\n                right: getMinDistance(placement.right, rect.right, target.right),\n                bottom: getMinDistance(placement.bottom, rect.bottom, target.bottom),\n            };\n        }\n    }\n    return placement;\n}\nexport function getClosestNeighbor(target, sources, direction) {\n    const getFirst = (rects) => { var _a; return (_a = rects[0]) !== null && _a !== void 0 ? _a : null; };\n    const verticalDiff = (r1, r2) => Math.abs(r1.top - target.top) - Math.abs(r2.top - target.top);\n    const horizontalDiff = (r1, r2) => Math.abs(r1.left - target.left) - Math.abs(r2.left - target.left);\n    switch (direction) {\n        case \"left\":\n            return getFirst(sources.filter((rect) => rect.right <= target.left).sort((r1, r2) => r2.left - r1.left || verticalDiff(r1, r2)));\n        case \"right\":\n            return getFirst(sources.filter((rect) => rect.left >= target.right).sort((r1, r2) => r1.left - r2.left || verticalDiff(r1, r2)));\n        case \"up\":\n            return getFirst(sources.filter((rect) => rect.bottom <= target.top).sort((r1, r2) => r2.top - r1.top || horizontalDiff(r1, r2)));\n        case \"down\":\n            return getFirst(sources.filter((rect) => rect.top >= target.bottom).sort((r1, r2) => r1.top - r2.top || horizontalDiff(r1, r2)));\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}