{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { getFocusables as getActualFocusables } from '../../internal/components/focus-lock/utils';\n// For the grid to have a single Tab stop all interactive element indices are updated to be -999.\n// The elements having tab index -999 are eligible for keyboard navigation but not for Tab navigation.\nconst PSEUDO_FOCUSABLE_TAB_INDEX = -999;\nconst FOCUSABLES_SELECTOR = `[tabIndex=\"0\"],[tabIndex=\"${PSEUDO_FOCUSABLE_TAB_INDEX}\"]`;\n/**\n * Finds focused cell props corresponding the focused element inside the table.\n * The function relies on ARIA colindex/rowindex attributes being correctly applied.\n */\nexport function findFocusinCell(event) {\n  var _a, _b;\n  if (!(event.target instanceof HTMLElement)) {\n    return null;\n  }\n  const element = event.target;\n  const cellElement = element.closest('td,th');\n  const rowElement = cellElement === null || cellElement === void 0 ? void 0 : cellElement.closest('tr');\n  if (!cellElement || !rowElement) {\n    return null;\n  }\n  const colIndex = parseInt((_a = cellElement.getAttribute('aria-colindex')) !== null && _a !== void 0 ? _a : '');\n  const rowIndex = parseInt((_b = rowElement.getAttribute('aria-rowindex')) !== null && _b !== void 0 ? _b : '');\n  if (isNaN(colIndex) || isNaN(rowIndex)) {\n    return null;\n  }\n  const cellFocusables = getFocusables(cellElement);\n  const elementIndex = cellFocusables.indexOf(element);\n  return {\n    rowIndex,\n    colIndex,\n    rowElement,\n    cellElement,\n    element,\n    elementIndex\n  };\n}\n/**\n * Moves table focus in the provided direction. The focus can transition between cells or interactive elements inside cells.\n */\nexport function moveFocusBy(table, from, delta) {\n  var _a;\n  // Find next row to move focus into (can be null if the top/bottom is reached).\n  const targetAriaRowIndex = from.rowIndex + delta.y;\n  const targetRow = findTableRowByAriaRowIndex(table, targetAriaRowIndex, delta.y);\n  if (!targetRow) {\n    return;\n  }\n  // Move focus to the next interactive cell content element if available.\n  const cellFocusables = getFocusables(from.cellElement);\n  const nextElementIndex = from.elementIndex + delta.x;\n  if (delta.x && from.elementIndex !== -1 && 0 <= nextElementIndex && nextElementIndex < cellFocusables.length) {\n    focus(cellFocusables[nextElementIndex]);\n    return;\n  }\n  // Find next cell to focus or move focus into (can be null if the left/right edge is reached).\n  const targetAriaColIndex = from.colIndex + delta.x;\n  const targetCell = findTableRowCellByAriaColIndex(targetRow, targetAriaColIndex, delta.x);\n  if (!targetCell) {\n    return;\n  }\n  // Move focus on the cell interactive content or the cell itself.\n  const targetCellFocusables = getFocusables(targetCell);\n  const focusIndex = delta.x < 0 ? targetCellFocusables.length - 1 : delta.x > 0 ? 0 : from.elementIndex;\n  const focusTarget = (_a = targetCellFocusables[focusIndex]) !== null && _a !== void 0 ? _a : targetCell;\n  focus(focusTarget);\n}\n/**\n * Makes the cell element, the first interactive element or the first cell of the table user-focusable.\n */\nexport function ensureSingleFocusable(table, cell) {\n  var _a;\n  const firstTableCell = table.querySelector('td,th');\n  // A single element of the table is made user-focusable.\n  // It defaults to the first interactive element of the first cell or the first cell itself otherwise.\n  let focusTarget = (_a = firstTableCell && getFocusables(firstTableCell)[0]) !== null && _a !== void 0 ? _a : firstTableCell;\n  // When a navigation-focused element is present in the table it is used for user-navigation instead.\n  if (cell && table.contains(cell.element)) {\n    focusTarget = cell.element;\n  }\n  setTabIndex(focusTarget, 0);\n}\n/**\n * Makes all element focusable children pseudo-focusable unless the grid navigation is suppressed.\n */\nexport function muteElementFocusables(element, suppressed) {\n  // When grid navigation is suppressed all interactive elements and all cells focus is unmuted to unblock Tab navigation.\n  // Leaving the interactive widget using Tab navigation moves the focus to the current or adjacent cell and un-suppresses\n  // the navigation when implemented correctly.\n  if (suppressed) {\n    for (const focusable of getFocusables(element)) {\n      setTabIndex(focusable, 0);\n    }\n    return;\n  }\n  // Assigning pseudo-focusable tab index to all cells and all interactive elements makes them focusable with grid navigation.\n  for (const focusable of getActualFocusables(element)) {\n    if (focusable !== document.activeElement) {\n      setTabIndex(focusable, PSEUDO_FOCUSABLE_TAB_INDEX);\n    }\n  }\n}\n/**\n * This cleanup code ensures all cells are no longer focusable but the interactive elements are.\n * Currently there are no use cases for it as we don't expect the navigation to be used conditionally.\n */\nexport function restoreElementFocusables(element) {\n  for (const focusable of getFocusables(element)) {\n    if (focusable instanceof HTMLTableCellElement) {\n      setTabIndex(focusable, -1);\n    } else {\n      setTabIndex(focusable, 0);\n    }\n  }\n}\n/**\n * Returns true if the target element or one of its parents is a dialog or is marked with data-awsui-table-suppress-navigation attribute.\n * This is used to suppress navigation for interactive content without a need to use a custom suppression check.\n */\nexport function defaultIsSuppressed(target) {\n  let current = target;\n  while (current) {\n    // Stop checking for parents upon reaching the cell element as the function only aims at the cell content.\n    const tagName = current.tagName.toLowerCase();\n    if (tagName === 'td' || tagName === 'th') {\n      return false;\n    }\n    if (current.getAttribute('role') === 'dialog' || current.getAttribute('data-awsui-table-suppress-navigation') === 'true') {\n      return true;\n    }\n    current = current.parentElement;\n  }\n  return false;\n}\n/**\n * Returns actually focusable or pseudo-focusable elements to find navigation targets.\n */\nexport function getFocusables(element) {\n  return Array.from(element.querySelectorAll(FOCUSABLES_SELECTOR));\n}\nexport function getFirstFocusable(element) {\n  return element.querySelector(FOCUSABLES_SELECTOR);\n}\n/**\n * Finds the closest row to the targetAriaRowIndex+delta in the direction of delta.\n */\nfunction findTableRowByAriaRowIndex(table, targetAriaRowIndex, delta) {\n  var _a;\n  let targetRow = null;\n  const rowElements = Array.from(table.querySelectorAll('tr[aria-rowindex]'));\n  if (delta < 0) {\n    rowElements.reverse();\n  }\n  for (const element of rowElements) {\n    const rowIndex = parseInt((_a = element.getAttribute('aria-rowindex')) !== null && _a !== void 0 ? _a : '');\n    targetRow = element;\n    if (rowIndex === targetAriaRowIndex) {\n      break;\n    }\n    if (delta >= 0 && rowIndex > targetAriaRowIndex) {\n      break;\n    }\n    if (delta < 0 && rowIndex < targetAriaRowIndex) {\n      break;\n    }\n  }\n  return targetRow;\n}\n/**\n * Finds the closest column to the targetAriaColIndex+delta in the direction of delta.\n */\nfunction findTableRowCellByAriaColIndex(tableRow, targetAriaColIndex, delta) {\n  var _a;\n  let targetCell = null;\n  const cellElements = Array.from(tableRow.querySelectorAll('td[aria-colindex],th[aria-colindex]'));\n  if (delta < 0) {\n    cellElements.reverse();\n  }\n  for (const element of cellElements) {\n    const columnIndex = parseInt((_a = element.getAttribute('aria-colindex')) !== null && _a !== void 0 ? _a : '');\n    targetCell = element;\n    if (columnIndex === targetAriaColIndex) {\n      break;\n    }\n    if (delta >= 0 && columnIndex > targetAriaColIndex) {\n      break;\n    }\n    if (delta < 0 && columnIndex < targetAriaColIndex) {\n      break;\n    }\n  }\n  return targetCell;\n}\nfunction focus(element) {\n  setTabIndex(element, 0);\n  element === null || element === void 0 ? void 0 : element.focus();\n}\nfunction setTabIndex(element, tabIndex) {\n  if (element && element.tabIndex !== tabIndex) {\n    element.tabIndex = tabIndex;\n  }\n}","map":{"version":3,"mappings":"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","names":["getFocusables","getActualFocusables","PSEUDO_FOCUSABLE_TAB_INDEX","FOCUSABLES_SELECTOR","findFocusinCell","event","target","HTMLElement","element","cellElement","closest","rowElement","colIndex","parseInt","getAttribute","rowIndex","isNaN","cellFocusables","elementIndex","indexOf","moveFocusBy","table","from","delta","targetAriaRowIndex","y","targetRow","findTableRowByAriaRowIndex","nextElementIndex","x","length","focus","targetAriaColIndex","targetCell","findTableRowCellByAriaColIndex","targetCellFocusables","focusIndex","focusTarget","ensureSingleFocusable","cell","firstTableCell","querySelector","contains","setTabIndex","muteElementFocusables","suppressed","focusable","document","activeElement","restoreElementFocusables","HTMLTableCellElement","defaultIsSuppressed","current","tagName","toLowerCase","parentElement","Array","querySelectorAll","getFirstFocusable","rowElements","reverse","tableRow","cellElements","columnIndex","tabIndex"],"sources":["/Users/tangyizhi/Desktop/Assignment2/frontend/node_modules/@cloudscape-design/components/table/table-role/lib/default/table/table-role/utils.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { getFocusables as getActualFocusables } from '../../internal/components/focus-lock/utils';\nimport { FocusedCell } from './interfaces';\n\n// For the grid to have a single Tab stop all interactive element indices are updated to be -999.\n// The elements having tab index -999 are eligible for keyboard navigation but not for Tab navigation.\nconst PSEUDO_FOCUSABLE_TAB_INDEX = -999;\nconst FOCUSABLES_SELECTOR = `[tabIndex=\"0\"],[tabIndex=\"${PSEUDO_FOCUSABLE_TAB_INDEX}\"]`;\n\n/**\n * Finds focused cell props corresponding the focused element inside the table.\n * The function relies on ARIA colindex/rowindex attributes being correctly applied.\n */\nexport function findFocusinCell(event: FocusEvent): null | FocusedCell {\n  if (!(event.target instanceof HTMLElement)) {\n    return null;\n  }\n  const element = event.target;\n\n  const cellElement = element.closest('td,th') as null | HTMLTableCellElement;\n  const rowElement = cellElement?.closest('tr');\n\n  if (!cellElement || !rowElement) {\n    return null;\n  }\n\n  const colIndex = parseInt(cellElement.getAttribute('aria-colindex') ?? '');\n  const rowIndex = parseInt(rowElement.getAttribute('aria-rowindex') ?? '');\n  if (isNaN(colIndex) || isNaN(rowIndex)) {\n    return null;\n  }\n\n  const cellFocusables = getFocusables(cellElement);\n  const elementIndex = cellFocusables.indexOf(element);\n\n  return { rowIndex, colIndex, rowElement, cellElement, element, elementIndex };\n}\n\n/**\n * Moves table focus in the provided direction. The focus can transition between cells or interactive elements inside cells.\n */\nexport function moveFocusBy(table: HTMLTableElement, from: FocusedCell, delta: { y: number; x: number }) {\n  // Find next row to move focus into (can be null if the top/bottom is reached).\n  const targetAriaRowIndex = from.rowIndex + delta.y;\n  const targetRow = findTableRowByAriaRowIndex(table, targetAriaRowIndex, delta.y);\n  if (!targetRow) {\n    return;\n  }\n\n  // Move focus to the next interactive cell content element if available.\n  const cellFocusables = getFocusables(from.cellElement);\n  const nextElementIndex = from.elementIndex + delta.x;\n  if (delta.x && from.elementIndex !== -1 && 0 <= nextElementIndex && nextElementIndex < cellFocusables.length) {\n    focus(cellFocusables[nextElementIndex]);\n    return;\n  }\n\n  // Find next cell to focus or move focus into (can be null if the left/right edge is reached).\n  const targetAriaColIndex = from.colIndex + delta.x;\n  const targetCell = findTableRowCellByAriaColIndex(targetRow, targetAriaColIndex, delta.x);\n  if (!targetCell) {\n    return;\n  }\n\n  // Move focus on the cell interactive content or the cell itself.\n  const targetCellFocusables = getFocusables(targetCell);\n  const focusIndex = delta.x < 0 ? targetCellFocusables.length - 1 : delta.x > 0 ? 0 : from.elementIndex;\n  const focusTarget = targetCellFocusables[focusIndex] ?? targetCell;\n  focus(focusTarget);\n}\n\n/**\n * Makes the cell element, the first interactive element or the first cell of the table user-focusable.\n */\nexport function ensureSingleFocusable(table: HTMLElement, cell: null | FocusedCell) {\n  const firstTableCell = table.querySelector('td,th') as null | HTMLTableCellElement;\n\n  // A single element of the table is made user-focusable.\n  // It defaults to the first interactive element of the first cell or the first cell itself otherwise.\n  let focusTarget: null | HTMLElement = (firstTableCell && getFocusables(firstTableCell)[0]) ?? firstTableCell;\n\n  // When a navigation-focused element is present in the table it is used for user-navigation instead.\n  if (cell && table.contains(cell.element)) {\n    focusTarget = cell.element;\n  }\n\n  setTabIndex(focusTarget, 0);\n}\n\n/**\n * Makes all element focusable children pseudo-focusable unless the grid navigation is suppressed.\n */\nexport function muteElementFocusables(element: HTMLElement, suppressed: boolean) {\n  // When grid navigation is suppressed all interactive elements and all cells focus is unmuted to unblock Tab navigation.\n  // Leaving the interactive widget using Tab navigation moves the focus to the current or adjacent cell and un-suppresses\n  // the navigation when implemented correctly.\n  if (suppressed) {\n    for (const focusable of getFocusables(element)) {\n      setTabIndex(focusable, 0);\n    }\n    return;\n  }\n\n  // Assigning pseudo-focusable tab index to all cells and all interactive elements makes them focusable with grid navigation.\n  for (const focusable of getActualFocusables(element)) {\n    if (focusable !== document.activeElement) {\n      setTabIndex(focusable, PSEUDO_FOCUSABLE_TAB_INDEX);\n    }\n  }\n}\n\n/**\n * This cleanup code ensures all cells are no longer focusable but the interactive elements are.\n * Currently there are no use cases for it as we don't expect the navigation to be used conditionally.\n */\nexport function restoreElementFocusables(element: HTMLTableElement) {\n  for (const focusable of getFocusables(element)) {\n    if (focusable instanceof HTMLTableCellElement) {\n      setTabIndex(focusable, -1);\n    } else {\n      setTabIndex(focusable, 0);\n    }\n  }\n}\n\n/**\n * Returns true if the target element or one of its parents is a dialog or is marked with data-awsui-table-suppress-navigation attribute.\n * This is used to suppress navigation for interactive content without a need to use a custom suppression check.\n */\nexport function defaultIsSuppressed(target: HTMLElement) {\n  let current: null | HTMLElement = target;\n  while (current) {\n    // Stop checking for parents upon reaching the cell element as the function only aims at the cell content.\n    const tagName = current.tagName.toLowerCase();\n    if (tagName === 'td' || tagName === 'th') {\n      return false;\n    }\n    if (\n      current.getAttribute('role') === 'dialog' ||\n      current.getAttribute('data-awsui-table-suppress-navigation') === 'true'\n    ) {\n      return true;\n    }\n    current = current.parentElement;\n  }\n  return false;\n}\n\n/**\n * Returns actually focusable or pseudo-focusable elements to find navigation targets.\n */\nexport function getFocusables(element: HTMLElement) {\n  return Array.from(element.querySelectorAll(FOCUSABLES_SELECTOR)) as HTMLElement[];\n}\n\nexport function getFirstFocusable(element: HTMLElement) {\n  return element.querySelector(FOCUSABLES_SELECTOR) as null | HTMLElement;\n}\n\n/**\n * Finds the closest row to the targetAriaRowIndex+delta in the direction of delta.\n */\nfunction findTableRowByAriaRowIndex(table: HTMLTableElement, targetAriaRowIndex: number, delta: number) {\n  let targetRow: null | HTMLTableRowElement = null;\n  const rowElements = Array.from(table.querySelectorAll('tr[aria-rowindex]'));\n  if (delta < 0) {\n    rowElements.reverse();\n  }\n  for (const element of rowElements) {\n    const rowIndex = parseInt(element.getAttribute('aria-rowindex') ?? '');\n    targetRow = element as HTMLTableRowElement;\n\n    if (rowIndex === targetAriaRowIndex) {\n      break;\n    }\n    if (delta >= 0 && rowIndex > targetAriaRowIndex) {\n      break;\n    }\n    if (delta < 0 && rowIndex < targetAriaRowIndex) {\n      break;\n    }\n  }\n  return targetRow;\n}\n\n/**\n * Finds the closest column to the targetAriaColIndex+delta in the direction of delta.\n */\nfunction findTableRowCellByAriaColIndex(tableRow: HTMLTableRowElement, targetAriaColIndex: number, delta: number) {\n  let targetCell: null | HTMLTableCellElement = null;\n  const cellElements = Array.from(tableRow.querySelectorAll('td[aria-colindex],th[aria-colindex]'));\n  if (delta < 0) {\n    cellElements.reverse();\n  }\n  for (const element of cellElements) {\n    const columnIndex = parseInt(element.getAttribute('aria-colindex') ?? '');\n    targetCell = element as HTMLTableCellElement;\n\n    if (columnIndex === targetAriaColIndex) {\n      break;\n    }\n    if (delta >= 0 && columnIndex > targetAriaColIndex) {\n      break;\n    }\n    if (delta < 0 && columnIndex < targetAriaColIndex) {\n      break;\n    }\n  }\n  return targetCell;\n}\n\nfunction focus(element: null | HTMLElement) {\n  setTabIndex(element, 0);\n  element?.focus();\n}\n\nfunction setTabIndex(element: null | HTMLElement, tabIndex: number) {\n  if (element && element.tabIndex !== tabIndex) {\n    element.tabIndex = tabIndex;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}