{"ast":null,"code":"import _defineProperty from \"/Users/tangyizhi/Desktop/Assignment2/frontend/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _createForOfIteratorHelper from \"/Users/tangyizhi/Desktop/Assignment2/frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _slicedToArray from \"/Users/tangyizhi/Desktop/Assignment2/frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport { __rest } from \"tslib\";\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport React, { useCallback, useEffect, useMemo, useRef, useState } from 'react';\nimport { OpenAnnotation } from './annotation/open-annotation';\nimport { ClosedAnnotation } from './annotation/closed-annotation';\nimport { hotspotContext } from './context';\nimport { fireNonCancelableEvent } from '../internal/events';\nimport { useTelemetry } from '../internal/hooks/use-telemetry';\nimport { applyDisplayName } from '../internal/utils/apply-display-name';\nimport { getStepInfo } from './utils';\n// constant empty array to keep hook dependency stable\nvar emptyTasks = [];\nexport default function AnnotationContext(_ref) {\n  var currentTutorial = _ref.currentTutorial,\n    children = _ref.children,\n    onStepChange = _ref.onStepChange,\n    onFinishHandler = _ref.onFinish,\n    onStartTutorial = _ref.onStartTutorial,\n    onExitTutorial = _ref.onExitTutorial,\n    i18nStrings = _ref.i18nStrings;\n  var _a, _b, _c, _d;\n  useTelemetry('AnnotationContext');\n  var _useState = useState(true),\n    _useState2 = _slicedToArray(_useState, 2),\n    open = _useState2[0],\n    setOpen = _useState2[1];\n  var _useState3 = useState(0),\n    _useState4 = _slicedToArray(_useState3, 2),\n    currentStepIndex = _useState4[0],\n    setCurrentStepIndex = _useState4[1];\n  useEffect(function () {\n    // When a tutorial is started, we reset the progress to the first step.\n    setCurrentStepIndex(0);\n    setOpen(true);\n  }, [currentTutorial, setOpen]);\n  var _useState5 = useState({}),\n    _useState6 = _slicedToArray(_useState5, 2),\n    availableHotspots = _useState6[0],\n    setAvailableHotspots = _useState6[1];\n  // availableHotspots is mirrored in this ref to prevent endless loops\n  // in between registerHotspot and unregisterHotspot callbacks.\n  var availableHotspotsRef = useRef(availableHotspots);\n  var annotations = currentTutorial ? currentTutorial.tasks : emptyTasks;\n  var _getStepInfo = getStepInfo(annotations, currentStepIndex),\n    task = _getStepInfo.task,\n    step = _getStepInfo.step,\n    localIndex = _getStepInfo.localIndex,\n    taskIndex = _getStepInfo.taskIndex;\n  var currentId = step === null || step === void 0 ? void 0 : step.hotspotId;\n  var totalStepCount = annotations.map(function (a) {\n    return a.steps.length;\n  }).reduce(function (a, b) {\n    return a + b;\n  }, 0);\n  var id2index = useMemo(function () {\n    var mapping = {};\n    var counter = 0;\n    var _iterator = _createForOfIteratorHelper(annotations),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var annotation = _step.value;\n        var _iterator2 = _createForOfIteratorHelper(annotation.steps),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var _step3 = _step2.value;\n            if (mapping[_step3.hotspotId] === undefined) {\n              mapping[_step3.hotspotId] = counter;\n            }\n            counter++;\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    return mapping;\n  }, [annotations]);\n  var openNextStep = useCallback(function () {\n    var newStepIndex = Math.min(currentStepIndex + 1, totalStepCount);\n    setCurrentStepIndex(newStepIndex);\n    fireNonCancelableEvent(onStepChange, {\n      step: newStepIndex,\n      reason: 'next'\n    });\n  }, [currentStepIndex, onStepChange, totalStepCount]);\n  var openPreviousStep = useCallback(function () {\n    var newStepIndex = Math.max(currentStepIndex - 1, 0);\n    setCurrentStepIndex(newStepIndex);\n    fireNonCancelableEvent(onStepChange, {\n      step: newStepIndex,\n      reason: 'previous'\n    });\n  }, [onStepChange, currentStepIndex]);\n  var onFinish = useCallback(function () {\n    return fireNonCancelableEvent(onFinishHandler);\n  }, [onFinishHandler]);\n  /**\n   * If the currently open hotspot disappears from the page (e.g. because of a react-router navigation),\n   * this Effect detects the nearest available hotspot and changes to it. This allows us to e.g. automatically\n   * advance to the first step on the new page (or the last step on the previous page, in case the user\n   * navigates back).\n   */\n  var isCurrentHotspotAvailable = currentId ? availableHotspots[currentId] : null;\n  useEffect(function () {\n    if (!currentId || availableHotspotsRef.current[currentId]) {\n      return;\n    }\n    var findNearestHotspot = function findNearestHotspot() {\n      var nearestHotspot = undefined;\n      var nearestDistance = Infinity;\n      for (var _i = 0, _Object$keys = Object.keys(availableHotspotsRef.current); _i < _Object$keys.length; _i++) {\n        var hotspotId = _Object$keys[_i];\n        var distanceFromCurrentHotspot = Math.abs(id2index[hotspotId] - currentStepIndex);\n        if (distanceFromCurrentHotspot < nearestDistance) {\n          nearestDistance = distanceFromCurrentHotspot;\n          nearestHotspot = hotspotId;\n        }\n      }\n      return nearestHotspot;\n    };\n    var nearestHotspot = findNearestHotspot();\n    if (nearestHotspot) {\n      var newStepIndex = id2index[nearestHotspot];\n      setCurrentStepIndex(newStepIndex);\n      setOpen(true);\n      fireNonCancelableEvent(onStepChange, {\n        step: newStepIndex,\n        reason: 'auto-fallback'\n      });\n    }\n  }, [annotations, isCurrentHotspotAvailable, currentId, currentStepIndex, id2index, onStepChange]);\n  var onDismiss = useCallback(function () {\n    setOpen(false);\n  }, [setOpen]);\n  var onOpen = useCallback(function (stepIndex) {\n    setCurrentStepIndex(stepIndex);\n    fireNonCancelableEvent(onStepChange, {\n      step: stepIndex,\n      reason: 'open'\n    });\n    setOpen(true);\n  }, [onStepChange, setOpen]);\n  var idOfPreviousHotspot = (_a = getStepInfo(annotations, currentStepIndex - 1).step) === null || _a === void 0 ? void 0 : _a.hotspotId;\n  var idOfNextHotspot = (_b = getStepInfo(annotations, currentStepIndex + 1).step) === null || _b === void 0 ? void 0 : _b.hotspotId;\n  var previousHotspotIsAvailable = (_c = idOfPreviousHotspot !== undefined && availableHotspots[idOfPreviousHotspot]) !== null && _c !== void 0 ? _c : false;\n  var nextHotspotIsAvailable = (_d = idOfNextHotspot !== undefined && availableHotspots[idOfNextHotspot]) !== null && _d !== void 0 ? _d : false;\n  var getContentForId = useCallback(function (id, direction) {\n    if (currentTutorial === null || currentTutorial === void 0 ? void 0 : currentTutorial.completed) {\n      return null;\n    }\n    var globalStepIndex = id2index[id];\n    if (globalStepIndex === undefined) {\n      // This hotspot is not used in the current tutorial.\n      return null;\n    }\n    if (!task || !step || !open || id !== currentId) {\n      var _getStepInfo2 = getStepInfo(annotations, globalStepIndex),\n        currentTask = _getStepInfo2.task,\n        _currentStepIndex = _getStepInfo2.localIndex;\n      return React.createElement(ClosedAnnotation, {\n        globalStepIndex: globalStepIndex,\n        i18nStrings: i18nStrings,\n        onOpen: onOpen,\n        focusOnRender: id === currentId,\n        totalLocalSteps: currentTask ? currentTask.steps.length : 0,\n        taskLocalStepIndex: _currentStepIndex\n      });\n    }\n    return React.createElement(OpenAnnotation, {\n      i18nStrings: i18nStrings,\n      direction: direction,\n      title: i18nStrings.taskTitle(taskIndex, task.title),\n      content: step.content,\n      alert: step.warningAlert,\n      showPreviousButton: currentStepIndex !== 0,\n      showFinishButton: currentStepIndex + 1 === totalStepCount,\n      taskLocalStepIndex: localIndex,\n      totalLocalSteps: task.steps.length,\n      nextButtonEnabled: nextHotspotIsAvailable,\n      onNextButtonClick: openNextStep,\n      onFinish: onFinish,\n      previousButtonEnabled: previousHotspotIsAvailable,\n      onPreviousButtonClick: openPreviousStep,\n      onDismiss: onDismiss\n    });\n  }, [id2index, currentTutorial, task, step, open, currentId, currentStepIndex, i18nStrings, taskIndex, localIndex, totalStepCount, nextHotspotIsAvailable, openNextStep, onFinish, previousHotspotIsAvailable, openPreviousStep, onDismiss, onOpen, annotations]);\n  var registerHotspot = useCallback(function (id) {\n    if (!id2index || id2index[id] === undefined) {\n      // This hotspot is not used in the current tutorial.\n      return;\n    }\n    /*\n      To ensure that all hotspots are immediately known to all triggered useEffects, we\n      need to update the availableHotspotsRef BEFORE the setAvailableHotspots calls, since\n      they will be batched and delayed until after the useEffects are run.\n    */\n    availableHotspotsRef.current = Object.assign(Object.assign({}, availableHotspotsRef.current), _defineProperty({}, id, true));\n    setAvailableHotspots(function (availableHotspots) {\n      if (availableHotspots[id]) {\n        return availableHotspots;\n      }\n      return Object.assign(Object.assign({}, availableHotspots), _defineProperty({}, id, true));\n    });\n  },\n  // We need to react on id2index changes for registering new hotspots when the map changes.\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  [id2index]);\n  var unregisterHotspot = useCallback(function (id) {\n    if (!availableHotspotsRef.current[id]) {\n      // Prevents unnecessary re-renders.\n      return;\n    }\n    /*\n      To ensure that all hotspots are immediately known to all triggered useEffects, we\n      need to update the availableHotspotsRef BEFORE the setAvailableHotspots calls, since\n      they will be batched and delayed until after the useEffects are run.\n    */\n    availableHotspotsRef.current = removeKey(id, availableHotspotsRef.current);\n    setAvailableHotspots(function (availableHotspots) {\n      if (!availableHotspots[id]) {\n        return availableHotspots;\n      }\n      return removeKey(id, availableHotspots);\n    });\n  }, []);\n  var context = {\n    getContentForId: getContentForId,\n    registerHotspot: registerHotspot,\n    unregisterHotspot: unregisterHotspot,\n    onStartTutorial: onStartTutorial,\n    onExitTutorial: onExitTutorial,\n    currentStepIndex: currentStepIndex,\n    currentTutorial: currentTutorial\n  };\n  return React.createElement(hotspotContext.Provider, {\n    value: context\n  }, children);\n}\napplyDisplayName(AnnotationContext, 'AnnotationContext');\nfunction removeKey(key, object) {\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  var _a = object,\n    _b = key,\n    _ = _a[_b],\n    remainingObject = __rest(_a, [typeof _b === \"symbol\" ? _b : _b + \"\"]);\n  return remainingObject;\n}","map":{"version":3,"mappings":";;;;AAAA;AACA;AACA,OAAOA,KAAK,IAAIC,WAAW,EAAEC,SAAS,EAAEC,OAAO,EAAEC,MAAM,EAAEC,QAAQ,QAAQ,OAAO;AAEhF,SAASC,cAAc,QAAQ,8BAA8B;AAC7D,SAASC,gBAAgB,QAAQ,gCAAgC;AAEjE,SAAyBC,cAAc,QAAQ,WAAW;AAC1D,SAASC,sBAAsB,QAAQ,oBAAoB;AAE3D,SAASC,YAAY,QAAQ,iCAAiC;AAC9D,SAASC,gBAAgB,QAAQ,sCAAsC;AACvE,SAASC,WAAW,QAAQ,SAAS;AAIrC;AACA,IAAMC,UAAU,GAA+C,EAAE;AAEjE,eAAc,SAAUC,iBAAiB,OAQhB;EAAA,IAPvBC,eAAe,QAAfA,eAAe;IACfC,QAAQ,QAARA,QAAQ;IACRC,YAAY,QAAZA,YAAY;IACFC,eAAe,QAAzBC,QAAQ;IACRC,eAAe,QAAfA,eAAe;IACfC,cAAc,QAAdA,cAAc;IACdC,WAAW,QAAXA,WAAW;;EAEXZ,YAAY,CAAC,mBAAmB,CAAC;EAEjC,gBAAwBL,QAAQ,CAAC,IAAI,CAAC;IAAA;IAA/BkB,IAAI;IAAEC,OAAO;EAEpB,iBAAgDnB,QAAQ,CAAC,CAAC,CAAC;IAAA;IAApDoB,gBAAgB;IAAEC,mBAAmB;EAC5CxB,SAAS,CAAC,YAAK;IACb;IACAwB,mBAAmB,CAAC,CAAC,CAAC;IACtBF,OAAO,CAAC,IAAI,CAAC;EACf,CAAC,EAAE,CAACT,eAAe,EAAES,OAAO,CAAC,CAAC;EAE9B,iBAAkDnB,QAAQ,CAAmC,EAAE,CAAC;IAAA;IAAzFsB,iBAAiB;IAAEC,oBAAoB;EAC9C;EACA;EACA,IAAMC,oBAAoB,GAAGzB,MAAM,CAAmCuB,iBAAiB,CAAC;EAExF,IAAMG,WAAW,GAAGf,eAAe,GAAGA,eAAe,CAACgB,KAAK,GAAGlB,UAAU;EACxE,mBAA8CD,WAAW,CAACkB,WAAW,EAAEL,gBAAgB,CAAC;IAAhFO,IAAI,gBAAJA,IAAI;IAAEC,IAAI,gBAAJA,IAAI;IAAEC,UAAU,gBAAVA,UAAU;IAAEC,SAAS,gBAATA,SAAS;EACzC,IAAMC,SAAS,GAAGH,IAAI,aAAJA,IAAI,uBAAJA,IAAI,CAAEI,SAAS;EACjC,IAAMC,cAAc,GAAGR,WAAW,CAACS,GAAG,CAAC,WAAC;IAAA,OAAIC,CAAC,CAACC,KAAK,CAACC,MAAM;EAAA,EAAC,CAACC,MAAM,CAAC,UAACH,CAAC,EAAEI,CAAC;IAAA,OAAKJ,CAAC,GAAGI,CAAC;EAAA,GAAE,CAAC,CAAC;EAEtF,IAAMC,QAAQ,GAAG1C,OAAO,CAAC,YAAK;IAC5B,IAAM2C,OAAO,GAA2B,EAAE;IAE1C,IAAIC,OAAO,GAAG,CAAC;IAAC,2CACSjB,WAAW;MAAA;IAAA;MAApC,oDAAsC;QAAA,IAA3BkB,UAAU;QAAA,4CACAA,UAAU,CAACP,KAAK;UAAA;QAAA;UAAnC,uDAAqC;YAAA,IAA1BR,MAAI;YACb,IAAIa,OAAO,CAACb,MAAI,CAACI,SAAS,CAAC,KAAKY,SAAS,EAAE;cACzCH,OAAO,CAACb,MAAI,CAACI,SAAS,CAAC,GAAGU,OAAO;;YAEnCA,OAAO,EAAE;;QACV;UAAA;QAAA;UAAA;QAAA;;IACF;MAAA;IAAA;MAAA;IAAA;IAED,OAAOD,OAAO;EAChB,CAAC,EAAE,CAAChB,WAAW,CAAC,CAAC;EAEjB,IAAMoB,YAAY,GAAGjD,WAAW,CAAC,YAAK;IACpC,IAAMkD,YAAY,GAAGC,IAAI,CAACC,GAAG,CAAC5B,gBAAgB,GAAG,CAAC,EAAEa,cAAc,CAAC;IACnEZ,mBAAmB,CAACyB,YAAY,CAAC;IACjC1C,sBAAsB,CAACQ,YAAY,EAAE;MAAEgB,IAAI,EAAEkB,YAAY;MAAEG,MAAM,EAAE;IAAM,CAAE,CAAC;EAC9E,CAAC,EAAE,CAAC7B,gBAAgB,EAAER,YAAY,EAAEqB,cAAc,CAAC,CAAC;EAEpD,IAAMiB,gBAAgB,GAAGtD,WAAW,CAAC,YAAK;IACxC,IAAMkD,YAAY,GAAGC,IAAI,CAACI,GAAG,CAAC/B,gBAAgB,GAAG,CAAC,EAAE,CAAC,CAAC;IACtDC,mBAAmB,CAACyB,YAAY,CAAC;IACjC1C,sBAAsB,CAACQ,YAAY,EAAE;MAAEgB,IAAI,EAAEkB,YAAY;MAAEG,MAAM,EAAE;IAAU,CAAE,CAAC;EAClF,CAAC,EAAE,CAACrC,YAAY,EAAEQ,gBAAgB,CAAC,CAAC;EAEpC,IAAMN,QAAQ,GAAGlB,WAAW,CAAC;IAAA,OAAMQ,sBAAsB,CAACS,eAAe,CAAC;EAAA,GAAE,CAACA,eAAe,CAAC,CAAC;EAE9F;;;;;;EAMA,IAAMuC,yBAAyB,GAAGrB,SAAS,GAAGT,iBAAiB,CAACS,SAAS,CAAC,GAAG,IAAI;EACjFlC,SAAS,CAAC,YAAK;IACb,IAAI,CAACkC,SAAS,IAAIP,oBAAoB,CAAC6B,OAAO,CAACtB,SAAS,CAAC,EAAE;MACzD;;IAGF,IAAMuB,kBAAkB,GAAG,SAArBA,kBAAkB,GAAQ;MAC9B,IAAIC,cAAc,GAAuBX,SAAS;MAClD,IAAIY,eAAe,GAAGC,QAAQ;MAC9B,gCAAwBC,MAAM,CAACC,IAAI,CAACnC,oBAAoB,CAAC6B,OAAO,CAAC,kCAAE;QAA9D,IAAMrB,SAAS;QAClB,IAAM4B,0BAA0B,GAAGb,IAAI,CAACc,GAAG,CAACrB,QAAQ,CAACR,SAAS,CAAC,GAAGZ,gBAAgB,CAAC;QACnF,IAAIwC,0BAA0B,GAAGJ,eAAe,EAAE;UAChDA,eAAe,GAAGI,0BAA0B;UAC5CL,cAAc,GAAGvB,SAAS;;;MAG9B,OAAOuB,cAAc;IACvB,CAAC;IAED,IAAMA,cAAc,GAAGD,kBAAkB,EAAE;IAC3C,IAAIC,cAAc,EAAE;MAClB,IAAMT,YAAY,GAAGN,QAAQ,CAACe,cAAc,CAAC;MAC7ClC,mBAAmB,CAACyB,YAAY,CAAC;MACjC3B,OAAO,CAAC,IAAI,CAAC;MACbf,sBAAsB,CAACQ,YAAY,EAAE;QAAEgB,IAAI,EAAEkB,YAAY;QAAEG,MAAM,EAAE;MAAe,CAAE,CAAC;;EAEzF,CAAC,EAAE,CAACxB,WAAW,EAAE2B,yBAAyB,EAAErB,SAAS,EAAEX,gBAAgB,EAAEoB,QAAQ,EAAE5B,YAAY,CAAC,CAAC;EAEjG,IAAMkD,SAAS,GAAGlE,WAAW,CAAC,YAAK;IACjCuB,OAAO,CAAC,KAAK,CAAC;EAChB,CAAC,EAAE,CAACA,OAAO,CAAC,CAAC;EAEb,IAAM4C,MAAM,GAAGnE,WAAW,CACxB,UAACoE,SAAiB,EAAI;IACpB3C,mBAAmB,CAAC2C,SAAS,CAAC;IAC9B5D,sBAAsB,CAACQ,YAAY,EAAE;MAAEgB,IAAI,EAAEoC,SAAS;MAAEf,MAAM,EAAE;IAAM,CAAE,CAAC;IACzE9B,OAAO,CAAC,IAAI,CAAC;EACf,CAAC,EACD,CAACP,YAAY,EAAEO,OAAO,CAAC,CACxB;EAED,IAAM8C,mBAAmB,GAAG,iBAAW,CAACxC,WAAW,EAAEL,gBAAgB,GAAG,CAAC,CAAC,CAACQ,IAAI,0CAAEI,SAAS;EAC1F,IAAMkC,eAAe,GAAG,iBAAW,CAACzC,WAAW,EAAEL,gBAAgB,GAAG,CAAC,CAAC,CAACQ,IAAI,0CAAEI,SAAS;EACtF,IAAMmC,0BAA0B,GAC9B,MAACF,mBAAmB,KAAKrB,SAAS,IAAItB,iBAAiB,CAAC2C,mBAAmB,CAAE,mCAAI,KAAK;EACxF,IAAMG,sBAAsB,GAAG,MAACF,eAAe,KAAKtB,SAAS,IAAItB,iBAAiB,CAAC4C,eAAe,CAAE,mCAAI,KAAK;EAE7G,IAAMG,eAAe,GAAGzE,WAAW,CACjC,UAAC0E,EAAU,EAAEC,SAAoC,EAAI;IACnD,IAAI7D,eAAe,aAAfA,eAAe,uBAAfA,eAAe,CAAE8D,SAAS,EAAE;MAC9B,OAAO,IAAI;;IAGb,IAAMC,eAAe,GAAGjC,QAAQ,CAAC8B,EAAE,CAAC;IACpC,IAAIG,eAAe,KAAK7B,SAAS,EAAE;MACjC;MACA,OAAO,IAAI;;IAGb,IAAI,CAACjB,IAAI,IAAI,CAACC,IAAI,IAAI,CAACV,IAAI,IAAIoD,EAAE,KAAKvC,SAAS,EAAE;MAC/C,oBAA4DxB,WAAW,CAACkB,WAAW,EAAEgD,eAAe,CAAC;QAAvFC,WAAW,iBAAjB/C,IAAI;QAA2BP,iBAAgB,iBAA5BS,UAAU;MACrC,OACElC,oBAACO,gBAAgB;QACfuE,eAAe,EAAEA,eAAe;QAChCxD,WAAW,EAAEA,WAAW;QACxB8C,MAAM,EAAEA,MAAM;QACdY,aAAa,EAAEL,EAAE,KAAKvC,SAAS;QAC/B6C,eAAe,EAAEF,WAAW,GAAGA,WAAW,CAACtC,KAAK,CAACC,MAAM,GAAG,CAAC;QAC3DwC,kBAAkB,EAAEzD;MAAgB,EACpC;;IAIN,OACEzB,oBAACM,cAAc;MACbgB,WAAW,EAAEA,WAAW;MACxBsD,SAAS,EAAEA,SAAS;MACpBO,KAAK,EAAE7D,WAAW,CAAC8D,SAAS,CAACjD,SAAS,EAAEH,IAAI,CAACmD,KAAK,CAAC;MACnDE,OAAO,EAAEpD,IAAI,CAACoD,OAAO;MACrBC,KAAK,EAAErD,IAAI,CAACsD,YAAY;MACxBC,kBAAkB,EAAE/D,gBAAgB,KAAK,CAAC;MAC1CgE,gBAAgB,EAAEhE,gBAAgB,GAAG,CAAC,KAAKa,cAAc;MACzD4C,kBAAkB,EAAEhD,UAAU;MAC9B+C,eAAe,EAAEjD,IAAI,CAACS,KAAK,CAACC,MAAM;MAClCgD,iBAAiB,EAAEjB,sBAAsB;MACzCkB,iBAAiB,EAAEzC,YAAY;MAC/B/B,QAAQ,EAAEA,QAAQ;MAClByE,qBAAqB,EAAEpB,0BAA0B;MACjDqB,qBAAqB,EAAEtC,gBAAgB;MACvCY,SAAS,EAAEA;IAAS,EACpB;EAEN,CAAC,EACD,CACEtB,QAAQ,EACR9B,eAAe,EACfiB,IAAI,EACJC,IAAI,EACJV,IAAI,EACJa,SAAS,EACTX,gBAAgB,EAChBH,WAAW,EACXa,SAAS,EACTD,UAAU,EACVI,cAAc,EACdmC,sBAAsB,EACtBvB,YAAY,EACZ/B,QAAQ,EACRqD,0BAA0B,EAC1BjB,gBAAgB,EAChBY,SAAS,EACTC,MAAM,EACNtC,WAAW,CACZ,CACF;EAED,IAAMgE,eAAe,GAAG7F,WAAW,CACjC,UAAC0E,EAAU,EAAI;IACb,IAAI,CAAC9B,QAAQ,IAAIA,QAAQ,CAAC8B,EAAE,CAAC,KAAK1B,SAAS,EAAE;MAC3C;MACA;;IAGF;;;;;IAKApB,oBAAoB,CAAC6B,OAAO,GAAGK,gCAAKlC,oBAAoB,CAAC6B,OAAO,uBAAGiB,EAAE,EAAG,IAAI,EAAW;IAEvF/C,oBAAoB,CAAC,2BAAiB,EAAG;MACvC,IAAID,iBAAiB,CAACgD,EAAE,CAAC,EAAE;QACzB,OAAOhD,iBAAiB;;MAG1B,OAAOoC,gCAAKpC,iBAAiB,uBAAGgD,EAAE,EAAG,IAAI,EAAW;IACtD,CAAC,CAAC;EACJ,CAAC;EACD;EACA;EACA,CAAC9B,QAAQ,CAAC,CACX;EAED,IAAMkD,iBAAiB,GAAG9F,WAAW,CAAC,UAAC0E,EAAU,EAAI;IACnD,IAAI,CAAC9C,oBAAoB,CAAC6B,OAAO,CAACiB,EAAE,CAAC,EAAE;MACrC;MACA;;IAGF;;;;;IAKA9C,oBAAoB,CAAC6B,OAAO,GAAGsC,SAAS,CAACrB,EAAE,EAAE9C,oBAAoB,CAAC6B,OAAO,CAAC;IAE1E9B,oBAAoB,CAAC,2BAAiB,EAAG;MACvC,IAAI,CAACD,iBAAiB,CAACgD,EAAE,CAAC,EAAE;QAC1B,OAAOhD,iBAAiB;;MAG1B,OAAOqE,SAAS,CAACrB,EAAE,EAAEhD,iBAAiB,CAAC;IACzC,CAAC,CAAC;EACJ,CAAC,EAAE,EAAE,CAAC;EAEN,IAAMsE,OAAO,GAAmB;IAC9BvB,eAAe,EAAfA,eAAe;IACfoB,eAAe,EAAfA,eAAe;IACfC,iBAAiB,EAAjBA,iBAAiB;IACjB3E,eAAe,EAAfA,eAAe;IACfC,cAAc,EAAdA,cAAc;IACdI,gBAAgB,EAAhBA,gBAAgB;IAChBV,eAAe,EAAfA;GACD;EAED,OAAOf,oBAACQ,cAAc,CAAC0F,QAAQ;IAACC,KAAK,EAAEF;EAAO,GAAGjF,QAAQ,CAA2B;AACtF;AAEAL,gBAAgB,CAACG,iBAAiB,EAAE,mBAAmB,CAAC;AAExD,SAASkF,SAAS,CAAgCI,GAAY,EAAEC,MAAS;EACvE;EACA,IAAyCC,WAAM;IAAvCC,KAACH,GAAI;IAAEI,CAAC;IAAKC,eAAe,cAA9B,uCAAgC,CAAS;EAC/C,OAAOA,eAAe;AACxB","names":["React","useCallback","useEffect","useMemo","useRef","useState","OpenAnnotation","ClosedAnnotation","hotspotContext","fireNonCancelableEvent","useTelemetry","applyDisplayName","getStepInfo","emptyTasks","AnnotationContext","currentTutorial","children","onStepChange","onFinishHandler","onFinish","onStartTutorial","onExitTutorial","i18nStrings","open","setOpen","currentStepIndex","setCurrentStepIndex","availableHotspots","setAvailableHotspots","availableHotspotsRef","annotations","tasks","task","step","localIndex","taskIndex","currentId","hotspotId","totalStepCount","map","a","steps","length","reduce","b","id2index","mapping","counter","annotation","undefined","openNextStep","newStepIndex","Math","min","reason","openPreviousStep","max","isCurrentHotspotAvailable","current","findNearestHotspot","nearestHotspot","nearestDistance","Infinity","Object","keys","distanceFromCurrentHotspot","abs","onDismiss","onOpen","stepIndex","idOfPreviousHotspot","idOfNextHotspot","previousHotspotIsAvailable","nextHotspotIsAvailable","getContentForId","id","direction","completed","globalStepIndex","currentTask","focusOnRender","totalLocalSteps","taskLocalStepIndex","title","taskTitle","content","alert","warningAlert","showPreviousButton","showFinishButton","nextButtonEnabled","onNextButtonClick","previousButtonEnabled","onPreviousButtonClick","registerHotspot","unregisterHotspot","removeKey","context","Provider","value","key","object","_a","_b","_","remainingObject"],"sources":["/Users/tangyizhi/Desktop/Assignment2/frontend/node_modules/@cloudscape-design/components/annotation-context/lib/default/annotation-context/index.tsx"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport React, { useCallback, useEffect, useMemo, useRef, useState } from 'react';\n\nimport { OpenAnnotation } from './annotation/open-annotation';\nimport { ClosedAnnotation } from './annotation/closed-annotation';\nimport { AnnotationContextProps } from './interfaces';\nimport { HotspotContext, hotspotContext } from './context';\nimport { fireNonCancelableEvent } from '../internal/events';\nimport { HotspotProps } from '../hotspot/interfaces';\nimport { useTelemetry } from '../internal/hooks/use-telemetry';\nimport { applyDisplayName } from '../internal/utils/apply-display-name';\nimport { getStepInfo } from './utils';\n\nexport { AnnotationContextProps };\n\n// constant empty array to keep hook dependency stable\nconst emptyTasks: ReadonlyArray<AnnotationContextProps.Task> = [];\n\nexport default function AnnotationContext({\n  currentTutorial,\n  children,\n  onStepChange,\n  onFinish: onFinishHandler,\n  onStartTutorial,\n  onExitTutorial,\n  i18nStrings,\n}: AnnotationContextProps): JSX.Element {\n  useTelemetry('AnnotationContext');\n\n  const [open, setOpen] = useState(true);\n\n  const [currentStepIndex, setCurrentStepIndex] = useState(0);\n  useEffect(() => {\n    // When a tutorial is started, we reset the progress to the first step.\n    setCurrentStepIndex(0);\n    setOpen(true);\n  }, [currentTutorial, setOpen]);\n\n  const [availableHotspots, setAvailableHotspots] = useState<Record<string, true | undefined>>({});\n  // availableHotspots is mirrored in this ref to prevent endless loops\n  // in between registerHotspot and unregisterHotspot callbacks.\n  const availableHotspotsRef = useRef<Record<string, true | undefined>>(availableHotspots);\n\n  const annotations = currentTutorial ? currentTutorial.tasks : emptyTasks;\n  const { task, step, localIndex, taskIndex } = getStepInfo(annotations, currentStepIndex);\n  const currentId = step?.hotspotId;\n  const totalStepCount = annotations.map(a => a.steps.length).reduce((a, b) => a + b, 0);\n\n  const id2index = useMemo(() => {\n    const mapping: Record<string, number> = {};\n\n    let counter = 0;\n    for (const annotation of annotations) {\n      for (const step of annotation.steps) {\n        if (mapping[step.hotspotId] === undefined) {\n          mapping[step.hotspotId] = counter;\n        }\n        counter++;\n      }\n    }\n\n    return mapping;\n  }, [annotations]);\n\n  const openNextStep = useCallback(() => {\n    const newStepIndex = Math.min(currentStepIndex + 1, totalStepCount);\n    setCurrentStepIndex(newStepIndex);\n    fireNonCancelableEvent(onStepChange, { step: newStepIndex, reason: 'next' });\n  }, [currentStepIndex, onStepChange, totalStepCount]);\n\n  const openPreviousStep = useCallback(() => {\n    const newStepIndex = Math.max(currentStepIndex - 1, 0);\n    setCurrentStepIndex(newStepIndex);\n    fireNonCancelableEvent(onStepChange, { step: newStepIndex, reason: 'previous' });\n  }, [onStepChange, currentStepIndex]);\n\n  const onFinish = useCallback(() => fireNonCancelableEvent(onFinishHandler), [onFinishHandler]);\n\n  /**\n   * If the currently open hotspot disappears from the page (e.g. because of a react-router navigation),\n   * this Effect detects the nearest available hotspot and changes to it. This allows us to e.g. automatically\n   * advance to the first step on the new page (or the last step on the previous page, in case the user\n   * navigates back).\n   */\n  const isCurrentHotspotAvailable = currentId ? availableHotspots[currentId] : null;\n  useEffect(() => {\n    if (!currentId || availableHotspotsRef.current[currentId]) {\n      return;\n    }\n\n    const findNearestHotspot = () => {\n      let nearestHotspot: string | undefined = undefined;\n      let nearestDistance = Infinity;\n      for (const hotspotId of Object.keys(availableHotspotsRef.current)) {\n        const distanceFromCurrentHotspot = Math.abs(id2index[hotspotId] - currentStepIndex);\n        if (distanceFromCurrentHotspot < nearestDistance) {\n          nearestDistance = distanceFromCurrentHotspot;\n          nearestHotspot = hotspotId;\n        }\n      }\n      return nearestHotspot;\n    };\n\n    const nearestHotspot = findNearestHotspot();\n    if (nearestHotspot) {\n      const newStepIndex = id2index[nearestHotspot];\n      setCurrentStepIndex(newStepIndex);\n      setOpen(true);\n      fireNonCancelableEvent(onStepChange, { step: newStepIndex, reason: 'auto-fallback' });\n    }\n  }, [annotations, isCurrentHotspotAvailable, currentId, currentStepIndex, id2index, onStepChange]);\n\n  const onDismiss = useCallback(() => {\n    setOpen(false);\n  }, [setOpen]);\n\n  const onOpen = useCallback(\n    (stepIndex: number) => {\n      setCurrentStepIndex(stepIndex);\n      fireNonCancelableEvent(onStepChange, { step: stepIndex, reason: 'open' });\n      setOpen(true);\n    },\n    [onStepChange, setOpen]\n  );\n\n  const idOfPreviousHotspot = getStepInfo(annotations, currentStepIndex - 1).step?.hotspotId;\n  const idOfNextHotspot = getStepInfo(annotations, currentStepIndex + 1).step?.hotspotId;\n  const previousHotspotIsAvailable =\n    (idOfPreviousHotspot !== undefined && availableHotspots[idOfPreviousHotspot]) ?? false;\n  const nextHotspotIsAvailable = (idOfNextHotspot !== undefined && availableHotspots[idOfNextHotspot]) ?? false;\n\n  const getContentForId = useCallback(\n    (id: string, direction: HotspotProps['direction']) => {\n      if (currentTutorial?.completed) {\n        return null;\n      }\n\n      const globalStepIndex = id2index[id];\n      if (globalStepIndex === undefined) {\n        // This hotspot is not used in the current tutorial.\n        return null;\n      }\n\n      if (!task || !step || !open || id !== currentId) {\n        const { task: currentTask, localIndex: currentStepIndex } = getStepInfo(annotations, globalStepIndex);\n        return (\n          <ClosedAnnotation\n            globalStepIndex={globalStepIndex}\n            i18nStrings={i18nStrings}\n            onOpen={onOpen}\n            focusOnRender={id === currentId}\n            totalLocalSteps={currentTask ? currentTask.steps.length : 0}\n            taskLocalStepIndex={currentStepIndex}\n          />\n        );\n      }\n\n      return (\n        <OpenAnnotation\n          i18nStrings={i18nStrings}\n          direction={direction}\n          title={i18nStrings.taskTitle(taskIndex, task.title)}\n          content={step.content}\n          alert={step.warningAlert}\n          showPreviousButton={currentStepIndex !== 0}\n          showFinishButton={currentStepIndex + 1 === totalStepCount}\n          taskLocalStepIndex={localIndex}\n          totalLocalSteps={task.steps.length}\n          nextButtonEnabled={nextHotspotIsAvailable}\n          onNextButtonClick={openNextStep}\n          onFinish={onFinish}\n          previousButtonEnabled={previousHotspotIsAvailable}\n          onPreviousButtonClick={openPreviousStep}\n          onDismiss={onDismiss}\n        />\n      );\n    },\n    [\n      id2index,\n      currentTutorial,\n      task,\n      step,\n      open,\n      currentId,\n      currentStepIndex,\n      i18nStrings,\n      taskIndex,\n      localIndex,\n      totalStepCount,\n      nextHotspotIsAvailable,\n      openNextStep,\n      onFinish,\n      previousHotspotIsAvailable,\n      openPreviousStep,\n      onDismiss,\n      onOpen,\n      annotations,\n    ]\n  );\n\n  const registerHotspot = useCallback(\n    (id: string) => {\n      if (!id2index || id2index[id] === undefined) {\n        // This hotspot is not used in the current tutorial.\n        return;\n      }\n\n      /*\n        To ensure that all hotspots are immediately known to all triggered useEffects, we\n        need to update the availableHotspotsRef BEFORE the setAvailableHotspots calls, since\n        they will be batched and delayed until after the useEffects are run.\n      */\n      availableHotspotsRef.current = { ...availableHotspotsRef.current, [id]: true } as const;\n\n      setAvailableHotspots(availableHotspots => {\n        if (availableHotspots[id]) {\n          return availableHotspots;\n        }\n\n        return { ...availableHotspots, [id]: true } as const;\n      });\n    },\n    // We need to react on id2index changes for registering new hotspots when the map changes.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [id2index]\n  );\n\n  const unregisterHotspot = useCallback((id: string) => {\n    if (!availableHotspotsRef.current[id]) {\n      // Prevents unnecessary re-renders.\n      return;\n    }\n\n    /*\n      To ensure that all hotspots are immediately known to all triggered useEffects, we\n      need to update the availableHotspotsRef BEFORE the setAvailableHotspots calls, since\n      they will be batched and delayed until after the useEffects are run.\n    */\n    availableHotspotsRef.current = removeKey(id, availableHotspotsRef.current);\n\n    setAvailableHotspots(availableHotspots => {\n      if (!availableHotspots[id]) {\n        return availableHotspots;\n      }\n\n      return removeKey(id, availableHotspots);\n    });\n  }, []);\n\n  const context: HotspotContext = {\n    getContentForId,\n    registerHotspot,\n    unregisterHotspot,\n    onStartTutorial,\n    onExitTutorial,\n    currentStepIndex,\n    currentTutorial,\n  };\n\n  return <hotspotContext.Provider value={context}>{children}</hotspotContext.Provider>;\n}\n\napplyDisplayName(AnnotationContext, 'AnnotationContext');\n\nfunction removeKey<T extends Record<string, any>>(key: keyof T, object: T) {\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  const { [key]: _, ...remainingObject } = object;\n  return remainingObject;\n}\n"]},"metadata":{},"sourceType":"module"}