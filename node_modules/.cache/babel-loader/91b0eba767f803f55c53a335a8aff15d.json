{"ast":null,"code":"import styles from './styles.css.js';\nconst minRadius = 30;\nconst paddingLabels = 44; // = 2 * (size-lineHeight-body-100)\nconst defaultPadding = 12; // = space-s\nconst smallPadding = 8; // = space-xs\nexport const minLabelLineAngularPadding = Math.PI / 20;\nexport const dimensionsBySize = {\n  small: {\n    innerRadius: 33,\n    outerRadius: 50,\n    innerLabelPadding: smallPadding,\n    padding: smallPadding,\n    paddingLabels\n  },\n  medium: {\n    innerRadius: 66,\n    outerRadius: 100,\n    innerLabelPadding: defaultPadding,\n    padding: defaultPadding,\n    paddingLabels\n  },\n  large: {\n    innerRadius: 93,\n    outerRadius: 140,\n    innerLabelPadding: defaultPadding,\n    padding: defaultPadding,\n    paddingLabels\n  }\n};\nexport const refreshDimensionsBySize = {\n  small: Object.assign(Object.assign({}, dimensionsBySize.small), {\n    innerRadius: 38,\n    cornerRadius: 3\n  }),\n  medium: Object.assign(Object.assign({}, dimensionsBySize.medium), {\n    innerRadius: 75,\n    cornerRadius: 4\n  }),\n  large: Object.assign(Object.assign({}, dimensionsBySize.large), {\n    innerRadius: 105,\n    cornerRadius: 5\n  })\n};\n/**\n * When `size` is a string (\"small\", \"medium\" or \"large\") the predefined pie chart element dimensions for classic and visual refresh are used.\n * When `size` is a number the outer and inner radii are computed and the rest of the dimensions are taken from the closest predefined size.\n */\nexport function getDimensionsBySize(_ref) {\n  let {\n    size,\n    hasLabels,\n    visualRefresh\n  } = _ref;\n  if (typeof size === 'string') {\n    const dimensions = visualRefresh ? refreshDimensionsBySize[size] : dimensionsBySize[size];\n    return Object.assign(Object.assign({}, dimensions), {\n      size\n    });\n  }\n  const sizeSpec = visualRefresh ? refreshDimensionsBySize : dimensionsBySize;\n  const getPixelSize = d => d.outerRadius * 2 + d.padding * 2 + (hasLabels ? d.paddingLabels : 0) * 2;\n  let matchedSize = 'small';\n  if (size > getPixelSize(sizeSpec.medium)) {\n    matchedSize = 'medium';\n  }\n  if (size > getPixelSize(sizeSpec.large)) {\n    matchedSize = 'large';\n  }\n  const padding = sizeSpec[matchedSize].padding;\n  const paddingLabels = hasLabels ? sizeSpec[matchedSize].paddingLabels : 0;\n  const radiiRatio = sizeSpec[matchedSize].outerRadius / sizeSpec[matchedSize].innerRadius;\n  const outerRadius = Math.max(minRadius, (size - 2 * paddingLabels - 2 * padding) / 2);\n  const innerRadius = outerRadius / radiiRatio;\n  return Object.assign(Object.assign({}, sizeSpec[matchedSize]), {\n    outerRadius,\n    innerRadius,\n    size: matchedSize\n  });\n}\nexport const defaultDetails = (i18n, i18nStrings) => (datum, dataSum) => [{\n  key: i18n('i18nStrings.detailsValue', i18nStrings.detailsValue) || '',\n  value: datum.value\n}, {\n  key: i18n('i18nStrings.detailsPercentage', i18nStrings.detailsPercentage) || '',\n  value: `${(datum.value * 100 / dataSum).toFixed(0)}%`\n}];\n/**\n * Adjusts the position of the given label nodes to avoid visual overlapping.\n * @param nodes List of label nodes of the entire chart (both left and right side)\n * @param markers Markers array that was calculated in <Labels>, but we just need the `endY` values\n * @param leftSide Boolean flag whether we are processing the left or right side of the chart labels\n */\nexport const balanceLabelNodes = (nodes, markers, leftSide, radius) => {\n  var _a;\n  const MARGIN = 10;\n  let previousBBox = null;\n  // When traversing the right side of labels, we start at the beginning of the array and go forwards.\n  // For the left side, we need to traverse backwards from the end, so that overlapping nodes are pushed down in the right order.\n  let i = leftSide ? nodes.length - 1 : 0;\n  while (leftSide && i >= 0 || !leftSide && i < nodes.length) {\n    const node = nodes[i];\n    // Currently using dataset attributes to determine the base position.\n    // This implementation can be changed back to using `getBBox` when we drop IE11 support.\n    // Unfortunately, there is no good alternative for `getBBox` that is supported by IE11.\n    // `getBoundingClientRect` works for width and height calculations in SVG, but the x/y positions are inaccurate.\n    const x = parseFloat(node.getAttribute('data-x') || '0');\n    const y = parseFloat(node.getAttribute('data-y') || '0');\n    const box = {\n      x,\n      y,\n      height: node.getBoundingClientRect().height\n    };\n    const marker = markers[i];\n    if (leftSide) {\n      i--;\n    } else {\n      i++;\n    }\n    if (!previousBBox) {\n      previousBBox = box;\n      node.setAttribute('transform', '');\n      continue;\n    }\n    if (!leftSide && box.x < 0 || leftSide && box.x >= 0) {\n      // We have reached a label that is on the other side of the chart, so we're done.\n      break;\n    }\n    node.setAttribute('transform', '');\n    // Calculate how much the current node is overlapping with the previous one.\n    const yOffset = previousBBox.y + previousBBox.height + MARGIN - box.y;\n    if (yOffset > 0) {\n      const xOffset = computeXOffset(box, yOffset, radius) * (leftSide ? -1 : 1);\n      // Move the label down.\n      node.setAttribute('transform', `translate(${xOffset} ${yOffset})`);\n      // Adjust the attached line accordingly.\n      const lineNode = (_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.querySelector(`.${styles['label-line']}`);\n      if (lineNode) {\n        const {\n          endY,\n          endX\n        } = marker;\n        lineNode.setAttribute('y2', '' + (endY + yOffset));\n        lineNode.setAttribute('x2', '' + (endX + xOffset));\n      }\n      // Update the position accordingly to inform the next label\n      box.y += yOffset;\n      box.x += xOffset;\n    }\n    previousBBox = box;\n  }\n};\nconst squareDistance = edge => Math.pow(edge[0], 2) + Math.pow(edge[1], 2);\nconst computeXOffset = (box, yOffset, radius) => {\n  const upperEdge = [box.x, box.y + yOffset];\n  const lowerEdge = [box.x, box.y + box.height + yOffset];\n  const closestEdge = squareDistance(upperEdge) < squareDistance(lowerEdge) ? upperEdge : lowerEdge;\n  if (squareDistance(closestEdge) < Math.pow(radius, 2)) {\n    return Math.sqrt(Math.pow(radius, 2) - Math.pow(closestEdge[1], 2)) - Math.abs(closestEdge[0]);\n  }\n  return 0;\n};\nexport const computeSmartAngle = function (startAngle, endAngle) {\n  let optimize = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  if (!optimize || endAngle - startAngle < 2 * minLabelLineAngularPadding) {\n    return (endAngle + startAngle) / 2;\n  }\n  const paddedStartAngle = startAngle + minLabelLineAngularPadding;\n  const paddedEndAngle = endAngle - minLabelLineAngularPadding;\n  if (paddedStartAngle < 0 && paddedEndAngle > 0) {\n    return 0;\n  }\n  if (paddedStartAngle < Math.PI && paddedEndAngle > Math.PI) {\n    return Math.PI;\n  }\n  const endAngleMinDistance = Math.min(paddedEndAngle, Math.abs(Math.PI - paddedEndAngle), 2 * Math.PI - paddedEndAngle);\n  const startAngleMinDistance = Math.min(paddedStartAngle, Math.abs(Math.PI - paddedStartAngle), 2 * Math.PI - paddedStartAngle);\n  if (endAngleMinDistance < startAngleMinDistance) {\n    return paddedEndAngle;\n  }\n  return paddedStartAngle;\n};","map":{"version":3,"mappings":"AAIA,OAAOA,MAAM,MAAM,iBAAiB;AAWpC,MAAMC,SAAS,GAAG,EAAE;AACpB,MAAMC,aAAa,GAAG,EAAE,CAAC,CAAC;AAC1B,MAAMC,cAAc,GAAG,EAAE,CAAC,CAAC;AAC3B,MAAMC,YAAY,GAAG,CAAC,CAAC,CAAC;AACxB,OAAO,MAAMC,0BAA0B,GAAGC,IAAI,CAACC,EAAE,GAAG,EAAE;AAEtD,OAAO,MAAMC,gBAAgB,GAA0D;EACrFC,KAAK,EAAE;IACLC,WAAW,EAAE,EAAE;IACfC,WAAW,EAAE,EAAE;IACfC,iBAAiB,EAAER,YAAY;IAC/BS,OAAO,EAAET,YAAY;IACrBF;GACD;EACDY,MAAM,EAAE;IACNJ,WAAW,EAAE,EAAE;IACfC,WAAW,EAAE,GAAG;IAChBC,iBAAiB,EAAET,cAAc;IACjCU,OAAO,EAAEV,cAAc;IACvBD;GACD;EACDa,KAAK,EAAE;IACLL,WAAW,EAAE,EAAE;IACfC,WAAW,EAAE,GAAG;IAChBC,iBAAiB,EAAET,cAAc;IACjCU,OAAO,EAAEV,cAAc;IACvBD;;CAEH;AAED,OAAO,MAAMc,uBAAuB,GAA0D;EAC5FP,KAAK,kCACAD,gBAAgB,CAACC,KAAK;IACzBC,WAAW,EAAE,EAAE;IACfO,YAAY,EAAE;EAAC,EAChB;EACDH,MAAM,kCACDN,gBAAgB,CAACM,MAAM;IAC1BJ,WAAW,EAAE,EAAE;IACfO,YAAY,EAAE;EAAC,EAChB;EACDF,KAAK,kCACAP,gBAAgB,CAACO,KAAK;IACzBL,WAAW,EAAE,GAAG;IAChBO,YAAY,EAAE;EAAC;CAElB;AAED;;;;AAIA,OAAM,SAAUC,mBAAmB,OAQlC;EAAA,IARmC;IAClCC,IAAI;IACJC,SAAS;IACTC;EAAa,CAKd;EACC,IAAI,OAAOF,IAAI,KAAK,QAAQ,EAAE;IAC5B,MAAMG,UAAU,GAAGD,aAAa,GAAGL,uBAAuB,CAACG,IAAI,CAAC,GAAGX,gBAAgB,CAACW,IAAI,CAAC;IACzF,uCAAYG,UAAU;MAAEH;IAAI;;EAE9B,MAAMI,QAAQ,GAAGF,aAAa,GAAGL,uBAAuB,GAAGR,gBAAgB;EAC3E,MAAMgB,YAAY,GAAIC,CAAY,IAAKA,CAAC,CAACd,WAAW,GAAG,CAAC,GAAGc,CAAC,CAACZ,OAAO,GAAG,CAAC,GAAG,CAACO,SAAS,GAAGK,CAAC,CAACvB,aAAa,GAAG,CAAC,IAAI,CAAC;EAEhH,IAAIwB,WAAW,GAAuC,OAAO;EAC7D,IAAIP,IAAI,GAAGK,YAAY,CAACD,QAAQ,CAACT,MAAM,CAAC,EAAE;IACxCY,WAAW,GAAG,QAAQ;;EAExB,IAAIP,IAAI,GAAGK,YAAY,CAACD,QAAQ,CAACR,KAAK,CAAC,EAAE;IACvCW,WAAW,GAAG,OAAO;;EAGvB,MAAMb,OAAO,GAAGU,QAAQ,CAACG,WAAW,CAAC,CAACb,OAAO;EAC7C,MAAMX,aAAa,GAAGkB,SAAS,GAAGG,QAAQ,CAACG,WAAW,CAAC,CAACxB,aAAa,GAAG,CAAC;EACzE,MAAMyB,UAAU,GAAGJ,QAAQ,CAACG,WAAW,CAAC,CAACf,WAAW,GAAGY,QAAQ,CAACG,WAAW,CAAC,CAAChB,WAAW;EACxF,MAAMC,WAAW,GAAGL,IAAI,CAACsB,GAAG,CAAC3B,SAAS,EAAE,CAACkB,IAAI,GAAG,CAAC,GAAGjB,aAAa,GAAG,CAAC,GAAGW,OAAO,IAAI,CAAC,CAAC;EACrF,MAAMH,WAAW,GAAGC,WAAW,GAAGgB,UAAU;EAE5C,uCAAYJ,QAAQ,CAACG,WAAW,CAAC;IAAEf,WAAW;IAAED,WAAW;IAAES,IAAI,EAAEO;EAAW;AAChF;AAEA,OAAO,MAAMG,cAAc,GACzB,CAACC,IAA0C,EAAEC,WAAsC,KACnF,CAACC,KAA0B,EAAEC,OAAe,KAC1C,CACE;EAAEC,GAAG,EAAEJ,IAAI,CAAC,0BAA0B,EAAEC,WAAW,CAACI,YAAY,CAAC,IAAI,EAAE;EAAEC,KAAK,EAAEJ,KAAK,CAACI;AAAK,CAAE,EAC7F;EACEF,GAAG,EAAEJ,IAAI,CAAC,+BAA+B,EAAEC,WAAW,CAACM,iBAAiB,CAAC,IAAI,EAAE;EAC/ED,KAAK,EAAE,GAAG,CAAEJ,KAAK,CAACI,KAAK,GAAG,GAAG,GAAIH,OAAO,EAAEK,OAAO,CAAC,CAAC,CAAC;CACrD,CACF;AAEL;;;;;;AAMA,OAAO,MAAMC,iBAAiB,GAAG,CAC/BC,KAA8B,EAC9BC,OAA8C,EAC9CC,QAAiB,EACjBC,MAAc,KACZ;;EACF,MAAMC,MAAM,GAAG,EAAE;EAEjB,IAAIC,YAAY,GAAoD,IAAI;EAExE;EACA;EACA,IAAIC,CAAC,GAAGJ,QAAQ,GAAGF,KAAK,CAACO,MAAM,GAAG,CAAC,GAAG,CAAC;EAEvC,OAAQL,QAAQ,IAAII,CAAC,IAAI,CAAC,IAAM,CAACJ,QAAQ,IAAII,CAAC,GAAGN,KAAK,CAACO,MAAO,EAAE;IAC9D,MAAMC,IAAI,GAAGR,KAAK,CAACM,CAAC,CAAC;IAErB;IACA;IACA;IACA;IACA,MAAMG,CAAC,GAAGC,UAAU,CAACF,IAAI,CAACG,YAAY,CAAC,QAAQ,CAAC,IAAI,GAAG,CAAC;IACxD,MAAMC,CAAC,GAAGF,UAAU,CAACF,IAAI,CAACG,YAAY,CAAC,QAAQ,CAAC,IAAI,GAAG,CAAC;IACxD,MAAME,GAAG,GAAG;MACVJ,CAAC;MACDG,CAAC;MACDE,MAAM,EAAEN,IAAI,CAACO,qBAAqB,EAAE,CAACD;KACtC;IAED,MAAME,MAAM,GAAGf,OAAO,CAACK,CAAC,CAAC;IAEzB,IAAIJ,QAAQ,EAAE;MACZI,CAAC,EAAE;KACJ,MAAM;MACLA,CAAC,EAAE;;IAGL,IAAI,CAACD,YAAY,EAAE;MACjBA,YAAY,GAAGQ,GAAG;MAClBL,IAAI,CAACS,YAAY,CAAC,WAAW,EAAE,EAAE,CAAC;MAClC;;IAGF,IAAK,CAACf,QAAQ,IAAIW,GAAG,CAACJ,CAAC,GAAG,CAAC,IAAMP,QAAQ,IAAIW,GAAG,CAACJ,CAAC,IAAI,CAAE,EAAE;MACxD;MACA;;IAGFD,IAAI,CAACS,YAAY,CAAC,WAAW,EAAE,EAAE,CAAC;IAElC;IACA,MAAMC,OAAO,GAAGb,YAAY,CAACO,CAAC,GAAGP,YAAY,CAACS,MAAM,GAAGV,MAAM,GAAGS,GAAG,CAACD,CAAC;IAErE,IAAIM,OAAO,GAAG,CAAC,EAAE;MACf,MAAMC,OAAO,GAAGC,cAAc,CAACP,GAAG,EAAEK,OAAO,EAAEf,MAAM,CAAC,IAAID,QAAQ,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC;MAC1E;MACAM,IAAI,CAACS,YAAY,CAAC,WAAW,EAAE,aAAaE,OAAO,IAAID,OAAO,GAAG,CAAC;MAElE;MACA,MAAMG,QAAQ,GAAG,UAAI,CAACC,UAAU,0CAAEC,aAAa,CAAC,IAAI/D,MAAM,CAAC,YAAY,CAAC,EAAE,CAAC;MAC3E,IAAI6D,QAAQ,EAAE;QACZ,MAAM;UAAEG,IAAI;UAAEC;QAAI,CAAE,GAAGT,MAAM;QAC7BK,QAAQ,CAACJ,YAAY,CAAC,IAAI,EAAE,EAAE,IAAIO,IAAI,GAAGN,OAAO,CAAC,CAAC;QAClDG,QAAQ,CAACJ,YAAY,CAAC,IAAI,EAAE,EAAE,IAAIQ,IAAI,GAAGN,OAAO,CAAC,CAAC;;MAGpD;MACAN,GAAG,CAACD,CAAC,IAAIM,OAAO;MAChBL,GAAG,CAACJ,CAAC,IAAIU,OAAO;;IAGlBd,YAAY,GAAGQ,GAAG;;AAEtB,CAAC;AAED,MAAMa,cAAc,GAAIC,IAAsB,IAAa7D,IAAI,CAAC8D,GAAG,CAACD,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,GAAG7D,IAAI,CAAC8D,GAAG,CAACD,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC;AAEtG,MAAMP,cAAc,GAAG,CAACP,GAA6C,EAAEK,OAAe,EAAEf,MAAc,KAAY;EAChH,MAAM0B,SAAS,GAAqB,CAAChB,GAAG,CAACJ,CAAC,EAAEI,GAAG,CAACD,CAAC,GAAGM,OAAO,CAAC;EAC5D,MAAMY,SAAS,GAAqB,CAACjB,GAAG,CAACJ,CAAC,EAAEI,GAAG,CAACD,CAAC,GAAGC,GAAG,CAACC,MAAM,GAAGI,OAAO,CAAC;EACzE,MAAMa,WAAW,GAAGL,cAAc,CAACG,SAAS,CAAC,GAAGH,cAAc,CAACI,SAAS,CAAC,GAAGD,SAAS,GAAGC,SAAS;EAEjG,IAAIJ,cAAc,CAACK,WAAW,CAAC,GAAGjE,IAAI,CAAC8D,GAAG,CAACzB,MAAM,EAAE,CAAC,CAAC,EAAE;IACrD,OAAOrC,IAAI,CAACkE,IAAI,CAAClE,IAAI,CAAC8D,GAAG,CAACzB,MAAM,EAAE,CAAC,CAAC,GAAGrC,IAAI,CAAC8D,GAAG,CAACG,WAAW,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,GAAGjE,IAAI,CAACmE,GAAG,CAACF,WAAW,CAAC,CAAC,CAAC,CAAC;;EAEhG,OAAO,CAAC;AACV,CAAC;AAED,OAAO,MAAMG,iBAAiB,GAAG,UAACC,UAAkB,EAAEC,QAAgB,EAA8B;EAAA,IAA5BC,QAAQ,uEAAG,KAAK;EACtF,IAAI,CAACA,QAAQ,IAAID,QAAQ,GAAGD,UAAU,GAAG,CAAC,GAAGtE,0BAA0B,EAAE;IACvE,OAAO,CAACuE,QAAQ,GAAGD,UAAU,IAAI,CAAC;;EAEpC,MAAMG,gBAAgB,GAAGH,UAAU,GAAGtE,0BAA0B;EAChE,MAAM0E,cAAc,GAAGH,QAAQ,GAAGvE,0BAA0B;EAC5D,IAAIyE,gBAAgB,GAAG,CAAC,IAAIC,cAAc,GAAG,CAAC,EAAE;IAC9C,OAAO,CAAC;;EAEV,IAAID,gBAAgB,GAAGxE,IAAI,CAACC,EAAE,IAAIwE,cAAc,GAAGzE,IAAI,CAACC,EAAE,EAAE;IAC1D,OAAOD,IAAI,CAACC,EAAE;;EAGhB,MAAMyE,mBAAmB,GAAG1E,IAAI,CAAC2E,GAAG,CAClCF,cAAc,EACdzE,IAAI,CAACmE,GAAG,CAACnE,IAAI,CAACC,EAAE,GAAGwE,cAAc,CAAC,EAClC,CAAC,GAAGzE,IAAI,CAACC,EAAE,GAAGwE,cAAc,CAC7B;EACD,MAAMG,qBAAqB,GAAG5E,IAAI,CAAC2E,GAAG,CACpCH,gBAAgB,EAChBxE,IAAI,CAACmE,GAAG,CAACnE,IAAI,CAACC,EAAE,GAAGuE,gBAAgB,CAAC,EACpC,CAAC,GAAGxE,IAAI,CAACC,EAAE,GAAGuE,gBAAgB,CAC/B;EACD,IAAIE,mBAAmB,GAAGE,qBAAqB,EAAE;IAC/C,OAAOH,cAAc;;EAEvB,OAAOD,gBAAgB;AACzB,CAAC","names":["styles","minRadius","paddingLabels","defaultPadding","smallPadding","minLabelLineAngularPadding","Math","PI","dimensionsBySize","small","innerRadius","outerRadius","innerLabelPadding","padding","medium","large","refreshDimensionsBySize","cornerRadius","getDimensionsBySize","size","hasLabels","visualRefresh","dimensions","sizeSpec","getPixelSize","d","matchedSize","radiiRatio","max","defaultDetails","i18n","i18nStrings","datum","dataSum","key","detailsValue","value","detailsPercentage","toFixed","balanceLabelNodes","nodes","markers","leftSide","radius","MARGIN","previousBBox","i","length","node","x","parseFloat","getAttribute","y","box","height","getBoundingClientRect","marker","setAttribute","yOffset","xOffset","computeXOffset","lineNode","parentNode","querySelector","endY","endX","squareDistance","edge","pow","upperEdge","lowerEdge","closestEdge","sqrt","abs","computeSmartAngle","startAngle","endAngle","optimize","paddedStartAngle","paddedEndAngle","endAngleMinDistance","min","startAngleMinDistance"],"sources":["/Users/tangyizhi/Desktop/Assignment 2/frontend/node_modules/@cloudscape-design/components/pie-chart/lib/default/pie-chart/utils.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { ComponentFormatFunction } from '../i18n/context';\nimport { PieChartProps } from './interfaces';\nimport styles from './styles.css.js';\n\nexport interface Dimension {\n  innerRadius: number;\n  outerRadius: number;\n  padding: number;\n  paddingLabels: number;\n  innerLabelPadding: number;\n  cornerRadius?: number;\n}\n\nconst minRadius = 30;\nconst paddingLabels = 44; // = 2 * (size-lineHeight-body-100)\nconst defaultPadding = 12; // = space-s\nconst smallPadding = 8; // = space-xs\nexport const minLabelLineAngularPadding = Math.PI / 20;\n\nexport const dimensionsBySize: Record<NonNullable<PieChartProps['size']>, Dimension> = {\n  small: {\n    innerRadius: 33,\n    outerRadius: 50,\n    innerLabelPadding: smallPadding,\n    padding: smallPadding,\n    paddingLabels,\n  },\n  medium: {\n    innerRadius: 66,\n    outerRadius: 100,\n    innerLabelPadding: defaultPadding,\n    padding: defaultPadding,\n    paddingLabels,\n  },\n  large: {\n    innerRadius: 93,\n    outerRadius: 140,\n    innerLabelPadding: defaultPadding,\n    padding: defaultPadding,\n    paddingLabels,\n  },\n};\n\nexport const refreshDimensionsBySize: Record<NonNullable<PieChartProps['size']>, Dimension> = {\n  small: {\n    ...dimensionsBySize.small,\n    innerRadius: 38,\n    cornerRadius: 3,\n  },\n  medium: {\n    ...dimensionsBySize.medium,\n    innerRadius: 75,\n    cornerRadius: 4,\n  },\n  large: {\n    ...dimensionsBySize.large,\n    innerRadius: 105,\n    cornerRadius: 5,\n  },\n};\n\n/**\n * When `size` is a string (\"small\", \"medium\" or \"large\") the predefined pie chart element dimensions for classic and visual refresh are used.\n * When `size` is a number the outer and inner radii are computed and the rest of the dimensions are taken from the closest predefined size.\n */\nexport function getDimensionsBySize({\n  size,\n  hasLabels,\n  visualRefresh,\n}: {\n  size: NonNullable<PieChartProps['size']> | number;\n  hasLabels: boolean;\n  visualRefresh?: boolean;\n}): Dimension & { size: NonNullable<PieChartProps['size']> } {\n  if (typeof size === 'string') {\n    const dimensions = visualRefresh ? refreshDimensionsBySize[size] : dimensionsBySize[size];\n    return { ...dimensions, size };\n  }\n  const sizeSpec = visualRefresh ? refreshDimensionsBySize : dimensionsBySize;\n  const getPixelSize = (d: Dimension) => d.outerRadius * 2 + d.padding * 2 + (hasLabels ? d.paddingLabels : 0) * 2;\n\n  let matchedSize: NonNullable<PieChartProps['size']> = 'small';\n  if (size > getPixelSize(sizeSpec.medium)) {\n    matchedSize = 'medium';\n  }\n  if (size > getPixelSize(sizeSpec.large)) {\n    matchedSize = 'large';\n  }\n\n  const padding = sizeSpec[matchedSize].padding;\n  const paddingLabels = hasLabels ? sizeSpec[matchedSize].paddingLabels : 0;\n  const radiiRatio = sizeSpec[matchedSize].outerRadius / sizeSpec[matchedSize].innerRadius;\n  const outerRadius = Math.max(minRadius, (size - 2 * paddingLabels - 2 * padding) / 2);\n  const innerRadius = outerRadius / radiiRatio;\n\n  return { ...sizeSpec[matchedSize], outerRadius, innerRadius, size: matchedSize };\n}\n\nexport const defaultDetails =\n  (i18n: ComponentFormatFunction<'pie-chart'>, i18nStrings: PieChartProps.I18nStrings) =>\n  (datum: PieChartProps.Datum, dataSum: number) =>\n    [\n      { key: i18n('i18nStrings.detailsValue', i18nStrings.detailsValue) || '', value: datum.value },\n      {\n        key: i18n('i18nStrings.detailsPercentage', i18nStrings.detailsPercentage) || '',\n        value: `${((datum.value * 100) / dataSum).toFixed(0)}%`,\n      },\n    ];\n\n/**\n * Adjusts the position of the given label nodes to avoid visual overlapping.\n * @param nodes List of label nodes of the entire chart (both left and right side)\n * @param markers Markers array that was calculated in <Labels>, but we just need the `endY` values\n * @param leftSide Boolean flag whether we are processing the left or right side of the chart labels\n */\nexport const balanceLabelNodes = (\n  nodes: NodeListOf<SVGGElement>,\n  markers: Array<{ endY: number; endX: number }>,\n  leftSide: boolean,\n  radius: number\n) => {\n  const MARGIN = 10;\n\n  let previousBBox: { x: number; y: number; height: number } | null = null;\n\n  // When traversing the right side of labels, we start at the beginning of the array and go forwards.\n  // For the left side, we need to traverse backwards from the end, so that overlapping nodes are pushed down in the right order.\n  let i = leftSide ? nodes.length - 1 : 0;\n\n  while ((leftSide && i >= 0) || (!leftSide && i < nodes.length)) {\n    const node = nodes[i];\n\n    // Currently using dataset attributes to determine the base position.\n    // This implementation can be changed back to using `getBBox` when we drop IE11 support.\n    // Unfortunately, there is no good alternative for `getBBox` that is supported by IE11.\n    // `getBoundingClientRect` works for width and height calculations in SVG, but the x/y positions are inaccurate.\n    const x = parseFloat(node.getAttribute('data-x') || '0');\n    const y = parseFloat(node.getAttribute('data-y') || '0');\n    const box = {\n      x,\n      y,\n      height: node.getBoundingClientRect().height,\n    };\n\n    const marker = markers[i];\n\n    if (leftSide) {\n      i--;\n    } else {\n      i++;\n    }\n\n    if (!previousBBox) {\n      previousBBox = box;\n      node.setAttribute('transform', '');\n      continue;\n    }\n\n    if ((!leftSide && box.x < 0) || (leftSide && box.x >= 0)) {\n      // We have reached a label that is on the other side of the chart, so we're done.\n      break;\n    }\n\n    node.setAttribute('transform', '');\n\n    // Calculate how much the current node is overlapping with the previous one.\n    const yOffset = previousBBox.y + previousBBox.height + MARGIN - box.y;\n\n    if (yOffset > 0) {\n      const xOffset = computeXOffset(box, yOffset, radius) * (leftSide ? -1 : 1);\n      // Move the label down.\n      node.setAttribute('transform', `translate(${xOffset} ${yOffset})`);\n\n      // Adjust the attached line accordingly.\n      const lineNode = node.parentNode?.querySelector(`.${styles['label-line']}`);\n      if (lineNode) {\n        const { endY, endX } = marker;\n        lineNode.setAttribute('y2', '' + (endY + yOffset));\n        lineNode.setAttribute('x2', '' + (endX + xOffset));\n      }\n\n      // Update the position accordingly to inform the next label\n      box.y += yOffset;\n      box.x += xOffset;\n    }\n\n    previousBBox = box;\n  }\n};\n\nconst squareDistance = (edge: [number, number]): number => Math.pow(edge[0], 2) + Math.pow(edge[1], 2);\n\nconst computeXOffset = (box: { x: number; y: number; height: number }, yOffset: number, radius: number): number => {\n  const upperEdge: [number, number] = [box.x, box.y + yOffset];\n  const lowerEdge: [number, number] = [box.x, box.y + box.height + yOffset];\n  const closestEdge = squareDistance(upperEdge) < squareDistance(lowerEdge) ? upperEdge : lowerEdge;\n\n  if (squareDistance(closestEdge) < Math.pow(radius, 2)) {\n    return Math.sqrt(Math.pow(radius, 2) - Math.pow(closestEdge[1], 2)) - Math.abs(closestEdge[0]);\n  }\n  return 0;\n};\n\nexport const computeSmartAngle = (startAngle: number, endAngle: number, optimize = false): number => {\n  if (!optimize || endAngle - startAngle < 2 * minLabelLineAngularPadding) {\n    return (endAngle + startAngle) / 2;\n  }\n  const paddedStartAngle = startAngle + minLabelLineAngularPadding;\n  const paddedEndAngle = endAngle - minLabelLineAngularPadding;\n  if (paddedStartAngle < 0 && paddedEndAngle > 0) {\n    return 0;\n  }\n  if (paddedStartAngle < Math.PI && paddedEndAngle > Math.PI) {\n    return Math.PI;\n  }\n\n  const endAngleMinDistance = Math.min(\n    paddedEndAngle,\n    Math.abs(Math.PI - paddedEndAngle),\n    2 * Math.PI - paddedEndAngle\n  );\n  const startAngleMinDistance = Math.min(\n    paddedStartAngle,\n    Math.abs(Math.PI - paddedStartAngle),\n    2 * Math.PI - paddedStartAngle\n  );\n  if (endAngleMinDistance < startAngleMinDistance) {\n    return paddedEndAngle;\n  }\n  return paddedStartAngle;\n};\n"]},"metadata":{},"sourceType":"module"}