{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/tangyizhi/Desktop/Assignment2/frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _slicedToArray from \"/Users/tangyizhi/Desktop/Assignment2/frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\n// A sufficiently small value.\n// The Number.EPSILON is not available in the target ECMA version.\n// See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON\nvar EPSILON = 0.0000000000001;\n// When x-domain is not set explicitly - guess it based on the available data.\nexport function computeDomainX(series) {\n  var xValues = getXValues(series);\n  if (xValues.length === 0) {\n    return [];\n  }\n  // Assuming categorical domain.\n  // In that case, all values are to be included.\n  if (typeof xValues[0] === 'string') {\n    return uniq(xValues);\n  }\n  // For non-categorical domain find min and max bounds.\n  return xValues.reduce(function (_ref, x) {\n    var _ref2 = _slicedToArray(_ref, 2),\n      min = _ref2[0],\n      max = _ref2[1];\n    return [x < min ? x : min, max < x ? x : max];\n  }, [xValues[0], xValues[0]]);\n}\n// When y-domain is not set explicitly - guess it based on the available data and series.\nexport function computeDomainY(series, scaleType) {\n  var min = Number.POSITIVE_INFINITY;\n  var max = Number.NEGATIVE_INFINITY;\n  // Find the min and max for threshold series.\n  series.forEach(function (s) {\n    if (s.type === 'threshold') {\n      min = Math.min(min, s.y);\n      max = Math.max(max, s.y);\n    }\n  });\n  // Find the min and max for area series considering their stacking.\n  getXValues(series).forEach(function (_, xIndex) {\n    var _a;\n    // Maintains the prev stack level.\n    var stackY = scaleType === 'linear' ? 0 : EPSILON;\n    var _iterator = _createForOfIteratorHelper(series),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var s = _step.value;\n        if (s.type === 'area') {\n          stackY = stackY + (((_a = s.data[xIndex]) === null || _a === void 0 ? void 0 : _a.y) || 0);\n          min = Math.min(min, stackY);\n          max = Math.max(max, stackY);\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  });\n  // If min/max is not overridden than either series or series data is empty.\n  if (min === Number.POSITIVE_INFINITY) {\n    return [];\n  }\n  // Log scales can't start from 0, so, if possible, start from 1.\n  if (scaleType === 'log' && min === 0 && max > 1) {\n    return [1, max];\n  }\n  return [min, max];\n}\n// For given data, series and scales, compute all points and group them as\n// x:y, x:series and series:x to allow constant time access to the required point or subset.\nexport function computePlotPoints(series, xScale, yScale) {\n  var xValues = getXValues(series);\n  // Lookup for xy[xIndex][yIndex]\n  var xy = [];\n  // Lookup for xs[xIndex][seriesIndex]\n  var xs = [];\n  // Lookup for sx[seriesIndex][xIndex]\n  var sx = [];\n  // Filter out the data which is beyond the plot for whatever reason.\n  getVisibleData(xValues, xScale).forEach(function (_ref3, xIndex) {\n    var x = _ref3.x,\n      scaledX = _ref3.scaledX;\n    // Maintains the prev stack level. Starting from epsilon to not break log scales.\n    var stackY = yScale.scaleType === 'linear' ? 0 : EPSILON;\n    // A column of series points related to the same x.\n    var points = [];\n    // Collect the points, leaving y-index as 0 for now.\n    series.forEach(function (s, sIndex) {\n      var _a;\n      if (s.type === 'threshold') {\n        var scaledY = yScale.d3Scale(s.y) || 0;\n        points.push({\n          x: x,\n          y0: s.y,\n          y1: s.y,\n          scaled: {\n            x: scaledX,\n            y0: scaledY,\n            y1: scaledY\n          },\n          index: {\n            x: xIndex,\n            s: sIndex,\n            y: 0\n          },\n          value: 0\n        });\n      } else {\n        var value = ((_a = s.data[xIndex]) === null || _a === void 0 ? void 0 : _a.y) || 0;\n        var y0 = stackY;\n        var y1 = stackY + value;\n        points.push({\n          x: x,\n          y0: y0,\n          y1: y1,\n          scaled: {\n            x: scaledX,\n            y0: yScale.d3Scale(y0) || 0,\n            y1: yScale.d3Scale(y1) || 0\n          },\n          index: {\n            x: xIndex,\n            s: sIndex,\n            y: 0\n          },\n          value: value\n        });\n        stackY = y1;\n      }\n    });\n    // Sort points by y and insert the missing y-index.\n    points.sort(function (p1, p2) {\n      return p1.y1 - p2.y1;\n    }).forEach(function (point, index) {\n      point.index.y = index;\n      // Insert the points to the respective two-dimensional lookup arrays.\n      insertIntoMatrix(xy, point.index.x, point.index.y, point);\n      insertIntoMatrix(xs, point.index.x, point.index.s, point);\n      insertIntoMatrix(sx, point.index.s, point.index.x, point);\n    });\n  });\n  return {\n    xy: xy,\n    xs: xs,\n    sx: sx\n  };\n}\n// Finds the closest point in the sorted array.\nexport function findClosest(sortedArray, target, getter) {\n  // The method guarantees to return a point hence empty arrays are not allowed.\n  if (sortedArray.length === 0) {\n    throw new Error('Invariant violation: array is empty.');\n  }\n  var isAscending = getter(sortedArray[0]) < getter(sortedArray[sortedArray.length - 1]);\n  var compare = function compare(x) {\n    return isAscending ? getter(x) < target : getter(x) > target;\n  };\n  var delta = function delta(x) {\n    return Math.abs(getter(x) - target);\n  };\n  // Use binary search to find the closest value in a sorted array.\n  var lo = 0;\n  var hi = sortedArray.length - 1;\n  while (hi - lo > 1) {\n    var mid = Math.floor((lo + hi) / 2);\n    if (compare(sortedArray[mid])) {\n      lo = mid;\n    } else {\n      hi = mid;\n    }\n  }\n  return delta(sortedArray[lo]) < delta(sortedArray[hi]) ? sortedArray[lo] : sortedArray[hi];\n}\n// Returns given index if it is in range or the opposite range boundary otherwise.\nexport function circleIndex(index, _ref4) {\n  var _ref5 = _slicedToArray(_ref4, 2),\n    from = _ref5[0],\n    to = _ref5[1];\n  if (index < from) {\n    return to;\n  }\n  if (index > to) {\n    return from;\n  }\n  return index;\n}\n// Compares all x-values between series to ensure they are consistent.\nexport function isSeriesValid(series) {\n  var _a;\n  var sampleXValues = getXValues(series);\n  var _iterator2 = _createForOfIteratorHelper(series),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var s = _step2.value;\n      if (s.type === 'area') {\n        for (var i = 0; i < Math.max(s.data.length, sampleXValues.length); i++) {\n          if (((_a = s.data[i]) === null || _a === void 0 ? void 0 : _a.x) !== sampleXValues[i]) {\n            return false;\n          }\n        }\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  return true;\n}\n// Takes first area series x-values as all data x-values are to match across series.\nfunction getXValues(series) {\n  var _iterator3 = _createForOfIteratorHelper(series),\n    _step3;\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var s = _step3.value;\n      if (s.type === 'area') {\n        return s.data.map(function (_ref6) {\n          var x = _ref6.x;\n          return x;\n        });\n      }\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n  return [];\n}\n// Returns data that is visible in the given scale.\nfunction getVisibleData(data, xScale) {\n  var scaledOffsetX = xScale.isCategorical() ? Math.max(0, xScale.d3Scale.bandwidth() - 1) / 2 : 0;\n  var visibleData = [];\n  var _iterator4 = _createForOfIteratorHelper(data),\n    _step4;\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var x = _step4.value;\n      var scaledX = xScale.d3Scale(x);\n      if (scaledX !== undefined) {\n        visibleData.push({\n          x: x,\n          scaledX: scaledX + scaledOffsetX\n        });\n      }\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n  return visibleData;\n}\n// Inserts given value into a two-dimensional array.\nfunction insertIntoMatrix(matrix, row, col, value) {\n  if (!matrix[row]) {\n    matrix[row] = [];\n  }\n  matrix[row][col] = value;\n}\n// Creates new array with only unique elements of the given array.\nfunction uniq(arr) {\n  var set = new Set();\n  var uniqArray = [];\n  var _iterator5 = _createForOfIteratorHelper(arr),\n    _step5;\n  try {\n    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n      var value = _step5.value;\n      if (!set.has(value)) {\n        set.add(value);\n        uniqArray.push(value);\n      }\n    }\n  } catch (err) {\n    _iterator5.e(err);\n  } finally {\n    _iterator5.f();\n  }\n  return uniqArray;\n}","map":{"version":3,"mappings":"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","names":["EPSILON","computeDomainX","series","xValues","getXValues","length","uniq","reduce","x","min","max","computeDomainY","scaleType","Number","POSITIVE_INFINITY","NEGATIVE_INFINITY","forEach","s","type","Math","y","_","xIndex","stackY","data","computePlotPoints","xScale","yScale","xy","xs","sx","getVisibleData","scaledX","points","sIndex","scaledY","d3Scale","push","y0","y1","scaled","index","value","sort","p1","p2","point","insertIntoMatrix","findClosest","sortedArray","target","getter","Error","isAscending","compare","delta","abs","lo","hi","mid","floor","circleIndex","from","to","isSeriesValid","sampleXValues","i","map","scaledOffsetX","isCategorical","bandwidth","visibleData","undefined","matrix","row","col","arr","set","Set","uniqArray","has","add"],"sources":["/Users/tangyizhi/Desktop/Assignment2/frontend/node_modules/@cloudscape-design/components/area-chart/model/lib/default/area-chart/model/utils.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { AreaChartProps } from '../interfaces';\nimport { ChartScale, NumericChartScale } from '../../internal/components/cartesian-chart/scales';\nimport { ChartDataTypes, XDomain, YDomain, YScaleType } from '../../internal/components/cartesian-chart/interfaces';\nimport { ChartModel } from './index';\n\n// A sufficiently small value.\n// The Number.EPSILON is not available in the target ECMA version.\n// See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON\nconst EPSILON = 0.0000000000001;\n\n// When x-domain is not set explicitly - guess it based on the available data.\nexport function computeDomainX<T extends ChartDataTypes>(series: readonly AreaChartProps.Series<T>[]): XDomain<T> {\n  const xValues = getXValues(series);\n\n  if (xValues.length === 0) {\n    return [] as unknown as XDomain<T>;\n  }\n\n  // Assuming categorical domain.\n  // In that case, all values are to be included.\n  if (typeof xValues[0] === 'string') {\n    return uniq(xValues) as unknown as XDomain<T>;\n  }\n\n  // For non-categorical domain find min and max bounds.\n  return xValues.reduce(\n    ([min, max], x) => [x < min ? x : min, max < x ? x : max],\n    [xValues[0], xValues[0]]\n  ) as unknown as XDomain<T>;\n}\n\n// When y-domain is not set explicitly - guess it based on the available data and series.\nexport function computeDomainY<T>(series: readonly AreaChartProps.Series<T>[], scaleType: YScaleType): YDomain {\n  let min = Number.POSITIVE_INFINITY;\n  let max = Number.NEGATIVE_INFINITY;\n\n  // Find the min and max for threshold series.\n  series.forEach(s => {\n    if (s.type === 'threshold') {\n      min = Math.min(min, s.y);\n      max = Math.max(max, s.y);\n    }\n  });\n\n  // Find the min and max for area series considering their stacking.\n  getXValues(series).forEach((_, xIndex) => {\n    // Maintains the prev stack level.\n    let stackY = scaleType === 'linear' ? 0 : EPSILON;\n\n    for (const s of series) {\n      if (s.type === 'area') {\n        stackY = stackY + (s.data[xIndex]?.y || 0);\n        min = Math.min(min, stackY);\n        max = Math.max(max, stackY);\n      }\n    }\n  });\n\n  // If min/max is not overridden than either series or series data is empty.\n  if (min === Number.POSITIVE_INFINITY) {\n    return [];\n  }\n\n  // Log scales can't start from 0, so, if possible, start from 1.\n  if (scaleType === 'log' && min === 0 && max > 1) {\n    return [1, max];\n  }\n\n  return [min, max];\n}\n\n// For given data, series and scales, compute all points and group them as\n// x:y, x:series and series:x to allow constant time access to the required point or subset.\nexport function computePlotPoints<T>(\n  series: readonly AreaChartProps.Series<T>[],\n  xScale: ChartScale,\n  yScale: NumericChartScale\n): {\n  xy: ChartModel.PlotPoint<T>[][];\n  xs: ChartModel.PlotPoint<T>[][];\n  sx: ChartModel.PlotPoint<T>[][];\n} {\n  const xValues = getXValues(series);\n\n  // Lookup for xy[xIndex][yIndex]\n  const xy: ChartModel.PlotPoint<T>[][] = [];\n  // Lookup for xs[xIndex][seriesIndex]\n  const xs: ChartModel.PlotPoint<T>[][] = [];\n  // Lookup for sx[seriesIndex][xIndex]\n  const sx: ChartModel.PlotPoint<T>[][] = [];\n\n  // Filter out the data which is beyond the plot for whatever reason.\n  getVisibleData(xValues, xScale).forEach(({ x, scaledX }, xIndex) => {\n    // Maintains the prev stack level. Starting from epsilon to not break log scales.\n    let stackY = yScale.scaleType === 'linear' ? 0 : EPSILON;\n\n    // A column of series points related to the same x.\n    const points: ChartModel.PlotPoint<T>[] = [];\n\n    // Collect the points, leaving y-index as 0 for now.\n    series.forEach((s, sIndex) => {\n      if (s.type === 'threshold') {\n        const scaledY = yScale.d3Scale(s.y) || 0;\n        points.push({\n          x: x,\n          y0: s.y,\n          y1: s.y,\n          scaled: { x: scaledX, y0: scaledY, y1: scaledY },\n          index: { x: xIndex, s: sIndex, y: 0 },\n          value: 0,\n        });\n      } else {\n        const value = s.data[xIndex]?.y || 0;\n        const y0 = stackY;\n        const y1 = stackY + value;\n        points.push({\n          x: x,\n          y0: y0,\n          y1: y1,\n          scaled: { x: scaledX, y0: yScale.d3Scale(y0) || 0, y1: yScale.d3Scale(y1) || 0 },\n          index: { x: xIndex, s: sIndex, y: 0 },\n          value: value,\n        });\n\n        stackY = y1;\n      }\n    });\n\n    // Sort points by y and insert the missing y-index.\n    points\n      .sort((p1, p2) => p1.y1 - p2.y1)\n      .forEach((point, index) => {\n        point.index.y = index;\n\n        // Insert the points to the respective two-dimensional lookup arrays.\n        insertIntoMatrix(xy, point.index.x, point.index.y, point);\n        insertIntoMatrix(xs, point.index.x, point.index.s, point);\n        insertIntoMatrix(sx, point.index.s, point.index.x, point);\n      });\n  });\n\n  return { xy, xs, sx };\n}\n\n// Finds the closest point in the sorted array.\nexport function findClosest<T>(sortedArray: readonly T[], target: number, getter: (item: T) => number): T {\n  // The method guarantees to return a point hence empty arrays are not allowed.\n  if (sortedArray.length === 0) {\n    throw new Error('Invariant violation: array is empty.');\n  }\n\n  const isAscending = getter(sortedArray[0]) < getter(sortedArray[sortedArray.length - 1]);\n  const compare = (x: T) => (isAscending ? getter(x) < target : getter(x) > target);\n  const delta = (x: T) => Math.abs(getter(x) - target);\n\n  // Use binary search to find the closest value in a sorted array.\n  let lo = 0;\n  let hi = sortedArray.length - 1;\n  while (hi - lo > 1) {\n    const mid = Math.floor((lo + hi) / 2);\n    if (compare(sortedArray[mid])) {\n      lo = mid;\n    } else {\n      hi = mid;\n    }\n  }\n  return delta(sortedArray[lo]) < delta(sortedArray[hi]) ? sortedArray[lo] : sortedArray[hi];\n}\n\n// Returns given index if it is in range or the opposite range boundary otherwise.\nexport function circleIndex(index: number, [from, to]: [number, number]): number {\n  if (index < from) {\n    return to;\n  }\n  if (index > to) {\n    return from;\n  }\n  return index;\n}\n\n// Compares all x-values between series to ensure they are consistent.\nexport function isSeriesValid<T>(series: readonly AreaChartProps.Series<T>[]) {\n  const sampleXValues = getXValues(series);\n\n  for (const s of series) {\n    if (s.type === 'area') {\n      for (let i = 0; i < Math.max(s.data.length, sampleXValues.length); i++) {\n        if (s.data[i]?.x !== sampleXValues[i]) {\n          return false;\n        }\n      }\n    }\n  }\n\n  return true;\n}\n\n// Takes first area series x-values as all data x-values are to match across series.\nfunction getXValues<T>(series: readonly AreaChartProps.Series<T>[]) {\n  for (const s of series) {\n    if (s.type === 'area') {\n      return s.data.map(({ x }) => x);\n    }\n  }\n\n  return [];\n}\n\n// Returns data that is visible in the given scale.\nfunction getVisibleData<T>(data: readonly T[], xScale: ChartScale) {\n  const scaledOffsetX = xScale.isCategorical() ? Math.max(0, xScale.d3Scale.bandwidth() - 1) / 2 : 0;\n\n  const visibleData = [];\n  for (const x of data) {\n    const scaledX = xScale.d3Scale(x as any);\n\n    if (scaledX !== undefined) {\n      visibleData.push({ x, scaledX: scaledX + scaledOffsetX });\n    }\n  }\n  return visibleData;\n}\n\n// Inserts given value into a two-dimensional array.\nfunction insertIntoMatrix<T>(matrix: T[][], row: number, col: number, value: T) {\n  if (!matrix[row]) {\n    matrix[row] = [];\n  }\n  matrix[row][col] = value;\n}\n\n// Creates new array with only unique elements of the given array.\nfunction uniq<T>(arr: readonly T[]): readonly T[] {\n  const set = new Set();\n  const uniqArray: T[] = [];\n\n  for (const value of arr) {\n    if (!set.has(value)) {\n      set.add(value);\n      uniqArray.push(value);\n    }\n  }\n\n  return uniqArray;\n}\n"]},"metadata":{},"sourceType":"module"}