{"ast":null,"code":"import _slicedToArray from \"/Users/tangyizhi/Desktop/Assignment2/frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { useState, useLayoutEffect, useCallback, useEffect, createContext } from 'react';\nimport { useAppLayoutContext } from '../internal/context/app-layout-context';\nimport { findUpUntil, supportsStickyPosition } from '../internal/utils/dom';\nimport { getOverflowParents } from '../internal/utils/scrollable-containers';\nimport { useVisualRefresh } from '../internal/hooks/use-visual-mode';\nimport customCssProps from '../internal/generated/custom-css-properties';\nimport { useMobile } from '../internal/hooks/use-mobile';\nexport function computeOffset(_ref) {\n  var isMobile = _ref.isMobile,\n    isVisualRefresh = _ref.isVisualRefresh,\n    customCssProps = _ref.customCssProps,\n    __stickyOffset = _ref.__stickyOffset,\n    __mobileStickyOffset = _ref.__mobileStickyOffset,\n    _ref$mobileBarHeight = _ref.mobileBarHeight,\n    mobileBarHeight = _ref$mobileBarHeight === void 0 ? 0 : _ref$mobileBarHeight,\n    stickyOffsetTop = _ref.stickyOffsetTop,\n    hasInnerOverflowParents = _ref.hasInnerOverflowParents;\n  var effectiveStickyOffset = __stickyOffset !== null && __stickyOffset !== void 0 ? __stickyOffset : hasInnerOverflowParents ? 0 : stickyOffsetTop;\n  /**\n   * The AppLayout refactor removed the need for passing the sticky offset in px all the time through the\n   * AppLayoutDomContext provider because that information already exists on the DOM in a custom property\n   * on the Layout subcomponent. Thus, if the Container header is sticky, we are in Visual Refresh and use\n   * body scroll then we will use that property. When a component is used outside AppLayout, we fall back\n   * to the default offset calculated in AppLayoutDomContext.\n   */\n  var computedOffset = \"\".concat(effectiveStickyOffset, \"px\");\n  if (isMobile) {\n    // This mobile offset is only relevant for full page tables in the mobile viewport.\n    // It is obtained by the sum of stickyOffsetTop (AppLayout header height), mobileBarHeight (AppLayout mobile bar height) and\n    // __stickyOffset (value of the stickyHeaderVerticalOffset, set by users), from which we subtract __mobileStickyOffset (which is the table tools header height).\n    // Classic offset is calculated using the AppLayout context\n    var classicOffset = \"\".concat(stickyOffsetTop + mobileBarHeight + (__stickyOffset !== null && __stickyOffset !== void 0 ? __stickyOffset : 0) - (__mobileStickyOffset !== null && __mobileStickyOffset !== void 0 ? __mobileStickyOffset : 0), \"px\");\n    // VR offset is calculated using CSS custom properties\n    var visualRefreshOffset = \"calc(var(\".concat(customCssProps.offsetTop, \", 0px) + var(\").concat(customCssProps.mobileBarHeight, \", 0px) + \").concat((__stickyOffset !== null && __stickyOffset !== void 0 ? __stickyOffset : 0) - (__mobileStickyOffset !== null && __mobileStickyOffset !== void 0 ? __mobileStickyOffset : 0), \"px)\");\n    computedOffset = isVisualRefresh ? visualRefreshOffset : classicOffset;\n  } else if (isVisualRefresh && !hasInnerOverflowParents) {\n    computedOffset = \"var(\".concat(customCssProps.offsetTopWithNotifications, \", \").concat(computedOffset, \")\");\n  }\n  return computedOffset;\n}\nexport var StickyHeaderContext = createContext({\n  isStuck: false\n});\nexport var useStickyHeader = function useStickyHeader(rootRef, headerRef, __stickyHeader, __stickyOffset, __mobileStickyOffset) {\n  var __disableMobile = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n  var isMobile = useMobile();\n  // We reach into AppLayoutContext in case sticky header needs to be offset down by the height\n  // of other sticky elements positioned on top of the view.\n  var _useAppLayoutContext = useAppLayoutContext(),\n    stickyOffsetTop = _useAppLayoutContext.stickyOffsetTop,\n    mobileBarHeight = _useAppLayoutContext.mobileBarHeight;\n  var disableSticky = isMobile && __disableMobile;\n  var isSticky = supportsStickyPosition() && !disableSticky && !!__stickyHeader;\n  var isVisualRefresh = useVisualRefresh();\n  // If it has overflow parents inside the app layout, we shouldn't apply a sticky offset.\n  var _useState = useState(false),\n    _useState2 = _slicedToArray(_useState, 2),\n    hasInnerOverflowParents = _useState2[0],\n    setHasInnerOverflowParents = _useState2[1];\n  var _useState3 = useState(false),\n    _useState4 = _slicedToArray(_useState3, 2),\n    isStuck = _useState4[0],\n    setIsStuck = _useState4[1];\n  useLayoutEffect(function () {\n    if (rootRef.current) {\n      var overflowParents = getOverflowParents(rootRef.current);\n      var mainElement = findUpUntil(rootRef.current, function (elem) {\n        return elem.tagName === 'MAIN';\n      });\n      // In both versions of the app layout, the scrolling element for disableBodyScroll\n      // is the <main>. If the closest overflow parent is also the closest <main> and we have\n      // offset values, it's safe to assume that it's the app layout scroll root and we\n      // should stop there.\n      setHasInnerOverflowParents(overflowParents.length > 0 && overflowParents[0] !== mainElement);\n    }\n  }, [rootRef]);\n  var computedOffset = computeOffset({\n    isMobile: isMobile,\n    isVisualRefresh: isVisualRefresh,\n    customCssProps: customCssProps,\n    __stickyOffset: __stickyOffset,\n    __mobileStickyOffset: __mobileStickyOffset,\n    mobileBarHeight: mobileBarHeight,\n    stickyOffsetTop: stickyOffsetTop,\n    hasInnerOverflowParents: hasInnerOverflowParents\n  });\n  var stickyStyles = isSticky ? {\n    style: {\n      top: computedOffset\n    }\n  } : {};\n  // \"stuck\" state, when the header has moved from its original posititon has a\n  // box-shadow, applied here by a \"header-stuck\" className\n  var checkIfStuck = useCallback(function () {\n    if (rootRef.current && headerRef.current) {\n      var rootTop = rootRef.current.getBoundingClientRect().top;\n      var headerTop = headerRef.current.getBoundingClientRect().top;\n      if (rootTop < headerTop) {\n        setIsStuck(true);\n      } else {\n        setIsStuck(false);\n      }\n    }\n  }, [rootRef, headerRef]);\n  useEffect(function () {\n    if (isSticky) {\n      window.addEventListener('scroll', checkIfStuck, true);\n      window.addEventListener('resize', checkIfStuck);\n      return function () {\n        window.removeEventListener('scroll', checkIfStuck, true);\n        window.removeEventListener('resize', checkIfStuck);\n      };\n    }\n  }, [isSticky, checkIfStuck]);\n  return {\n    isSticky: isSticky,\n    isStuck: isStuck,\n    stickyStyles: stickyStyles\n  };\n};","map":{"version":3,"mappings":"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","names":["useState","useLayoutEffect","useCallback","useEffect","createContext","useAppLayoutContext","findUpUntil","supportsStickyPosition","getOverflowParents","useVisualRefresh","customCssProps","useMobile","computeOffset","isMobile","isVisualRefresh","__stickyOffset","__mobileStickyOffset","mobileBarHeight","stickyOffsetTop","hasInnerOverflowParents","effectiveStickyOffset","computedOffset","classicOffset","visualRefreshOffset","offsetTop","offsetTopWithNotifications","StickyHeaderContext","isStuck","useStickyHeader","rootRef","headerRef","__stickyHeader","__disableMobile","disableSticky","isSticky","setHasInnerOverflowParents","setIsStuck","current","overflowParents","mainElement","elem","tagName","length","stickyStyles","style","top","checkIfStuck","rootTop","getBoundingClientRect","headerTop","window","addEventListener","removeEventListener"],"sources":["/Users/tangyizhi/Desktop/Assignment2/frontend/node_modules/@cloudscape-design/components/container/lib/default/container/use-sticky-header.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { RefObject, useState, useLayoutEffect, useCallback, useEffect, createContext } from 'react';\nimport { useAppLayoutContext } from '../internal/context/app-layout-context';\nimport { findUpUntil, supportsStickyPosition } from '../internal/utils/dom';\nimport { getOverflowParents } from '../internal/utils/scrollable-containers';\nimport { useVisualRefresh } from '../internal/hooks/use-visual-mode';\nimport customCssProps from '../internal/generated/custom-css-properties';\nimport { useMobile } from '../internal/hooks/use-mobile';\ninterface StickyHeaderContextProps {\n  isStuck: boolean;\n}\n\ninterface ComputeOffsetProps {\n  isMobile: boolean;\n  isVisualRefresh: boolean;\n  customCssProps: Record<string, string>;\n  __stickyOffset?: number;\n  __mobileStickyOffset?: number;\n  mobileBarHeight?: number;\n  stickyOffsetTop: number;\n  hasInnerOverflowParents: boolean;\n}\n\nexport function computeOffset({\n  isMobile,\n  isVisualRefresh,\n  customCssProps,\n  __stickyOffset,\n  __mobileStickyOffset,\n  mobileBarHeight = 0,\n  stickyOffsetTop,\n  hasInnerOverflowParents,\n}: ComputeOffsetProps) {\n  const effectiveStickyOffset = __stickyOffset ?? (hasInnerOverflowParents ? 0 : stickyOffsetTop);\n  /**\n   * The AppLayout refactor removed the need for passing the sticky offset in px all the time through the\n   * AppLayoutDomContext provider because that information already exists on the DOM in a custom property\n   * on the Layout subcomponent. Thus, if the Container header is sticky, we are in Visual Refresh and use\n   * body scroll then we will use that property. When a component is used outside AppLayout, we fall back\n   * to the default offset calculated in AppLayoutDomContext.\n   */\n  let computedOffset = `${effectiveStickyOffset}px`;\n  if (isMobile) {\n    // This mobile offset is only relevant for full page tables in the mobile viewport.\n    // It is obtained by the sum of stickyOffsetTop (AppLayout header height), mobileBarHeight (AppLayout mobile bar height) and\n    // __stickyOffset (value of the stickyHeaderVerticalOffset, set by users), from which we subtract __mobileStickyOffset (which is the table tools header height).\n\n    // Classic offset is calculated using the AppLayout context\n    const classicOffset = `${\n      stickyOffsetTop + mobileBarHeight + (__stickyOffset ?? 0) - (__mobileStickyOffset ?? 0)\n    }px`;\n\n    // VR offset is calculated using CSS custom properties\n    const visualRefreshOffset = `calc(var(${customCssProps.offsetTop}, 0px) + var(${\n      customCssProps.mobileBarHeight\n    }, 0px) + ${(__stickyOffset ?? 0) - (__mobileStickyOffset ?? 0)}px)`;\n\n    computedOffset = isVisualRefresh ? visualRefreshOffset : classicOffset;\n  } else if (isVisualRefresh && !hasInnerOverflowParents) {\n    computedOffset = `var(${customCssProps.offsetTopWithNotifications}, ${computedOffset})`;\n  }\n  return computedOffset;\n}\n\nexport const StickyHeaderContext = createContext<StickyHeaderContextProps>({\n  isStuck: false,\n});\n\nexport const useStickyHeader = (\n  rootRef: RefObject<HTMLDivElement>,\n  headerRef: RefObject<HTMLDivElement>,\n  __stickyHeader?: boolean,\n  __stickyOffset?: number,\n  __mobileStickyOffset?: number,\n  __disableMobile = true\n) => {\n  const isMobile = useMobile();\n  // We reach into AppLayoutContext in case sticky header needs to be offset down by the height\n  // of other sticky elements positioned on top of the view.\n  const { stickyOffsetTop, mobileBarHeight } = useAppLayoutContext();\n  const disableSticky = isMobile && __disableMobile;\n  const isSticky = supportsStickyPosition() && !disableSticky && !!__stickyHeader;\n  const isVisualRefresh = useVisualRefresh();\n\n  // If it has overflow parents inside the app layout, we shouldn't apply a sticky offset.\n  const [hasInnerOverflowParents, setHasInnerOverflowParents] = useState(false);\n  const [isStuck, setIsStuck] = useState(false);\n  useLayoutEffect(() => {\n    if (rootRef.current) {\n      const overflowParents = getOverflowParents(rootRef.current);\n      const mainElement = findUpUntil(rootRef.current, elem => elem.tagName === 'MAIN');\n      // In both versions of the app layout, the scrolling element for disableBodyScroll\n      // is the <main>. If the closest overflow parent is also the closest <main> and we have\n      // offset values, it's safe to assume that it's the app layout scroll root and we\n      // should stop there.\n      setHasInnerOverflowParents(overflowParents.length > 0 && overflowParents[0] !== mainElement);\n    }\n  }, [rootRef]);\n\n  const computedOffset = computeOffset({\n    isMobile,\n    isVisualRefresh,\n    customCssProps,\n    __stickyOffset,\n    __mobileStickyOffset,\n    mobileBarHeight,\n    stickyOffsetTop,\n    hasInnerOverflowParents,\n  });\n\n  const stickyStyles = isSticky\n    ? {\n        style: {\n          top: computedOffset,\n        },\n      }\n    : {};\n\n  // \"stuck\" state, when the header has moved from its original posititon has a\n  // box-shadow, applied here by a \"header-stuck\" className\n  const checkIfStuck = useCallback(() => {\n    if (rootRef.current && headerRef.current) {\n      const rootTop = rootRef.current.getBoundingClientRect().top;\n      const headerTop = headerRef.current.getBoundingClientRect().top;\n      if (rootTop < headerTop) {\n        setIsStuck(true);\n      } else {\n        setIsStuck(false);\n      }\n    }\n  }, [rootRef, headerRef]);\n  useEffect(() => {\n    if (isSticky) {\n      window.addEventListener('scroll', checkIfStuck, true);\n      window.addEventListener('resize', checkIfStuck);\n      return () => {\n        window.removeEventListener('scroll', checkIfStuck, true);\n        window.removeEventListener('resize', checkIfStuck);\n      };\n    }\n  }, [isSticky, checkIfStuck]);\n  return {\n    isSticky,\n    isStuck,\n    stickyStyles,\n  };\n};\n"]},"metadata":{},"sourceType":"module"}