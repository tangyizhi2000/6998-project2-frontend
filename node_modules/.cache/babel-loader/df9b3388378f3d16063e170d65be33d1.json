{"ast":null,"code":"import _defineProperty from \"/Users/tangyizhi/Desktop/Assignment2/frontend/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _slicedToArray from \"/Users/tangyizhi/Desktop/Assignment2/frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport React, { useCallback, useLayoutEffect, useRef, useState } from 'react';\nimport clsx from 'clsx';\nimport { nodeContains } from '@cloudscape-design/component-toolkit/dom';\nimport { useResizeObserver } from '@cloudscape-design/component-toolkit/internal';\nimport { getContainingBlock } from '../internal/utils/dom';\nimport { calculatePosition } from './utils/positions';\nimport styles from './styles.css.js';\nimport { useVisualRefresh } from '../internal/hooks/use-visual-mode';\nvar INITIAL_STYLES = {\n  position: 'absolute',\n  top: -9999,\n  left: -9999\n};\nexport default function PopoverContainer(_ref) {\n  var _clsx;\n  var position = _ref.position,\n    trackRef = _ref.trackRef,\n    trackKey = _ref.trackKey,\n    arrow = _ref.arrow,\n    children = _ref.children,\n    zIndex = _ref.zIndex,\n    renderWithPortal = _ref.renderWithPortal,\n    size = _ref.size,\n    fixedWidth = _ref.fixedWidth,\n    variant = _ref.variant;\n  var bodyRef = useRef(null);\n  var contentRef = useRef(null);\n  var popoverRef = useRef(null);\n  var arrowRef = useRef(null);\n  var _useState = useState(INITIAL_STYLES),\n    _useState2 = _slicedToArray(_useState, 2),\n    popoverStyle = _useState2[0],\n    setPopoverStyle = _useState2[1];\n  var _useState3 = useState(null),\n    _useState4 = _slicedToArray(_useState3, 2),\n    internalPosition = _useState4[0],\n    setInternalPosition = _useState4[1];\n  var isRefresh = useVisualRefresh();\n  // Store the handler in a ref so that it can still be replaced from outside of the listener closure.\n  var positionHandlerRef = useRef(function () {});\n  // Updates the position handler.\n  var updatePositionHandler = useCallback(function () {\n    if (!trackRef.current || !popoverRef.current || !bodyRef.current || !contentRef.current || !arrowRef.current) {\n      return;\n    }\n    // Get important elements\n    var popover = popoverRef.current;\n    var body = bodyRef.current;\n    var arrow = arrowRef.current;\n    var document = popover.ownerDocument;\n    var track = trackRef.current;\n    // If the popover body isn't being rendered for whatever reason (e.g. \"display: none\" or JSDOM),\n    // or track does not belong to the document - bail on calculating dimensions.\n    if (popover.offsetWidth === 0 || popover.offsetHeight === 0 || !nodeContains(document.body, track)) {\n      return;\n    }\n    // Imperatively move body off-screen to give it room to expand.\n    // Not doing this in React because this recalculation should happen\n    // in the span of a single frame without rerendering anything.\n    var prevTop = popover.style.top;\n    var prevLeft = popover.style.left;\n    popover.style.top = '0';\n    popover.style.left = '0';\n    // Imperatively remove body styles that can remain from the previous computation.\n    body.style.maxHeight = '';\n    body.style.overflowX = '';\n    body.style.overflowY = '';\n    // Get rects representing key elements\n    // Use getComputedStyle for arrowRect to avoid modifications made by transform\n    var viewportRect = getViewportRect(document.defaultView);\n    var trackRect = track.getBoundingClientRect();\n    var arrowRect = {\n      width: parseFloat(getComputedStyle(arrow).width),\n      height: parseFloat(getComputedStyle(arrow).height)\n    };\n    var containingBlock = getContainingBlock(popover);\n    var containingBlockRect = containingBlock ? containingBlock.getBoundingClientRect() : viewportRect;\n    var bodyBorderWidth = getBorderWidth(body);\n    var contentRect = contentRef.current.getBoundingClientRect();\n    var contentBoundingBox = {\n      width: contentRect.width + 2 * bodyBorderWidth,\n      height: contentRect.height + 2 * bodyBorderWidth\n    };\n    // Calculate the arrow direction and viewport-relative position of the popover.\n    var _calculatePosition = calculatePosition(position, trackRect, arrowRect, contentBoundingBox, containingBlock ? containingBlockRect : getDocumentRect(document), viewportRect, renderWithPortal),\n      scrollable = _calculatePosition.scrollable,\n      newInternalPosition = _calculatePosition.internalPosition,\n      boundingOffset = _calculatePosition.boundingOffset;\n    // Get the position of the popover relative to the offset parent.\n    var popoverOffset = toRelativePosition(boundingOffset, containingBlockRect);\n    // Cache the distance between the trigger and the popover (which stays the same as you scroll),\n    // and use that to recalculate the new popover position.\n    var trackRelativeOffset = toRelativePosition(popoverOffset, toRelativePosition(trackRect, containingBlockRect));\n    // Bring back the container to its original position to prevent any flashing.\n    popover.style.top = prevTop;\n    popover.style.left = prevLeft;\n    // Allow popover body to scroll if can't fit the popover into the container/viewport otherwise.\n    if (scrollable) {\n      body.style.maxHeight = boundingOffset.height + 'px';\n      body.style.overflowX = 'hidden';\n      body.style.overflowY = 'auto';\n    }\n    // Position the popover\n    setInternalPosition(newInternalPosition);\n    setPopoverStyle({\n      top: popoverOffset.top,\n      left: popoverOffset.left\n    });\n    positionHandlerRef.current = function () {\n      var newTrackOffset = toRelativePosition(track.getBoundingClientRect(), containingBlock ? containingBlock.getBoundingClientRect() : viewportRect);\n      setPopoverStyle({\n        top: newTrackOffset.top + trackRelativeOffset.top,\n        left: newTrackOffset.left + trackRelativeOffset.left\n      });\n    };\n  }, [position, trackRef, renderWithPortal]);\n  // Recalculate position when properties change.\n  useLayoutEffect(function () {\n    updatePositionHandler();\n  }, [updatePositionHandler, trackKey]);\n  // Recalculate position when content size changes.\n  useResizeObserver(contentRef, function () {\n    return updatePositionHandler();\n  });\n  // Recalculate position on DOM events.\n  useLayoutEffect(function () {\n    /*\n      This is a heuristic. Some layout changes are caused by user clicks (e.g. toggling the tools panel, submitting a form),\n      and by tracking the click event we can adapt the popover's position to the new layout.\n           TODO: extend this to Enter and Spacebar?\n    */\n    var updatePosition = function updatePosition() {\n      return requestAnimationFrame(function () {\n        return updatePositionHandler();\n      });\n    };\n    var refreshPosition = function refreshPosition() {\n      return requestAnimationFrame(function () {\n        return positionHandlerRef.current();\n      });\n    };\n    window.addEventListener('click', updatePosition);\n    window.addEventListener('resize', updatePosition);\n    window.addEventListener('scroll', refreshPosition, true);\n    return function () {\n      window.removeEventListener('click', updatePosition);\n      window.removeEventListener('resize', updatePosition);\n      window.removeEventListener('scroll', refreshPosition, true);\n    };\n  }, [updatePositionHandler]);\n  return React.createElement(\"div\", {\n    ref: popoverRef,\n    style: Object.assign(Object.assign({}, popoverStyle), {\n      zIndex: zIndex\n    }),\n    className: clsx(styles.container, isRefresh && styles.refresh)\n  }, React.createElement(\"div\", {\n    ref: arrowRef,\n    className: clsx(styles[\"container-arrow\"], styles[\"container-arrow-position-\".concat(internalPosition)]),\n    \"aria-hidden\": true\n  }, arrow(internalPosition)), React.createElement(\"div\", {\n    ref: bodyRef,\n    className: clsx(styles['container-body'], styles[\"container-body-size-\".concat(size)], (_clsx = {}, _defineProperty(_clsx, styles['fixed-width'], fixedWidth), _defineProperty(_clsx, styles[\"container-body-variant-\".concat(variant)], variant), _clsx))\n  }, React.createElement(\"div\", {\n    ref: contentRef\n  }, children)));\n}\nfunction getBorderWidth(element) {\n  return parseInt(getComputedStyle(element).borderWidth) || 0;\n}\n/**\n * Convert a viewport-relative offset to an element-relative offset.\n */\nfunction toRelativePosition(element, parent) {\n  return {\n    top: element.top - parent.top,\n    left: element.left - parent.left\n  };\n}\n/**\n * Get a BoundingOffset that represents the visible viewport.\n */\nfunction getViewportRect(window) {\n  return {\n    top: 0,\n    left: 0,\n    width: window.innerWidth,\n    height: window.innerHeight\n  };\n}\nfunction getDocumentRect(document) {\n  var _document$documentEle = document.documentElement.getBoundingClientRect(),\n    top = _document$documentEle.top,\n    left = _document$documentEle.left;\n  return {\n    top: top,\n    left: left,\n    width: document.documentElement.scrollWidth,\n    height: document.documentElement.scrollHeight\n  };\n}","map":{"version":3,"mappings":";;AAAA;AACA;AACA,OAAOA,KAAK,IAAmBC,WAAW,EAAEC,eAAe,EAAEC,MAAM,EAAEC,QAAQ,QAAQ,OAAO;AAC5F,OAAOC,IAAI,MAAM,MAAM;AACvB,SAASC,YAAY,QAAQ,0CAA0C;AACvE,SAASC,iBAAiB,QAAQ,+CAA+C;AAEjF,SAASC,kBAAkB,QAAQ,uBAAuB;AAE1D,SAASC,iBAAiB,QAAQ,mBAAmB;AACrD,OAAOC,MAAM,MAAM,iBAAiB;AACpC,SAASC,gBAAgB,QAAQ,mCAAmC;AAyBpE,IAAMC,cAAc,GAAkB;EAAEC,QAAQ,EAAE,UAAU;EAAEC,GAAG,EAAE,CAAC,IAAI;EAAEC,IAAI,EAAE,CAAC;AAAI,CAAE;AAEvF,eAAc,SAAUC,gBAAgB,OAWhB;EAAA;EAAA,IAVtBH,QAAQ,QAARA,QAAQ;IACRI,QAAQ,QAARA,QAAQ;IACRC,QAAQ,QAARA,QAAQ;IACRC,KAAK,QAALA,KAAK;IACLC,QAAQ,QAARA,QAAQ;IACRC,MAAM,QAANA,MAAM;IACNC,gBAAgB,QAAhBA,gBAAgB;IAChBC,IAAI,QAAJA,IAAI;IACJC,UAAU,QAAVA,UAAU;IACVC,OAAO,QAAPA,OAAO;EAEP,IAAMC,OAAO,GAAGvB,MAAM,CAAwB,IAAI,CAAC;EACnD,IAAMwB,UAAU,GAAGxB,MAAM,CAAwB,IAAI,CAAC;EACtD,IAAMyB,UAAU,GAAGzB,MAAM,CAAwB,IAAI,CAAC;EACtD,IAAM0B,QAAQ,GAAG1B,MAAM,CAAwB,IAAI,CAAC;EAEpD,gBAAwCC,QAAQ,CAAgBQ,cAAc,CAAC;IAAA;IAAxEkB,YAAY;IAAEC,eAAe;EACpC,iBAAgD3B,QAAQ,CAA0B,IAAI,CAAC;IAAA;IAAhF4B,gBAAgB;IAAEC,mBAAmB;EAC5C,IAAMC,SAAS,GAAGvB,gBAAgB,EAAE;EAEpC;EACA,IAAMwB,kBAAkB,GAAGhC,MAAM,CAAa,YAAK,CAAE,CAAC,CAAC;EAEvD;EACA,IAAMiC,qBAAqB,GAAGnC,WAAW,CAAC,YAAK;IAC7C,IAAI,CAACgB,QAAQ,CAACoB,OAAO,IAAI,CAACT,UAAU,CAACS,OAAO,IAAI,CAACX,OAAO,CAACW,OAAO,IAAI,CAACV,UAAU,CAACU,OAAO,IAAI,CAACR,QAAQ,CAACQ,OAAO,EAAE;MAC5G;;IAGF;IACA,IAAMC,OAAO,GAAGV,UAAU,CAACS,OAAO;IAClC,IAAME,IAAI,GAAGb,OAAO,CAACW,OAAO;IAC5B,IAAMlB,KAAK,GAAGU,QAAQ,CAACQ,OAAO;IAC9B,IAAMG,QAAQ,GAAGF,OAAO,CAACG,aAAa;IACtC,IAAMC,KAAK,GAAGzB,QAAQ,CAACoB,OAAO;IAE9B;IACA;IACA,IAAIC,OAAO,CAACK,WAAW,KAAK,CAAC,IAAIL,OAAO,CAACM,YAAY,KAAK,CAAC,IAAI,CAACtC,YAAY,CAACkC,QAAQ,CAACD,IAAI,EAAEG,KAAK,CAAC,EAAE;MAClG;;IAGF;IACA;IACA;IACA,IAAMG,OAAO,GAAGP,OAAO,CAACQ,KAAK,CAAChC,GAAG;IACjC,IAAMiC,QAAQ,GAAGT,OAAO,CAACQ,KAAK,CAAC/B,IAAI;IACnCuB,OAAO,CAACQ,KAAK,CAAChC,GAAG,GAAG,GAAG;IACvBwB,OAAO,CAACQ,KAAK,CAAC/B,IAAI,GAAG,GAAG;IACxB;IACAwB,IAAI,CAACO,KAAK,CAACE,SAAS,GAAG,EAAE;IACzBT,IAAI,CAACO,KAAK,CAACG,SAAS,GAAG,EAAE;IACzBV,IAAI,CAACO,KAAK,CAACI,SAAS,GAAG,EAAE;IAEzB;IACA;IACA,IAAMC,YAAY,GAAGC,eAAe,CAACZ,QAAQ,CAACa,WAAY,CAAC;IAC3D,IAAMC,SAAS,GAAGZ,KAAK,CAACa,qBAAqB,EAAE;IAC/C,IAAMC,SAAS,GAAG;MAChBC,KAAK,EAAEC,UAAU,CAACC,gBAAgB,CAACxC,KAAK,CAAC,CAACsC,KAAK,CAAC;MAChDG,MAAM,EAAEF,UAAU,CAACC,gBAAgB,CAACxC,KAAK,CAAC,CAACyC,MAAM;KAClD;IACD,IAAMC,eAAe,GAAGrD,kBAAkB,CAAC8B,OAAO,CAAC;IACnD,IAAMwB,mBAAmB,GAAGD,eAAe,GAAGA,eAAe,CAACN,qBAAqB,EAAE,GAAGJ,YAAY;IAEpG,IAAMY,eAAe,GAAGC,cAAc,CAACzB,IAAI,CAAC;IAC5C,IAAM0B,WAAW,GAAGtC,UAAU,CAACU,OAAO,CAACkB,qBAAqB,EAAE;IAC9D,IAAMW,kBAAkB,GAAG;MACzBT,KAAK,EAAEQ,WAAW,CAACR,KAAK,GAAG,CAAC,GAAGM,eAAe;MAC9CH,MAAM,EAAEK,WAAW,CAACL,MAAM,GAAG,CAAC,GAAGG;KAClC;IAED;IACA,yBAIItD,iBAAiB,CACnBI,QAAQ,EACRyC,SAAS,EACTE,SAAS,EACTU,kBAAkB,EAClBL,eAAe,GAAGC,mBAAmB,GAAGK,eAAe,CAAC3B,QAAQ,CAAC,EACjEW,YAAY,EACZ7B,gBAAgB,CACjB;MAXC8C,UAAU,sBAAVA,UAAU;MACQC,mBAAmB,sBAArCrC,gBAAgB;MAChBsC,cAAc,sBAAdA,cAAc;IAWhB;IACA,IAAMC,aAAa,GAAGC,kBAAkB,CAACF,cAAc,EAAER,mBAAmB,CAAC;IAE7E;IACA;IACA,IAAMW,mBAAmB,GAAGD,kBAAkB,CAACD,aAAa,EAAEC,kBAAkB,CAAClB,SAAS,EAAEQ,mBAAmB,CAAC,CAAC;IAEjH;IACAxB,OAAO,CAACQ,KAAK,CAAChC,GAAG,GAAG+B,OAAO;IAC3BP,OAAO,CAACQ,KAAK,CAAC/B,IAAI,GAAGgC,QAAQ;IAE7B;IACA,IAAIqB,UAAU,EAAE;MACd7B,IAAI,CAACO,KAAK,CAACE,SAAS,GAAGsB,cAAc,CAACV,MAAM,GAAG,IAAI;MACnDrB,IAAI,CAACO,KAAK,CAACG,SAAS,GAAG,QAAQ;MAC/BV,IAAI,CAACO,KAAK,CAACI,SAAS,GAAG,MAAM;;IAG/B;IACAjB,mBAAmB,CAACoC,mBAAmB,CAAC;IACxCtC,eAAe,CAAC;MAAEjB,GAAG,EAAEyD,aAAa,CAACzD,GAAG;MAAEC,IAAI,EAAEwD,aAAa,CAACxD;IAAI,CAAE,CAAC;IAErEoB,kBAAkB,CAACE,OAAO,GAAG,YAAK;MAChC,IAAMqC,cAAc,GAAGF,kBAAkB,CACvC9B,KAAK,CAACa,qBAAqB,EAAE,EAC7BM,eAAe,GAAGA,eAAe,CAACN,qBAAqB,EAAE,GAAGJ,YAAY,CACzE;MACDpB,eAAe,CAAC;QACdjB,GAAG,EAAE4D,cAAc,CAAC5D,GAAG,GAAG2D,mBAAmB,CAAC3D,GAAG;QACjDC,IAAI,EAAE2D,cAAc,CAAC3D,IAAI,GAAG0D,mBAAmB,CAAC1D;OACjD,CAAC;IACJ,CAAC;EACH,CAAC,EAAE,CAACF,QAAQ,EAAEI,QAAQ,EAAEK,gBAAgB,CAAC,CAAC;EAE1C;EACApB,eAAe,CAAC,YAAK;IACnBkC,qBAAqB,EAAE;EACzB,CAAC,EAAE,CAACA,qBAAqB,EAAElB,QAAQ,CAAC,CAAC;EAErC;EACAX,iBAAiB,CAACoB,UAAU,EAAE;IAAA,OAAMS,qBAAqB,EAAE;EAAA,EAAC;EAE5D;EACAlC,eAAe,CAAC,YAAK;IACnB;;;;;IAMA,IAAMyE,cAAc,GAAG,SAAjBA,cAAc;MAAA,OAASC,qBAAqB,CAAC;QAAA,OAAMxC,qBAAqB,EAAE;MAAA,EAAC;IAAA;IACjF,IAAMyC,eAAe,GAAG,SAAlBA,eAAe;MAAA,OAASD,qBAAqB,CAAC;QAAA,OAAMzC,kBAAkB,CAACE,OAAO,EAAE;MAAA,EAAC;IAAA;IAEvFyC,MAAM,CAACC,gBAAgB,CAAC,OAAO,EAAEJ,cAAc,CAAC;IAChDG,MAAM,CAACC,gBAAgB,CAAC,QAAQ,EAAEJ,cAAc,CAAC;IACjDG,MAAM,CAACC,gBAAgB,CAAC,QAAQ,EAAEF,eAAe,EAAE,IAAI,CAAC;IACxD,OAAO,YAAK;MACVC,MAAM,CAACE,mBAAmB,CAAC,OAAO,EAAEL,cAAc,CAAC;MACnDG,MAAM,CAACE,mBAAmB,CAAC,QAAQ,EAAEL,cAAc,CAAC;MACpDG,MAAM,CAACE,mBAAmB,CAAC,QAAQ,EAAEH,eAAe,EAAE,IAAI,CAAC;IAC7D,CAAC;EACH,CAAC,EAAE,CAACzC,qBAAqB,CAAC,CAAC;EAE3B,OACEpC;IACEiF,GAAG,EAAErD,UAAU;IACfkB,KAAK,kCAAOhB,YAAY;MAAET,MAAM,EAANA;IAAM;IAChC6D,SAAS,EAAE7E,IAAI,CAACK,MAAM,CAACyE,SAAS,EAAEjD,SAAS,IAAIxB,MAAM,CAAC0E,OAAO;EAAC,GAE9DpF;IACEiF,GAAG,EAAEpD,QAAQ;IACbqD,SAAS,EAAE7E,IAAI,CAACK,MAAM,mBAAmB,EAAEA,MAAM,oCAA6BsB,gBAAgB,EAAG,CAAC;IAAA,eACrF;EAAI,GAEhBb,KAAK,CAACa,gBAAgB,CAAC,CACpB,EAENhC;IACEiF,GAAG,EAAEvD,OAAO;IACZwD,SAAS,EAAE7E,IAAI,CAACK,MAAM,CAAC,gBAAgB,CAAC,EAAEA,MAAM,+BAAwBa,IAAI,EAAG,sCAC5Eb,MAAM,CAAC,aAAa,CAAC,EAAGc,UAAU,0BAClCd,MAAM,kCAA2Be,OAAO,EAAG,EAAGA,OAAO;EACtD,GAEFzB;IAAKiF,GAAG,EAAEtD;EAAU,GAAGP,QAAQ,CAAO,CAClC,CACF;AAEV;AAEA,SAAS4C,cAAc,CAACqB,OAAoB;EAC1C,OAAOC,QAAQ,CAAC3B,gBAAgB,CAAC0B,OAAO,CAAC,CAACE,WAAW,CAAC,IAAI,CAAC;AAC7D;AAEA;;;AAGA,SAASf,kBAAkB,CAACa,OAAe,EAAEG,MAAc;EACzD,OAAO;IACL1E,GAAG,EAAEuE,OAAO,CAACvE,GAAG,GAAG0E,MAAM,CAAC1E,GAAG;IAC7BC,IAAI,EAAEsE,OAAO,CAACtE,IAAI,GAAGyE,MAAM,CAACzE;GAC7B;AACH;AAEA;;;AAGA,SAASqC,eAAe,CAAC0B,MAAc;EACrC,OAAO;IACLhE,GAAG,EAAE,CAAC;IACNC,IAAI,EAAE,CAAC;IACP0C,KAAK,EAAEqB,MAAM,CAACW,UAAU;IACxB7B,MAAM,EAAEkB,MAAM,CAACY;GAChB;AACH;AAEA,SAASvB,eAAe,CAAC3B,QAAkB;EACzC,4BAAsBA,QAAQ,CAACmD,eAAe,CAACpC,qBAAqB,EAAE;IAA9DzC,GAAG,yBAAHA,GAAG;IAAEC,IAAI,yBAAJA,IAAI;EACjB,OAAO;IACLD,GAAG,EAAHA,GAAG;IACHC,IAAI,EAAJA,IAAI;IACJ0C,KAAK,EAAEjB,QAAQ,CAACmD,eAAe,CAACC,WAAW;IAC3ChC,MAAM,EAAEpB,QAAQ,CAACmD,eAAe,CAACE;GAClC;AACH","names":["React","useCallback","useLayoutEffect","useRef","useState","clsx","nodeContains","useResizeObserver","getContainingBlock","calculatePosition","styles","useVisualRefresh","INITIAL_STYLES","position","top","left","PopoverContainer","trackRef","trackKey","arrow","children","zIndex","renderWithPortal","size","fixedWidth","variant","bodyRef","contentRef","popoverRef","arrowRef","popoverStyle","setPopoverStyle","internalPosition","setInternalPosition","isRefresh","positionHandlerRef","updatePositionHandler","current","popover","body","document","ownerDocument","track","offsetWidth","offsetHeight","prevTop","style","prevLeft","maxHeight","overflowX","overflowY","viewportRect","getViewportRect","defaultView","trackRect","getBoundingClientRect","arrowRect","width","parseFloat","getComputedStyle","height","containingBlock","containingBlockRect","bodyBorderWidth","getBorderWidth","contentRect","contentBoundingBox","getDocumentRect","scrollable","newInternalPosition","boundingOffset","popoverOffset","toRelativePosition","trackRelativeOffset","newTrackOffset","updatePosition","requestAnimationFrame","refreshPosition","window","addEventListener","removeEventListener","ref","className","container","refresh","element","parseInt","borderWidth","parent","innerWidth","innerHeight","documentElement","scrollWidth","scrollHeight"],"sources":["/Users/tangyizhi/Desktop/Assignment2/frontend/node_modules/@cloudscape-design/components/popover/lib/default/popover/container.tsx"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport React, { CSSProperties, useCallback, useLayoutEffect, useRef, useState } from 'react';\nimport clsx from 'clsx';\nimport { nodeContains } from '@cloudscape-design/component-toolkit/dom';\nimport { useResizeObserver } from '@cloudscape-design/component-toolkit/internal';\n\nimport { getContainingBlock } from '../internal/utils/dom';\nimport { BoundingOffset, InternalPosition, Offset, PopoverProps } from './interfaces';\nimport { calculatePosition } from './utils/positions';\nimport styles from './styles.css.js';\nimport { useVisualRefresh } from '../internal/hooks/use-visual-mode';\n\nexport interface PopoverContainerProps {\n  /** References the element the container is positioned against. */\n  trackRef: React.RefObject<Element>;\n  /**\n    Used to update the container position in case track or track position changes:\n    \n    const trackRef = useRef<Element>(null)\n    return (<>\n      <Track style={getPosition(selectedItemId)} ref={trackRef} />\n      <PopoverContainer trackRef={trackRef} trackKey={selectedItemId} .../>\n    </>)\n  */\n  trackKey?: string | number;\n  position: PopoverProps.Position;\n  zIndex?: React.CSSProperties['zIndex'];\n  arrow: (position: InternalPosition | null) => React.ReactNode;\n  children: React.ReactNode;\n  renderWithPortal?: boolean;\n  size: PopoverProps.Size;\n  fixedWidth: boolean;\n  variant?: 'annotation';\n}\n\nconst INITIAL_STYLES: CSSProperties = { position: 'absolute', top: -9999, left: -9999 };\n\nexport default function PopoverContainer({\n  position,\n  trackRef,\n  trackKey,\n  arrow,\n  children,\n  zIndex,\n  renderWithPortal,\n  size,\n  fixedWidth,\n  variant,\n}: PopoverContainerProps) {\n  const bodyRef = useRef<HTMLDivElement | null>(null);\n  const contentRef = useRef<HTMLDivElement | null>(null);\n  const popoverRef = useRef<HTMLDivElement | null>(null);\n  const arrowRef = useRef<HTMLDivElement | null>(null);\n\n  const [popoverStyle, setPopoverStyle] = useState<CSSProperties>(INITIAL_STYLES);\n  const [internalPosition, setInternalPosition] = useState<InternalPosition | null>(null);\n  const isRefresh = useVisualRefresh();\n\n  // Store the handler in a ref so that it can still be replaced from outside of the listener closure.\n  const positionHandlerRef = useRef<() => void>(() => {});\n\n  // Updates the position handler.\n  const updatePositionHandler = useCallback(() => {\n    if (!trackRef.current || !popoverRef.current || !bodyRef.current || !contentRef.current || !arrowRef.current) {\n      return;\n    }\n\n    // Get important elements\n    const popover = popoverRef.current;\n    const body = bodyRef.current;\n    const arrow = arrowRef.current;\n    const document = popover.ownerDocument;\n    const track = trackRef.current;\n\n    // If the popover body isn't being rendered for whatever reason (e.g. \"display: none\" or JSDOM),\n    // or track does not belong to the document - bail on calculating dimensions.\n    if (popover.offsetWidth === 0 || popover.offsetHeight === 0 || !nodeContains(document.body, track)) {\n      return;\n    }\n\n    // Imperatively move body off-screen to give it room to expand.\n    // Not doing this in React because this recalculation should happen\n    // in the span of a single frame without rerendering anything.\n    const prevTop = popover.style.top;\n    const prevLeft = popover.style.left;\n    popover.style.top = '0';\n    popover.style.left = '0';\n    // Imperatively remove body styles that can remain from the previous computation.\n    body.style.maxHeight = '';\n    body.style.overflowX = '';\n    body.style.overflowY = '';\n\n    // Get rects representing key elements\n    // Use getComputedStyle for arrowRect to avoid modifications made by transform\n    const viewportRect = getViewportRect(document.defaultView!);\n    const trackRect = track.getBoundingClientRect();\n    const arrowRect = {\n      width: parseFloat(getComputedStyle(arrow).width),\n      height: parseFloat(getComputedStyle(arrow).height),\n    };\n    const containingBlock = getContainingBlock(popover);\n    const containingBlockRect = containingBlock ? containingBlock.getBoundingClientRect() : viewportRect;\n\n    const bodyBorderWidth = getBorderWidth(body);\n    const contentRect = contentRef.current.getBoundingClientRect();\n    const contentBoundingBox = {\n      width: contentRect.width + 2 * bodyBorderWidth,\n      height: contentRect.height + 2 * bodyBorderWidth,\n    };\n\n    // Calculate the arrow direction and viewport-relative position of the popover.\n    const {\n      scrollable,\n      internalPosition: newInternalPosition,\n      boundingOffset,\n    } = calculatePosition(\n      position,\n      trackRect,\n      arrowRect,\n      contentBoundingBox,\n      containingBlock ? containingBlockRect : getDocumentRect(document),\n      viewportRect,\n      renderWithPortal\n    );\n\n    // Get the position of the popover relative to the offset parent.\n    const popoverOffset = toRelativePosition(boundingOffset, containingBlockRect);\n\n    // Cache the distance between the trigger and the popover (which stays the same as you scroll),\n    // and use that to recalculate the new popover position.\n    const trackRelativeOffset = toRelativePosition(popoverOffset, toRelativePosition(trackRect, containingBlockRect));\n\n    // Bring back the container to its original position to prevent any flashing.\n    popover.style.top = prevTop;\n    popover.style.left = prevLeft;\n\n    // Allow popover body to scroll if can't fit the popover into the container/viewport otherwise.\n    if (scrollable) {\n      body.style.maxHeight = boundingOffset.height + 'px';\n      body.style.overflowX = 'hidden';\n      body.style.overflowY = 'auto';\n    }\n\n    // Position the popover\n    setInternalPosition(newInternalPosition);\n    setPopoverStyle({ top: popoverOffset.top, left: popoverOffset.left });\n\n    positionHandlerRef.current = () => {\n      const newTrackOffset = toRelativePosition(\n        track.getBoundingClientRect(),\n        containingBlock ? containingBlock.getBoundingClientRect() : viewportRect\n      );\n      setPopoverStyle({\n        top: newTrackOffset.top + trackRelativeOffset.top,\n        left: newTrackOffset.left + trackRelativeOffset.left,\n      });\n    };\n  }, [position, trackRef, renderWithPortal]);\n\n  // Recalculate position when properties change.\n  useLayoutEffect(() => {\n    updatePositionHandler();\n  }, [updatePositionHandler, trackKey]);\n\n  // Recalculate position when content size changes.\n  useResizeObserver(contentRef, () => updatePositionHandler());\n\n  // Recalculate position on DOM events.\n  useLayoutEffect(() => {\n    /*\n      This is a heuristic. Some layout changes are caused by user clicks (e.g. toggling the tools panel, submitting a form),\n      and by tracking the click event we can adapt the popover's position to the new layout.\n\n      TODO: extend this to Enter and Spacebar?\n    */\n    const updatePosition = () => requestAnimationFrame(() => updatePositionHandler());\n    const refreshPosition = () => requestAnimationFrame(() => positionHandlerRef.current());\n\n    window.addEventListener('click', updatePosition);\n    window.addEventListener('resize', updatePosition);\n    window.addEventListener('scroll', refreshPosition, true);\n    return () => {\n      window.removeEventListener('click', updatePosition);\n      window.removeEventListener('resize', updatePosition);\n      window.removeEventListener('scroll', refreshPosition, true);\n    };\n  }, [updatePositionHandler]);\n\n  return (\n    <div\n      ref={popoverRef}\n      style={{ ...popoverStyle, zIndex }}\n      className={clsx(styles.container, isRefresh && styles.refresh)}\n    >\n      <div\n        ref={arrowRef}\n        className={clsx(styles[`container-arrow`], styles[`container-arrow-position-${internalPosition}`])}\n        aria-hidden={true}\n      >\n        {arrow(internalPosition)}\n      </div>\n\n      <div\n        ref={bodyRef}\n        className={clsx(styles['container-body'], styles[`container-body-size-${size}`], {\n          [styles['fixed-width']]: fixedWidth,\n          [styles[`container-body-variant-${variant}`]]: variant,\n        })}\n      >\n        <div ref={contentRef}>{children}</div>\n      </div>\n    </div>\n  );\n}\n\nfunction getBorderWidth(element: HTMLElement) {\n  return parseInt(getComputedStyle(element).borderWidth) || 0;\n}\n\n/**\n * Convert a viewport-relative offset to an element-relative offset.\n */\nfunction toRelativePosition(element: Offset, parent: Offset): Offset {\n  return {\n    top: element.top - parent.top,\n    left: element.left - parent.left,\n  };\n}\n\n/**\n * Get a BoundingOffset that represents the visible viewport.\n */\nfunction getViewportRect(window: Window): BoundingOffset {\n  return {\n    top: 0,\n    left: 0,\n    width: window.innerWidth,\n    height: window.innerHeight,\n  };\n}\n\nfunction getDocumentRect(document: Document): BoundingOffset {\n  const { top, left } = document.documentElement.getBoundingClientRect();\n  return {\n    top,\n    left,\n    width: document.documentElement.scrollWidth,\n    height: document.documentElement.scrollHeight,\n  };\n}\n"]},"metadata":{},"sourceType":"module"}