{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport React, { useMemo } from 'react';\nimport clsx from 'clsx';\nimport { matchesX, getKeyValue } from './utils';\nimport styles from './styles.css.js';\nimport { useVisualRefresh } from '../internal/hooks/use-visual-mode';\nexport default function BarSeries(_ref) {\n  let {\n    axis,\n    series,\n    color,\n    xScale,\n    yScale,\n    highlighted,\n    dimmed,\n    highlightedGroupIndex,\n    stackedBarOffsets,\n    totalSeriesCount,\n    seriesIndex,\n    plotSize,\n    chartAreaClipPath\n  } = _ref;\n  const isRefresh = useVisualRefresh();\n  const xCoordinates = useMemo(() => {\n    var _a;\n    if (series.type !== 'bar' || !xScale.isCategorical()) {\n      return [];\n    }\n    const yContinuosScale = yScale.d3Scale;\n    const xPoints = series.data.map(_ref2 => {\n      let {\n        x\n      } = _ref2;\n      return xScale.d3Scale(x) || NaN;\n    });\n    const zeroY = (_a = yScale.d3Scale(0)) !== null && _a !== void 0 ? _a : NaN;\n    const baseY = isFinite(zeroY) ? Math.min(plotSize, zeroY) : plotSize;\n    let barWidth = xScale.d3Scale.bandwidth();\n    const PADDING = 4;\n    const MINWIDTH = 4;\n    if (!stackedBarOffsets && totalSeriesCount > 1) {\n      // Regular grouped bars\n      barWidth = (barWidth - (totalSeriesCount - 1) * PADDING) / totalSeriesCount;\n      barWidth = Math.max(barWidth, MINWIDTH);\n    }\n    return xPoints.map((x, i) => {\n      var _a, _b;\n      const d = series.data[i];\n      let barX = x;\n      let yValue = d.y;\n      if (stackedBarOffsets) {\n        // Stacked bars\n        const offsetMap = d.y < 0 ? stackedBarOffsets.negativeOffsets : stackedBarOffsets.positiveOffsets;\n        yValue = d.y + (offsetMap[getKeyValue(d.x)] || 0);\n      } else if (totalSeriesCount > 1) {\n        // Regular grouped bars\n        barX += seriesIndex * (barWidth + PADDING);\n      }\n      // Account for negative values growing \"down\" instead of \"up\"\n      yValue = yValue < 0 ? yValue - d.y : yValue;\n      return {\n        x: barX,\n        y: (_a = yContinuosScale(yValue)) !== null && _a !== void 0 ? _a : NaN,\n        width: barWidth,\n        height: Math.abs(((_b = yContinuosScale(d.y)) !== null && _b !== void 0 ? _b : NaN) - baseY)\n      };\n    });\n  }, [series, xScale, yScale, plotSize, stackedBarOffsets, totalSeriesCount, seriesIndex]);\n  const highlightedXValue = highlightedGroupIndex !== null ? xScale.domain[highlightedGroupIndex] : null;\n  return React.createElement(\"g\", {\n    \"aria-label\": series.title,\n    clipPath: `url(#${chartAreaClipPath})`,\n    className: clsx(styles.series, styles['series--bar'], {\n      [styles['series--highlighted']]: highlighted,\n      [styles['series--dimmed']]: dimmed\n    })\n  }, xCoordinates.map((_ref3, i) => {\n    let {\n      x,\n      y,\n      width,\n      height\n    } = _ref3;\n    if (!isFinite(x) || !isFinite(height)) {\n      return;\n    }\n    // Create margins between stacked series but only when series data is not too small.\n    const baseHeightOffset = stackedBarOffsets ? 3 : 0;\n    const isSmallBar = height < 4;\n    const heightOffset = isSmallBar ? 0 : baseHeightOffset;\n    const widthOffset = 2;\n    const rx = isRefresh ? isSmallBar ? '2px' : '4px' : '0px';\n    const className = clsx(styles.series__rect, {\n      [styles['series--dimmed']]: highlightedXValue !== null && !matchesX(highlightedXValue, series.data[i].x)\n    });\n    return axis === 'x' ? React.createElement(\"rect\", {\n      key: `bar-${i}`,\n      fill: color,\n      x: x + widthOffset / 2,\n      y: y + heightOffset / 2,\n      width: width - widthOffset,\n      height: height - heightOffset,\n      rx: rx,\n      className: className\n    }) : React.createElement(\"rect\", {\n      key: `bar-${i}`,\n      fill: color,\n      x: y - height + heightOffset / 2,\n      y: x + widthOffset / 2,\n      width: height - heightOffset,\n      height: width - widthOffset,\n      rx: rx,\n      className: className\n    });\n  }));\n}","map":{"version":3,"mappings":"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","names":["React","useMemo","clsx","matchesX","getKeyValue","styles","useVisualRefresh","BarSeries","axis","series","color","xScale","yScale","highlighted","dimmed","highlightedGroupIndex","stackedBarOffsets","totalSeriesCount","seriesIndex","plotSize","chartAreaClipPath","isRefresh","xCoordinates","type","isCategorical","yContinuosScale","d3Scale","xPoints","data","map","x","NaN","zeroY","baseY","isFinite","Math","min","barWidth","bandwidth","PADDING","MINWIDTH","max","i","d","barX","yValue","y","offsetMap","negativeOffsets","positiveOffsets","width","height","abs","highlightedXValue","domain","title","clipPath","className","baseHeightOffset","isSmallBar","heightOffset","widthOffset","rx","series__rect","key","fill"],"sources":["/Users/tangyizhi/Desktop/Assignment2/frontend/node_modules/@cloudscape-design/components/mixed-line-bar-chart/lib/default/mixed-line-bar-chart/bar-series.tsx"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport React, { useMemo } from 'react';\nimport clsx from 'clsx';\nimport { ScaleContinuousNumeric, ScaleTime } from '../internal/vendor/d3-scale';\n\nimport { ChartScale, NumericChartScale } from '../internal/components/cartesian-chart/scales';\nimport { ChartDataTypes, MixedLineBarChartProps } from './interfaces';\nimport { matchesX, getKeyValue, StackedOffsets } from './utils';\nimport styles from './styles.css.js';\nimport { useVisualRefresh } from '../internal/hooks/use-visual-mode';\nexport interface BarSeriesProps<T> {\n  axis: 'x' | 'y';\n\n  series: MixedLineBarChartProps.BarDataSeries<T>;\n\n  color: string;\n  totalSeriesCount: number;\n  seriesIndex: number;\n\n  xScale: ChartScale;\n  yScale: NumericChartScale;\n\n  plotSize: number;\n  chartAreaClipPath: string;\n\n  highlighted: boolean;\n  dimmed: boolean;\n  highlightedGroupIndex: number | null;\n\n  // Contains the cumulative offset for each x value in a stacked bar chart\n  stackedBarOffsets?: StackedOffsets;\n}\n\nexport default function BarSeries<T extends ChartDataTypes>({\n  axis,\n  series,\n  color,\n  xScale,\n  yScale,\n  highlighted,\n  dimmed,\n  highlightedGroupIndex,\n  stackedBarOffsets,\n  totalSeriesCount,\n  seriesIndex,\n  plotSize,\n  chartAreaClipPath,\n}: BarSeriesProps<T>) {\n  const isRefresh = useVisualRefresh();\n\n  const xCoordinates = useMemo(() => {\n    if (series.type !== 'bar' || !xScale.isCategorical()) {\n      return [];\n    }\n\n    const yContinuosScale: ScaleContinuousNumeric<number, number> | ScaleTime<number, number> = yScale.d3Scale;\n    const xPoints = (series.data as ReadonlyArray<MixedLineBarChartProps.Datum<ChartDataTypes>>).map(\n      ({ x }) => xScale.d3Scale(x) || NaN\n    );\n\n    const zeroY = yScale.d3Scale(0) ?? NaN;\n    const baseY = isFinite(zeroY) ? Math.min(plotSize, zeroY) : plotSize;\n\n    let barWidth = xScale.d3Scale.bandwidth();\n\n    const PADDING = 4;\n    const MINWIDTH = 4;\n\n    if (!stackedBarOffsets && totalSeriesCount > 1) {\n      // Regular grouped bars\n      barWidth = (barWidth - (totalSeriesCount - 1) * PADDING) / totalSeriesCount;\n      barWidth = Math.max(barWidth, MINWIDTH);\n    }\n\n    return xPoints.map((x, i) => {\n      const d = series.data[i];\n      let barX = x;\n      let yValue = d.y;\n\n      if (stackedBarOffsets) {\n        // Stacked bars\n        const offsetMap = d.y < 0 ? stackedBarOffsets.negativeOffsets : stackedBarOffsets.positiveOffsets;\n        yValue = d.y + (offsetMap[getKeyValue(d.x)] || 0);\n      } else if (totalSeriesCount > 1) {\n        // Regular grouped bars\n        barX += seriesIndex * (barWidth + PADDING);\n      }\n\n      // Account for negative values growing \"down\" instead of \"up\"\n      yValue = yValue < 0 ? yValue - d.y : yValue;\n\n      return {\n        x: barX,\n        y: yContinuosScale(yValue) ?? NaN,\n        width: barWidth,\n        height: Math.abs((yContinuosScale(d.y) ?? NaN) - baseY),\n      };\n    });\n  }, [series, xScale, yScale, plotSize, stackedBarOffsets, totalSeriesCount, seriesIndex]);\n\n  const highlightedXValue = highlightedGroupIndex !== null ? xScale.domain[highlightedGroupIndex] : null;\n\n  return (\n    <g\n      aria-label={series.title}\n      clipPath={`url(#${chartAreaClipPath})`}\n      className={clsx(styles.series, styles['series--bar'], {\n        [styles['series--highlighted']]: highlighted,\n        [styles['series--dimmed']]: dimmed,\n      })}\n    >\n      {xCoordinates.map(({ x, y, width, height }, i) => {\n        if (!isFinite(x) || !isFinite(height)) {\n          return;\n        }\n\n        // Create margins between stacked series but only when series data is not too small.\n        const baseHeightOffset = stackedBarOffsets ? 3 : 0;\n        const isSmallBar = height < 4;\n        const heightOffset = isSmallBar ? 0 : baseHeightOffset;\n        const widthOffset = 2;\n\n        const rx = isRefresh ? (isSmallBar ? '2px' : '4px') : '0px';\n        const className = clsx(styles.series__rect, {\n          [styles['series--dimmed']]: highlightedXValue !== null && !matchesX(highlightedXValue, series.data[i].x),\n        });\n\n        return axis === 'x' ? (\n          <rect\n            key={`bar-${i}`}\n            fill={color}\n            x={x + widthOffset / 2}\n            y={y + heightOffset / 2}\n            width={width - widthOffset}\n            height={height - heightOffset}\n            rx={rx}\n            className={className}\n          />\n        ) : (\n          <rect\n            key={`bar-${i}`}\n            fill={color}\n            x={y - height + heightOffset / 2}\n            y={x + widthOffset / 2}\n            width={height - heightOffset}\n            height={width - widthOffset}\n            rx={rx}\n            className={className}\n          />\n        );\n      })}\n    </g>\n  );\n}\n"]},"metadata":{},"sourceType":"module"}