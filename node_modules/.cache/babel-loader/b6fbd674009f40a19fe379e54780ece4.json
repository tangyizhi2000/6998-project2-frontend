{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/tangyizhi/Desktop/Assignment2/frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _slicedToArray from \"/Users/tangyizhi/Desktop/Assignment2/frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { nodeContains } from '@cloudscape-design/component-toolkit/dom';\nimport styles from '../styles.css.js';\nimport { isYThreshold } from '../utils';\nvar MAX_HOVER_MARGIN = 6;\nvar POPOVER_DEADZONE = 12;\nexport function useMouseHover(_ref) {\n  var plotRef = _ref.plotRef,\n    popoverRef = _ref.popoverRef,\n    scaledSeries = _ref.scaledSeries,\n    barGroups = _ref.barGroups,\n    highlightPoint = _ref.highlightPoint,\n    highlightGroup = _ref.highlightGroup,\n    clearHighlightedSeries = _ref.clearHighlightedSeries,\n    isGroupNavigation = _ref.isGroupNavigation,\n    isHandlersDisabled = _ref.isHandlersDisabled,\n    highlightX = _ref.highlightX;\n  var isMouseOverPopover = function isMouseOverPopover(event) {\n    var _a;\n    if ((_a = popoverRef.current) === null || _a === void 0 ? void 0 : _a.firstChild) {\n      var popoverPosition = popoverRef.current.firstChild.getBoundingClientRect();\n      if (event.clientX > popoverPosition.x - POPOVER_DEADZONE && event.clientX < popoverPosition.x + popoverPosition.width + POPOVER_DEADZONE && event.clientY > popoverPosition.y - POPOVER_DEADZONE && event.clientY < popoverPosition.y + popoverPosition.height + POPOVER_DEADZONE) {\n        return true;\n      }\n    }\n    return false;\n  };\n  var onSeriesMouseMove = function onSeriesMouseMove(event) {\n    var _a, _b;\n    var svgRect = event.target.getBoundingClientRect();\n    var offsetX = event.clientX - svgRect.left;\n    var closestX = scaledSeries.map(function (v) {\n      return v.x;\n    }).reduce(function (prev, curr) {\n      return Math.abs(curr - offsetX) < Math.abs(prev - offsetX) ? curr : prev;\n    }, -Infinity);\n    if (isFinite(closestX)) {\n      var offsetY = event.clientY - svgRect.top;\n      var closestY = scaledSeries.filter(function (v) {\n        return v.x === closestX || isYThreshold(v.series);\n      }).map(function (v) {\n        return v.y;\n      }).reduce(function (prev, curr) {\n        return Math.abs(curr - offsetY) < Math.abs(prev - offsetY) ? curr : prev;\n      }, -Infinity);\n      if (isFinite(closestY) && Math.abs(offsetX - closestX) < MAX_HOVER_MARGIN && Math.abs(offsetY - closestY) < MAX_HOVER_MARGIN) {\n        var _scaledSeries$filter = scaledSeries.filter(function (s) {\n            return (s.x === closestX || isYThreshold(s.series)) && s.y === closestY;\n          }),\n          _scaledSeries$filter2 = _slicedToArray(_scaledSeries$filter, 1),\n          _scaledSeries$filter3 = _scaledSeries$filter2[0],\n          color = _scaledSeries$filter3.color,\n          datum = _scaledSeries$filter3.datum,\n          series = _scaledSeries$filter3.series;\n        highlightPoint({\n          x: closestX,\n          y: closestY,\n          color: color,\n          datum: datum,\n          series: series\n        });\n      } else {\n        var datumX = null;\n        var _iterator = _createForOfIteratorHelper(scaledSeries),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var point = _step.value;\n            if (point.x === closestX) {\n              datumX = (_b = (_a = point.datum) === null || _a === void 0 ? void 0 : _a.x) !== null && _b !== void 0 ? _b : null;\n              break;\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n        highlightX({\n          scaledX: closestX,\n          label: datumX\n        });\n      }\n    }\n  };\n  var onGroupMouseMove = function onGroupMouseMove(event) {\n    var svgRect = event.target.getBoundingClientRect();\n    var offsetX = event.clientX - svgRect.left;\n    var offsetY = event.clientY - svgRect.top;\n    // If hovering over some group - highlight it.\n    for (var groupIndex = 0; groupIndex < barGroups.length; groupIndex++) {\n      var _barGroups$groupIndex = barGroups[groupIndex].position,\n        x = _barGroups$groupIndex.x,\n        y = _barGroups$groupIndex.y,\n        width = _barGroups$groupIndex.width,\n        height = _barGroups$groupIndex.height;\n      if (x <= offsetX && offsetX <= x + width && y <= offsetY && offsetY <= y + height) {\n        highlightGroup(groupIndex);\n        return;\n      }\n    }\n    // Otherwise - clear the highlight.\n    clearHighlightedSeries();\n  };\n  var onSVGMouseMove = function onSVGMouseMove(event) {\n    if (event.target === plotRef.current.svg && !isHandlersDisabled && !isMouseOverPopover(event)) {\n      if (isGroupNavigation) {\n        onGroupMouseMove(event);\n      } else if (scaledSeries.length > 0) {\n        onSeriesMouseMove(event);\n      }\n    }\n  };\n  var onSVGMouseOut = function onSVGMouseOut(event) {\n    if (isHandlersDisabled || isMouseOverPopover(event)) {\n      return;\n    }\n    if (!nodeContains(plotRef.current.svg, event.relatedTarget) || event.relatedTarget && event.relatedTarget.classList.contains(styles.series)) {\n      highlightX(null);\n      clearHighlightedSeries();\n    }\n  };\n  var onPopoverLeave = function onPopoverLeave(event) {\n    if (!plotRef.current.svg.contains(event.relatedTarget)) {\n      highlightX(null);\n      clearHighlightedSeries();\n    }\n  };\n  return {\n    onSVGMouseMove: onSVGMouseMove,\n    onSVGMouseOut: onSVGMouseOut,\n    onPopoverLeave: onPopoverLeave\n  };\n}","map":{"version":3,"mappings":";;AAAA;AACA;AACA,SAASA,YAAY,QAAQ,0CAA0C;AAKvE,OAAOC,MAAM,MAAM,kBAAkB;AAGrC,SAASC,YAAY,QAAQ,UAAU;AAEvC,IAAMC,gBAAgB,GAAG,CAAC;AAC1B,IAAMC,gBAAgB,GAAG,EAAE;AAe3B,OAAM,SAAUC,aAAa,OAWL;EAAA,IAVtBC,OAAO,QAAPA,OAAO;IACPC,UAAU,QAAVA,UAAU;IACVC,YAAY,QAAZA,YAAY;IACZC,SAAS,QAATA,SAAS;IACTC,cAAc,QAAdA,cAAc;IACdC,cAAc,QAAdA,cAAc;IACdC,sBAAsB,QAAtBA,sBAAsB;IACtBC,iBAAiB,QAAjBA,iBAAiB;IACjBC,kBAAkB,QAAlBA,kBAAkB;IAClBC,UAAU,QAAVA,UAAU;EAEV,IAAMC,kBAAkB,GAAG,SAArBA,kBAAkB,CAAIC,KAA+C,EAAI;;IAC7E,IAAI,gBAAU,CAACC,OAAO,0CAAEC,UAAU,EAAE;MAClC,IAAMC,eAAe,GAAIb,UAAU,CAACW,OAAO,CAACC,UAA0B,CAACE,qBAAqB,EAAE;MAC9F,IACEJ,KAAK,CAACK,OAAO,GAAGF,eAAe,CAACG,CAAC,GAAGnB,gBAAgB,IACpDa,KAAK,CAACK,OAAO,GAAGF,eAAe,CAACG,CAAC,GAAGH,eAAe,CAACI,KAAK,GAAGpB,gBAAgB,IAC5Ea,KAAK,CAACQ,OAAO,GAAGL,eAAe,CAACM,CAAC,GAAGtB,gBAAgB,IACpDa,KAAK,CAACQ,OAAO,GAAGL,eAAe,CAACM,CAAC,GAAGN,eAAe,CAACO,MAAM,GAAGvB,gBAAgB,EAC7E;QACA,OAAO,IAAI;;;IAGf,OAAO,KAAK;EACd,CAAC;EAED,IAAMwB,iBAAiB,GAAG,SAApBA,iBAAiB,CAAIX,KAA+C,EAAI;;IAC5E,IAAMY,OAAO,GAAIZ,KAAK,CAACa,MAAqB,CAACT,qBAAqB,EAAE;IACpE,IAAMU,OAAO,GAAGd,KAAK,CAACK,OAAO,GAAGO,OAAO,CAACG,IAAI;IAE5C,IAAMC,QAAQ,GAAGzB,YAAY,CAC1B0B,GAAG,CAAC,WAAC;MAAA,OAAIC,CAAC,CAACZ,CAAC;IAAA,EAAC,CACba,MAAM,CAAC,UAACC,IAAI,EAAEC,IAAI;MAAA,OAAMC,IAAI,CAACC,GAAG,CAACF,IAAI,GAAGP,OAAO,CAAC,GAAGQ,IAAI,CAACC,GAAG,CAACH,IAAI,GAAGN,OAAO,CAAC,GAAGO,IAAI,GAAGD,IAAI;IAAA,CAAC,EAAE,CAACI,QAAQ,CAAC;IAEzG,IAAIC,QAAQ,CAACT,QAAQ,CAAC,EAAE;MACtB,IAAMU,OAAO,GAAG1B,KAAK,CAACQ,OAAO,GAAGI,OAAO,CAACe,GAAG;MAC3C,IAAMC,QAAQ,GAAGrC,YAAY,CAC1BsC,MAAM,CAAC,WAAC;QAAA,OAAIX,CAAC,CAACZ,CAAC,KAAKU,QAAQ,IAAI/B,YAAY,CAACiC,CAAC,CAACY,MAAM,CAAC;MAAA,EAAC,CACvDb,GAAG,CAAC,WAAC;QAAA,OAAIC,CAAC,CAACT,CAAC;MAAA,EAAC,CACbU,MAAM,CAAC,UAACC,IAAI,EAAEC,IAAI;QAAA,OAAMC,IAAI,CAACC,GAAG,CAACF,IAAI,GAAGK,OAAO,CAAC,GAAGJ,IAAI,CAACC,GAAG,CAACH,IAAI,GAAGM,OAAO,CAAC,GAAGL,IAAI,GAAGD,IAAI;MAAA,CAAC,EAAE,CAACI,QAAQ,CAAC;MAEzG,IACEC,QAAQ,CAACG,QAAQ,CAAC,IAClBN,IAAI,CAACC,GAAG,CAACT,OAAO,GAAGE,QAAQ,CAAC,GAAG9B,gBAAgB,IAC/CoC,IAAI,CAACC,GAAG,CAACG,OAAO,GAAGE,QAAQ,CAAC,GAAG1C,gBAAgB,EAC/C;QACA,2BAAmCK,YAAY,CAACsC,MAAM,CACpD,WAAC;YAAA,OAAI,CAACE,CAAC,CAACzB,CAAC,KAAKU,QAAQ,IAAI/B,YAAY,CAAC8C,CAAC,CAACD,MAAM,CAAC,KAAKC,CAAC,CAACtB,CAAC,KAAKmB,QAAQ;UAAA,EACtE;UAAA;UAAA;UAFQI,KAAK,yBAALA,KAAK;UAAEC,KAAK,yBAALA,KAAK;UAAEH,MAAM,yBAANA,MAAM;QAG7BrC,cAAc,CAAC;UAAEa,CAAC,EAAEU,QAAQ;UAAEP,CAAC,EAAEmB,QAAQ;UAAEI,KAAK,EAALA,KAAK;UAAEC,KAAK,EAALA,KAAK;UAAEH,MAAM,EAANA;QAAM,CAAE,CAAC;OACnE,MAAM;QACL,IAAII,MAAM,GAAG,IAAI;QAAC,2CACE3C,YAAY;UAAA;QAAA;UAAhC,oDAAkC;YAAA,IAAvB4C,KAAK;YACd,IAAIA,KAAK,CAAC7B,CAAC,KAAKU,QAAQ,EAAE;cACxBkB,MAAM,GAAG,iBAAK,CAACD,KAAK,0CAAE3B,CAAC,mCAAI,IAAI;cAC/B;;;QAEH;UAAA;QAAA;UAAA;QAAA;QACDR,UAAU,CAAC;UAAEsC,OAAO,EAAEpB,QAAQ;UAAEqB,KAAK,EAAEH;QAAM,CAAE,CAAC;;;EAGtD,CAAC;EAED,IAAMI,gBAAgB,GAAG,SAAnBA,gBAAgB,CAAItC,KAA+C,EAAI;IAC3E,IAAMY,OAAO,GAAIZ,KAAK,CAACa,MAAqB,CAACT,qBAAqB,EAAE;IACpE,IAAMU,OAAO,GAAGd,KAAK,CAACK,OAAO,GAAGO,OAAO,CAACG,IAAI;IAC5C,IAAMW,OAAO,GAAG1B,KAAK,CAACQ,OAAO,GAAGI,OAAO,CAACe,GAAG;IAE3C;IACA,KAAK,IAAIY,UAAU,GAAG,CAAC,EAAEA,UAAU,GAAG/C,SAAS,CAACgD,MAAM,EAAED,UAAU,EAAE,EAAE;MACpE,4BAEI/C,SAAS,CAAC+C,UAAU,CAAC,CADvBE,QAAQ;QAAInC,CAAC,yBAADA,CAAC;QAAEG,CAAC,yBAADA,CAAC;QAAEF,KAAK,yBAALA,KAAK;QAAEG,MAAM,yBAANA,MAAM;MAGjC,IAAIJ,CAAC,IAAIQ,OAAO,IAAIA,OAAO,IAAIR,CAAC,GAAGC,KAAK,IAAIE,CAAC,IAAIiB,OAAO,IAAIA,OAAO,IAAIjB,CAAC,GAAGC,MAAM,EAAE;QACjFhB,cAAc,CAAC6C,UAAU,CAAC;QAC1B;;;IAGJ;IACA5C,sBAAsB,EAAE;EAC1B,CAAC;EAED,IAAM+C,cAAc,GAAG,SAAjBA,cAAc,CAAI1C,KAA+C,EAAI;IACzE,IAAIA,KAAK,CAACa,MAAM,KAAKxB,OAAO,CAACY,OAAQ,CAAC0C,GAAG,IAAI,CAAC9C,kBAAkB,IAAI,CAACE,kBAAkB,CAACC,KAAK,CAAC,EAAE;MAC9F,IAAIJ,iBAAiB,EAAE;QACrB0C,gBAAgB,CAACtC,KAAK,CAAC;OACxB,MAAM,IAAIT,YAAY,CAACiD,MAAM,GAAG,CAAC,EAAE;QAClC7B,iBAAiB,CAACX,KAAK,CAAC;;;EAG9B,CAAC;EAED,IAAM4C,aAAa,GAAG,SAAhBA,aAAa,CAAI5C,KAA+C,EAAI;IACxE,IAAIH,kBAAkB,IAAIE,kBAAkB,CAACC,KAAK,CAAC,EAAE;MACnD;;IAEF,IACE,CAACjB,YAAY,CAACM,OAAO,CAACY,OAAQ,CAAC0C,GAAG,EAAE3C,KAAK,CAAC6C,aAAwB,CAAC,IAClE7C,KAAK,CAAC6C,aAAa,IAAK7C,KAAK,CAAC6C,aAAyB,CAACC,SAAS,CAACC,QAAQ,CAAC/D,MAAM,CAAC8C,MAAM,CAAE,EAC3F;MACAhC,UAAU,CAAC,IAAI,CAAC;MAChBH,sBAAsB,EAAE;;EAE5B,CAAC;EAED,IAAMqD,cAAc,GAAG,SAAjBA,cAAc,CAAIhD,KAAuB,EAAI;IACjD,IAAI,CAACX,OAAO,CAACY,OAAQ,CAAC0C,GAAG,CAACI,QAAQ,CAAC/C,KAAK,CAAC6C,aAAqB,CAAC,EAAE;MAC/D/C,UAAU,CAAC,IAAI,CAAC;MAChBH,sBAAsB,EAAE;;EAE5B,CAAC;EAED,OAAO;IAAE+C,cAAc,EAAdA,cAAc;IAAEE,aAAa,EAAbA,aAAa;IAAEI,cAAc,EAAdA;EAAc,CAAE;AAC1D","names":["nodeContains","styles","isYThreshold","MAX_HOVER_MARGIN","POPOVER_DEADZONE","useMouseHover","plotRef","popoverRef","scaledSeries","barGroups","highlightPoint","highlightGroup","clearHighlightedSeries","isGroupNavigation","isHandlersDisabled","highlightX","isMouseOverPopover","event","current","firstChild","popoverPosition","getBoundingClientRect","clientX","x","width","clientY","y","height","onSeriesMouseMove","svgRect","target","offsetX","left","closestX","map","v","reduce","prev","curr","Math","abs","Infinity","isFinite","offsetY","top","closestY","filter","series","s","color","datum","datumX","point","scaledX","label","onGroupMouseMove","groupIndex","length","position","onSVGMouseMove","svg","onSVGMouseOut","relatedTarget","classList","contains","onPopoverLeave"],"sources":["/Users/tangyizhi/Desktop/Assignment2/frontend/node_modules/@cloudscape-design/components/mixed-line-bar-chart/hooks/lib/default/mixed-line-bar-chart/hooks/use-mouse-hover.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { nodeContains } from '@cloudscape-design/component-toolkit/dom';\n\nimport { ScaledBarGroup } from '../make-scaled-bar-groups';\nimport { ScaledPoint } from '../make-scaled-series';\n\nimport styles from '../styles.css.js';\nimport { ChartPlotRef } from '../../internal/components/chart-plot';\nimport { VerticalMarkerX } from '../interfaces';\nimport { isYThreshold } from '../utils';\n\nconst MAX_HOVER_MARGIN = 6;\nconst POPOVER_DEADZONE = 12;\n\nexport interface UseMouseHoverProps<T> {\n  plotRef: React.RefObject<ChartPlotRef>;\n  popoverRef: React.RefObject<HTMLElement>;\n  scaledSeries: ReadonlyArray<ScaledPoint<T>>;\n  barGroups: ScaledBarGroup<T>[];\n  highlightPoint: (point: ScaledPoint<T> | null) => void;\n  highlightGroup: (groupIndex: number) => void;\n  clearHighlightedSeries: () => void;\n  isGroupNavigation: boolean;\n  isHandlersDisabled: boolean;\n  highlightX: (verticalMarker: VerticalMarkerX<T> | null) => void;\n}\n\nexport function useMouseHover<T>({\n  plotRef,\n  popoverRef,\n  scaledSeries,\n  barGroups,\n  highlightPoint,\n  highlightGroup,\n  clearHighlightedSeries,\n  isGroupNavigation,\n  isHandlersDisabled,\n  highlightX,\n}: UseMouseHoverProps<T>) {\n  const isMouseOverPopover = (event: React.MouseEvent<SVGElement, MouseEvent>) => {\n    if (popoverRef.current?.firstChild) {\n      const popoverPosition = (popoverRef.current.firstChild as HTMLElement).getBoundingClientRect();\n      if (\n        event.clientX > popoverPosition.x - POPOVER_DEADZONE &&\n        event.clientX < popoverPosition.x + popoverPosition.width + POPOVER_DEADZONE &&\n        event.clientY > popoverPosition.y - POPOVER_DEADZONE &&\n        event.clientY < popoverPosition.y + popoverPosition.height + POPOVER_DEADZONE\n      ) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  const onSeriesMouseMove = (event: React.MouseEvent<SVGElement, MouseEvent>) => {\n    const svgRect = (event.target as SVGElement).getBoundingClientRect();\n    const offsetX = event.clientX - svgRect.left;\n\n    const closestX = scaledSeries\n      .map(v => v.x)\n      .reduce((prev, curr) => (Math.abs(curr - offsetX) < Math.abs(prev - offsetX) ? curr : prev), -Infinity);\n\n    if (isFinite(closestX)) {\n      const offsetY = event.clientY - svgRect.top;\n      const closestY = scaledSeries\n        .filter(v => v.x === closestX || isYThreshold(v.series))\n        .map(v => v.y)\n        .reduce((prev, curr) => (Math.abs(curr - offsetY) < Math.abs(prev - offsetY) ? curr : prev), -Infinity);\n\n      if (\n        isFinite(closestY) &&\n        Math.abs(offsetX - closestX) < MAX_HOVER_MARGIN &&\n        Math.abs(offsetY - closestY) < MAX_HOVER_MARGIN\n      ) {\n        const [{ color, datum, series }] = scaledSeries.filter(\n          s => (s.x === closestX || isYThreshold(s.series)) && s.y === closestY\n        );\n        highlightPoint({ x: closestX, y: closestY, color, datum, series });\n      } else {\n        let datumX = null;\n        for (const point of scaledSeries) {\n          if (point.x === closestX) {\n            datumX = point.datum?.x ?? null;\n            break;\n          }\n        }\n        highlightX({ scaledX: closestX, label: datumX });\n      }\n    }\n  };\n\n  const onGroupMouseMove = (event: React.MouseEvent<SVGElement, MouseEvent>) => {\n    const svgRect = (event.target as SVGElement).getBoundingClientRect();\n    const offsetX = event.clientX - svgRect.left;\n    const offsetY = event.clientY - svgRect.top;\n\n    // If hovering over some group - highlight it.\n    for (let groupIndex = 0; groupIndex < barGroups.length; groupIndex++) {\n      const {\n        position: { x, y, width, height },\n      } = barGroups[groupIndex];\n\n      if (x <= offsetX && offsetX <= x + width && y <= offsetY && offsetY <= y + height) {\n        highlightGroup(groupIndex);\n        return;\n      }\n    }\n    // Otherwise - clear the highlight.\n    clearHighlightedSeries();\n  };\n\n  const onSVGMouseMove = (event: React.MouseEvent<SVGElement, MouseEvent>) => {\n    if (event.target === plotRef.current!.svg && !isHandlersDisabled && !isMouseOverPopover(event)) {\n      if (isGroupNavigation) {\n        onGroupMouseMove(event);\n      } else if (scaledSeries.length > 0) {\n        onSeriesMouseMove(event);\n      }\n    }\n  };\n\n  const onSVGMouseOut = (event: React.MouseEvent<SVGElement, MouseEvent>) => {\n    if (isHandlersDisabled || isMouseOverPopover(event)) {\n      return;\n    }\n    if (\n      !nodeContains(plotRef.current!.svg, event.relatedTarget as Element) ||\n      (event.relatedTarget && (event.relatedTarget as Element).classList.contains(styles.series))\n    ) {\n      highlightX(null);\n      clearHighlightedSeries();\n    }\n  };\n\n  const onPopoverLeave = (event: React.MouseEvent) => {\n    if (!plotRef.current!.svg.contains(event.relatedTarget as Node)) {\n      highlightX(null);\n      clearHighlightedSeries();\n    }\n  };\n\n  return { onSVGMouseMove, onSVGMouseOut, onPopoverLeave };\n}\n"]},"metadata":{},"sourceType":"module"}