{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/tangyizhi/Desktop/Assignment2/frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n// Finds the longest property the filtering text starts from.\nexport function matchFilteringProperty(filteringProperties, filteringText) {\n  var maxLength = 0;\n  var matchedProperty = null;\n  var _iterator = _createForOfIteratorHelper(filteringProperties),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var property = _step.value;\n      if (property.propertyLabel.length >= maxLength && startsWith(filteringText, property.propertyLabel) || property.propertyLabel.length > maxLength && startsWith(filteringText.toLowerCase(), property.propertyLabel.toLowerCase())) {\n        maxLength = property.propertyLabel.length;\n        matchedProperty = property;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return matchedProperty;\n}\n// Finds the longest operator the filtering text starts from.\nexport function matchOperator(allowedOperators, filteringText) {\n  filteringText = filteringText.toLowerCase();\n  var maxLength = 0;\n  var matchedOperator = null;\n  var _iterator2 = _createForOfIteratorHelper(allowedOperators),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var operator = _step2.value;\n      if (operator.length > maxLength && startsWith(filteringText, operator.toLowerCase())) {\n        maxLength = operator.length;\n        matchedOperator = operator;\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  return matchedOperator;\n}\n// Finds if the filtering text matches any operator prefix.\nexport function matchOperatorPrefix(allowedOperators, filteringText) {\n  if (filteringText.trim().length === 0) {\n    return '';\n  }\n  var _iterator3 = _createForOfIteratorHelper(allowedOperators),\n    _step3;\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var operator = _step3.value;\n      if (startsWith(operator.toLowerCase(), filteringText.toLowerCase())) {\n        return filteringText;\n      }\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n  return null;\n}\nexport function matchTokenValue(_ref, filteringOptions) {\n  var property = _ref.property,\n    operator = _ref.operator,\n    value = _ref.value;\n  var _a, _b;\n  var propertyOptions = filteringOptions.filter(function (option) {\n    return option.property === property;\n  });\n  var bestMatch = {\n    propertyKey: property === null || property === void 0 ? void 0 : property.propertyKey,\n    operator: operator,\n    value: value\n  };\n  var _iterator4 = _createForOfIteratorHelper(propertyOptions),\n    _step4;\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var option = _step4.value;\n      if (option.label && option.label === value || !option.label && option.value === value) {\n        // exact match found: return it\n        return {\n          propertyKey: property === null || property === void 0 ? void 0 : property.propertyKey,\n          operator: operator,\n          value: option.value\n        };\n      }\n      // By default, the token value is a string, but when a custom property is used,\n      // the token value can be any, therefore we need to check for its type before calling toLowerCase()\n      if (typeof value === 'string' && value.toLowerCase() === ((_b = (_a = option.label) !== null && _a !== void 0 ? _a : option.value) !== null && _b !== void 0 ? _b : '').toLowerCase()) {\n        // non-exact match: save and keep running in case exact match found later\n        bestMatch.value = option.value;\n      }\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n  return bestMatch;\n}\nexport function getFormattedToken(token) {\n  var _a;\n  var valueFormatter = (_a = token.property) === null || _a === void 0 ? void 0 : _a.getValueFormatter(token.operator);\n  var propertyLabel = token.property && token.property.propertyLabel;\n  var tokenValue = valueFormatter ? valueFormatter(token.value) : token.value;\n  var label = \"\".concat(propertyLabel !== null && propertyLabel !== void 0 ? propertyLabel : '', \" \").concat(token.operator, \" \").concat(tokenValue);\n  return {\n    property: propertyLabel !== null && propertyLabel !== void 0 ? propertyLabel : '',\n    operator: token.operator,\n    value: tokenValue,\n    label: label\n  };\n}\nexport function trimStart(source) {\n  var spacesLength = 0;\n  for (var i = 0; i < source.length; i++) {\n    if (source[i] === ' ') {\n      spacesLength++;\n    } else {\n      break;\n    }\n  }\n  return source.slice(spacesLength);\n}\nexport function trimFirstSpace(source) {\n  return source[0] === ' ' ? source.slice(1) : source;\n}\nfunction startsWith(source, target) {\n  return source.indexOf(target) === 0;\n}","map":{"version":3,"mappings":"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","names":["matchFilteringProperty","filteringProperties","filteringText","maxLength","matchedProperty","property","propertyLabel","length","startsWith","toLowerCase","matchOperator","allowedOperators","matchedOperator","operator","matchOperatorPrefix","trim","matchTokenValue","filteringOptions","value","propertyOptions","filter","option","bestMatch","propertyKey","label","getFormattedToken","token","valueFormatter","getValueFormatter","tokenValue","trimStart","source","spacesLength","i","slice","trimFirstSpace","target","indexOf"],"sources":["/Users/tangyizhi/Desktop/Assignment2/frontend/node_modules/@cloudscape-design/components/property-filter/lib/default/property-filter/utils.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n  ComparisonOperator,\n  InternalFilteringOption,\n  InternalFilteringProperty,\n  InternalToken,\n  Token,\n} from './interfaces';\n\n// Finds the longest property the filtering text starts from.\nexport function matchFilteringProperty(\n  filteringProperties: readonly InternalFilteringProperty[],\n  filteringText: string\n): null | InternalFilteringProperty {\n  let maxLength = 0;\n  let matchedProperty: null | InternalFilteringProperty = null;\n\n  for (const property of filteringProperties) {\n    if (\n      (property.propertyLabel.length >= maxLength && startsWith(filteringText, property.propertyLabel)) ||\n      (property.propertyLabel.length > maxLength &&\n        startsWith(filteringText.toLowerCase(), property.propertyLabel.toLowerCase()))\n    ) {\n      maxLength = property.propertyLabel.length;\n      matchedProperty = property;\n    }\n  }\n\n  return matchedProperty;\n}\n\n// Finds the longest operator the filtering text starts from.\nexport function matchOperator(\n  allowedOperators: readonly ComparisonOperator[],\n  filteringText: string\n): null | ComparisonOperator {\n  filteringText = filteringText.toLowerCase();\n\n  let maxLength = 0;\n  let matchedOperator: null | ComparisonOperator = null;\n\n  for (const operator of allowedOperators) {\n    if (operator.length > maxLength && startsWith(filteringText, operator.toLowerCase())) {\n      maxLength = operator.length;\n      matchedOperator = operator;\n    }\n  }\n\n  return matchedOperator;\n}\n\n// Finds if the filtering text matches any operator prefix.\nexport function matchOperatorPrefix(\n  allowedOperators: readonly ComparisonOperator[],\n  filteringText: string\n): null | string {\n  if (filteringText.trim().length === 0) {\n    return '';\n  }\n  for (const operator of allowedOperators) {\n    if (startsWith(operator.toLowerCase(), filteringText.toLowerCase())) {\n      return filteringText;\n    }\n  }\n  return null;\n}\n\nexport function matchTokenValue(\n  { property, operator, value }: InternalToken,\n  filteringOptions: readonly InternalFilteringOption[]\n): Token {\n  const propertyOptions = filteringOptions.filter(option => option.property === property);\n  const bestMatch: Token = { propertyKey: property?.propertyKey, operator, value };\n  for (const option of propertyOptions) {\n    if ((option.label && option.label === value) || (!option.label && option.value === value)) {\n      // exact match found: return it\n      return { propertyKey: property?.propertyKey, operator, value: option.value };\n    }\n\n    // By default, the token value is a string, but when a custom property is used,\n    // the token value can be any, therefore we need to check for its type before calling toLowerCase()\n    if (typeof value === 'string' && value.toLowerCase() === (option.label ?? option.value ?? '').toLowerCase()) {\n      // non-exact match: save and keep running in case exact match found later\n      bestMatch.value = option.value;\n    }\n  }\n\n  return bestMatch;\n}\n\nexport function getFormattedToken(token: InternalToken) {\n  const valueFormatter = token.property?.getValueFormatter(token.operator);\n  const propertyLabel = token.property && token.property.propertyLabel;\n  const tokenValue = valueFormatter ? valueFormatter(token.value) : token.value;\n  const label = `${propertyLabel ?? ''} ${token.operator} ${tokenValue}`;\n  return { property: propertyLabel ?? '', operator: token.operator, value: tokenValue, label };\n}\n\nexport function trimStart(source: string): string {\n  let spacesLength = 0;\n  for (let i = 0; i < source.length; i++) {\n    if (source[i] === ' ') {\n      spacesLength++;\n    } else {\n      break;\n    }\n  }\n  return source.slice(spacesLength);\n}\n\nexport function trimFirstSpace(source: string): string {\n  return source[0] === ' ' ? source.slice(1) : source;\n}\n\nfunction startsWith(source: string, target: string): boolean {\n  return source.indexOf(target) === 0;\n}\n"]},"metadata":{},"sourceType":"module"}