{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport smoothScroll from './smooth-scroll';\nexport const onPaginationClick = (headerBarRef, direction) => {\n  if (!(headerBarRef === null || headerBarRef === void 0 ? void 0 : headerBarRef.current)) {\n    return;\n  }\n  const element = headerBarRef.current;\n  // Scroll each paginated section by 75% of what is already visible\n  const paginatedSectionSize = Math.ceil(element.clientWidth * 0.75);\n  if (direction === 1) {\n    smoothScroll(element, Math.min(element.scrollLeft + paginatedSectionSize, element.scrollWidth - element.offsetWidth));\n  }\n  if (direction === -1) {\n    smoothScroll(element, Math.max(element.scrollLeft - paginatedSectionSize, 0));\n  }\n};\nexport const hasHorizontalOverflow = (headerBar, leftOverflowButton) => {\n  const {\n    offsetWidth,\n    scrollWidth\n  } = headerBar;\n  // Need to account for pagination button width when deciding if there would be overflow without them\n  const paginationButtonsWidth = leftOverflowButton.current && 2 * leftOverflowButton.current.offsetWidth;\n  return paginationButtonsWidth ? scrollWidth > offsetWidth + paginationButtonsWidth : scrollWidth > offsetWidth;\n};\nexport const hasLeftOverflow = headerBar => {\n  return headerBar.scrollLeft > 0;\n};\nexport const hasRightOverflow = headerBar => {\n  const {\n    offsetWidth,\n    scrollLeft,\n    scrollWidth\n  } = headerBar;\n  // scrollLeft can be a decimal value on systems using display scaling\n  return Math.ceil(scrollLeft) < scrollWidth - offsetWidth;\n};\nexport const scrollIntoView = function (tabHeader, headerBar) {\n  let smooth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  if (!tabHeader || !headerBar) {\n    return;\n  }\n  // Extra left and right margin to always make the focus ring visible\n  const margin = 2;\n  let updatedLeftScroll = headerBar.scrollLeft;\n  // Anchor tab to left of scroll parent\n  updatedLeftScroll = Math.min(updatedLeftScroll, tabHeader.offsetLeft - margin);\n  // Anchor tab to right of scroll parent\n  updatedLeftScroll = Math.max(updatedLeftScroll, tabHeader.offsetLeft + tabHeader.offsetWidth - headerBar.offsetWidth + margin);\n  if (smooth) {\n    smoothScroll(headerBar, updatedLeftScroll);\n  } else {\n    headerBar.scrollLeft = updatedLeftScroll;\n  }\n};","map":{"version":3,"mappings":"AAAA;AACA;AACA,OAAOA,YAAY,MAAM,iBAAiB;AAE1C,OAAO,MAAMC,iBAAiB,GAAG,CAACC,YAA+C,EAAEC,SAAiB,KAAU;EAC5G,IAAI,EAACD,YAAY,aAAZA,YAAY,uBAAZA,YAAY,CAAEE,OAAO,GAAE;IAC1B;;EAEF,MAAMC,OAAO,GAAGH,YAAY,CAACE,OAAO;EAEpC;EACA,MAAME,oBAAoB,GAAGC,IAAI,CAACC,IAAI,CAACH,OAAO,CAACI,WAAW,GAAG,IAAI,CAAC;EAElE,IAAIN,SAAS,KAAK,CAAC,EAAE;IACnBH,YAAY,CACVK,OAAO,EACPE,IAAI,CAACG,GAAG,CAACL,OAAO,CAACM,UAAU,GAAGL,oBAAoB,EAAED,OAAO,CAACO,WAAW,GAAGP,OAAO,CAACQ,WAAW,CAAC,CAC/F;;EAEH,IAAIV,SAAS,KAAK,CAAC,CAAC,EAAE;IACpBH,YAAY,CAACK,OAAO,EAAEE,IAAI,CAACO,GAAG,CAACT,OAAO,CAACM,UAAU,GAAGL,oBAAoB,EAAE,CAAC,CAAC,CAAC;;AAEjF,CAAC;AAED,OAAO,MAAMS,qBAAqB,GAAG,CACnCC,SAAsB,EACtBC,kBAAgD,KACrC;EACX,MAAM;IAAEJ,WAAW;IAAED;EAAW,CAAE,GAAGI,SAAS;EAE9C;EACA,MAAME,sBAAsB,GAAGD,kBAAkB,CAACb,OAAO,IAAI,CAAC,GAAGa,kBAAkB,CAACb,OAAO,CAACS,WAAW;EACvG,OAAOK,sBAAsB,GAAGN,WAAW,GAAGC,WAAW,GAAGK,sBAAsB,GAAGN,WAAW,GAAGC,WAAW;AAChH,CAAC;AAED,OAAO,MAAMM,eAAe,GAAIH,SAAsB,IAAa;EACjE,OAAOA,SAAS,CAACL,UAAU,GAAG,CAAC;AACjC,CAAC;AAED,OAAO,MAAMS,gBAAgB,GAAIJ,SAAsB,IAAa;EAClE,MAAM;IAAEH,WAAW;IAAEF,UAAU;IAAEC;EAAW,CAAE,GAAGI,SAAS;EAC1D;EACA,OAAOT,IAAI,CAACC,IAAI,CAACG,UAAU,CAAC,GAAGC,WAAW,GAAGC,WAAW;AAC1D,CAAC;AAED,OAAO,MAAMQ,cAAc,GAAG,UAACC,SAAsB,EAAEN,SAAsB,EAAyB;EAAA,IAAvBO,MAAM,uEAAG,IAAI;EAC1F,IAAI,CAACD,SAAS,IAAI,CAACN,SAAS,EAAE;IAC5B;;EAEF;EACA,MAAMQ,MAAM,GAAG,CAAC;EAChB,IAAIC,iBAAiB,GAAGT,SAAS,CAACL,UAAU;EAE5C;EACAc,iBAAiB,GAAGlB,IAAI,CAACG,GAAG,CAACe,iBAAiB,EAAEH,SAAS,CAACI,UAAU,GAAGF,MAAM,CAAC;EAC9E;EACAC,iBAAiB,GAAGlB,IAAI,CAACO,GAAG,CAC1BW,iBAAiB,EACjBH,SAAS,CAACI,UAAU,GAAGJ,SAAS,CAACT,WAAW,GAAGG,SAAS,CAACH,WAAW,GAAGW,MAAM,CAC9E;EACD,IAAID,MAAM,EAAE;IACVvB,YAAY,CAACgB,SAAS,EAAES,iBAAiB,CAAC;GAC3C,MAAM;IACLT,SAAS,CAACL,UAAU,GAAGc,iBAAiB;;AAE5C,CAAC","names":["smoothScroll","onPaginationClick","headerBarRef","direction","current","element","paginatedSectionSize","Math","ceil","clientWidth","min","scrollLeft","scrollWidth","offsetWidth","max","hasHorizontalOverflow","headerBar","leftOverflowButton","paginationButtonsWidth","hasLeftOverflow","hasRightOverflow","scrollIntoView","tabHeader","smooth","margin","updatedLeftScroll","offsetLeft"],"sources":["/Users/tangyizhi/Desktop/Assignment2/frontend/node_modules/@cloudscape-design/components/tabs/lib/default/tabs/scroll-utils.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport smoothScroll from './smooth-scroll';\n\nexport const onPaginationClick = (headerBarRef: React.RefObject<HTMLUListElement>, direction: number): void => {\n  if (!headerBarRef?.current) {\n    return;\n  }\n  const element = headerBarRef.current;\n\n  // Scroll each paginated section by 75% of what is already visible\n  const paginatedSectionSize = Math.ceil(element.clientWidth * 0.75);\n\n  if (direction === 1) {\n    smoothScroll(\n      element,\n      Math.min(element.scrollLeft + paginatedSectionSize, element.scrollWidth - element.offsetWidth)\n    );\n  }\n  if (direction === -1) {\n    smoothScroll(element, Math.max(element.scrollLeft - paginatedSectionSize, 0));\n  }\n};\n\nexport const hasHorizontalOverflow = (\n  headerBar: HTMLElement,\n  leftOverflowButton: React.RefObject<HTMLElement>\n): boolean => {\n  const { offsetWidth, scrollWidth } = headerBar;\n\n  // Need to account for pagination button width when deciding if there would be overflow without them\n  const paginationButtonsWidth = leftOverflowButton.current && 2 * leftOverflowButton.current.offsetWidth;\n  return paginationButtonsWidth ? scrollWidth > offsetWidth + paginationButtonsWidth : scrollWidth > offsetWidth;\n};\n\nexport const hasLeftOverflow = (headerBar: HTMLElement): boolean => {\n  return headerBar.scrollLeft > 0;\n};\n\nexport const hasRightOverflow = (headerBar: HTMLElement): boolean => {\n  const { offsetWidth, scrollLeft, scrollWidth } = headerBar;\n  // scrollLeft can be a decimal value on systems using display scaling\n  return Math.ceil(scrollLeft) < scrollWidth - offsetWidth;\n};\n\nexport const scrollIntoView = (tabHeader: HTMLElement, headerBar: HTMLElement, smooth = true): void => {\n  if (!tabHeader || !headerBar) {\n    return;\n  }\n  // Extra left and right margin to always make the focus ring visible\n  const margin = 2;\n  let updatedLeftScroll = headerBar.scrollLeft;\n\n  // Anchor tab to left of scroll parent\n  updatedLeftScroll = Math.min(updatedLeftScroll, tabHeader.offsetLeft - margin);\n  // Anchor tab to right of scroll parent\n  updatedLeftScroll = Math.max(\n    updatedLeftScroll,\n    tabHeader.offsetLeft + tabHeader.offsetWidth - headerBar.offsetWidth + margin\n  );\n  if (smooth) {\n    smoothScroll(headerBar, updatedLeftScroll);\n  } else {\n    headerBar.scrollLeft = updatedLeftScroll;\n  }\n};\n"]},"metadata":{},"sourceType":"module"}