{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/tangyizhi/Desktop/Assignment2/frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nvar ARROW_OFFSET = 12;\nexport var PRIORITY_MAPPING = {\n  top: ['top-center', 'top-right', 'top-left', 'bottom-center', 'bottom-right', 'bottom-left', 'right-top', 'right-bottom', 'left-top', 'left-bottom'],\n  bottom: ['bottom-center', 'bottom-right', 'bottom-left', 'top-center', 'top-right', 'top-left', 'right-top', 'right-bottom', 'left-top', 'left-bottom'],\n  left: ['left-top', 'left-bottom', 'right-top', 'right-bottom', 'bottom-center', 'top-center', 'bottom-left', 'top-left', 'bottom-right', 'top-right'],\n  right: ['right-top', 'right-bottom', 'left-top', 'left-bottom', 'bottom-center', 'top-center', 'bottom-right', 'top-right', 'bottom-left', 'top-left']\n};\nvar RECTANGLE_CALCULATIONS = {\n  'top-center': function topCenter(_ref) {\n    var body = _ref.body,\n      trigger = _ref.trigger,\n      arrow = _ref.arrow;\n    return {\n      top: trigger.top - body.height - arrow.height,\n      left: trigger.left + trigger.width / 2 - body.width / 2,\n      width: body.width,\n      height: body.height\n    };\n  },\n  'top-right': function topRight(_ref2) {\n    var body = _ref2.body,\n      trigger = _ref2.trigger,\n      arrow = _ref2.arrow;\n    return {\n      top: trigger.top - body.height - arrow.height,\n      left: trigger.left,\n      width: body.width,\n      height: body.height\n    };\n  },\n  'top-left': function topLeft(_ref3) {\n    var body = _ref3.body,\n      trigger = _ref3.trigger,\n      arrow = _ref3.arrow;\n    return {\n      top: trigger.top - body.height - arrow.height,\n      left: trigger.left + trigger.width - body.width,\n      width: body.width,\n      height: body.height\n    };\n  },\n  'bottom-center': function bottomCenter(_ref4) {\n    var body = _ref4.body,\n      trigger = _ref4.trigger,\n      arrow = _ref4.arrow;\n    return {\n      top: trigger.top + trigger.height + arrow.height,\n      left: trigger.left + trigger.width / 2 - body.width / 2,\n      width: body.width,\n      height: body.height\n    };\n  },\n  'bottom-right': function bottomRight(_ref5) {\n    var body = _ref5.body,\n      trigger = _ref5.trigger,\n      arrow = _ref5.arrow;\n    return {\n      top: trigger.top + trigger.height + arrow.height,\n      left: trigger.left,\n      width: body.width,\n      height: body.height\n    };\n  },\n  'bottom-left': function bottomLeft(_ref6) {\n    var body = _ref6.body,\n      trigger = _ref6.trigger,\n      arrow = _ref6.arrow;\n    return {\n      top: trigger.top + trigger.height + arrow.height,\n      left: trigger.left + trigger.width - body.width,\n      width: body.width,\n      height: body.height\n    };\n  },\n  'right-top': function rightTop(_ref7) {\n    var body = _ref7.body,\n      trigger = _ref7.trigger,\n      arrow = _ref7.arrow;\n    return {\n      top: trigger.top + trigger.height / 2 - ARROW_OFFSET - arrow.height,\n      left: trigger.left + trigger.width + arrow.height,\n      width: body.width,\n      height: body.height\n    };\n  },\n  'right-bottom': function rightBottom(_ref8) {\n    var body = _ref8.body,\n      trigger = _ref8.trigger,\n      arrow = _ref8.arrow;\n    return {\n      top: trigger.top + trigger.height / 2 - body.height + ARROW_OFFSET + arrow.height,\n      left: trigger.left + trigger.width + arrow.height,\n      width: body.width,\n      height: body.height\n    };\n  },\n  'left-top': function leftTop(_ref9) {\n    var body = _ref9.body,\n      trigger = _ref9.trigger,\n      arrow = _ref9.arrow;\n    return {\n      top: trigger.top + trigger.height / 2 - ARROW_OFFSET - arrow.height,\n      left: trigger.left - body.width - arrow.height,\n      width: body.width,\n      height: body.height\n    };\n  },\n  'left-bottom': function leftBottom(_ref10) {\n    var body = _ref10.body,\n      trigger = _ref10.trigger,\n      arrow = _ref10.arrow;\n    return {\n      top: trigger.top + trigger.height / 2 - body.height + ARROW_OFFSET + arrow.height,\n      left: trigger.left - body.width - arrow.height,\n      width: body.width,\n      height: body.height\n    };\n  }\n};\n/**\n * Returns whether one rectangle fits in another.\n */\nfunction canRectFit(inner, outer) {\n  return inner.left >= outer.left && inner.top >= outer.top && inner.left + inner.width <= outer.left + outer.width && inner.top + inner.height <= outer.top + outer.height;\n}\nfunction fitIntoContainer(inner, outer) {\n  var left = inner.left,\n    width = inner.width,\n    top = inner.top,\n    height = inner.height;\n  // Adjust left boundary.\n  if (left < outer.left) {\n    width = left + width - outer.left;\n    left = outer.left;\n  }\n  // Adjust right boundary.\n  else if (left + width > outer.left + outer.width) {\n    width = outer.left + outer.width - left;\n  }\n  // Adjust top boundary.\n  if (top < outer.top) {\n    height = top + height - outer.top;\n    top = outer.top;\n  }\n  // Adjust bottom boundary.\n  else if (top + height > outer.top + outer.height) {\n    height = outer.top + outer.height - top;\n  }\n  return {\n    left: left,\n    width: width,\n    top: top,\n    height: height\n  };\n}\nfunction getLargestRect(rect1, rect2) {\n  var area1 = rect1.height * rect1.width;\n  var area2 = rect2.height * rect2.width;\n  return area1 >= area2 ? rect1 : rect2;\n}\n/**\n * Returns the area of the intersection of passed in rectangles or a null, if there is no intersection\n */\nexport function intersectRectangles(rectangles) {\n  var boundingOffset = null;\n  var _iterator = _createForOfIteratorHelper(rectangles),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var currentRect = _step.value;\n      if (!boundingOffset) {\n        boundingOffset = currentRect;\n        continue;\n      }\n      var left = Math.max(boundingOffset.left, currentRect.left);\n      var top = Math.max(boundingOffset.top, currentRect.top);\n      var right = Math.min(boundingOffset.left + boundingOffset.width, currentRect.left + currentRect.width);\n      var bottom = Math.min(boundingOffset.top + boundingOffset.height, currentRect.top + currentRect.height);\n      if (right < left || bottom < top) {\n        return null;\n      }\n      boundingOffset = {\n        left: left,\n        top: top,\n        width: right - left,\n        height: bottom - top\n      };\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return boundingOffset && boundingOffset.height * boundingOffset.width;\n}\n/**\n * A functions that returns the correct popover position based on screen dimensions.\n */\nexport function calculatePosition(preferred, trigger, arrow, body, container, viewport,\n// the popover is only bound by the viewport if it is rendered in a portal\nrenderWithPortal) {\n  var bestPositionOutsideViewport = null;\n  var largestArea = 0;\n  // Attempt to position the popover based on the priority list for this position,\n  // trying to fit it inside the container and inside the viewport.\n  var _iterator2 = _createForOfIteratorHelper(PRIORITY_MAPPING[preferred]),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var _internalPosition = _step2.value;\n      var boundingOffset = RECTANGLE_CALCULATIONS[_internalPosition]({\n        body: body,\n        trigger: trigger,\n        arrow: arrow\n      });\n      var fitsInContainer = renderWithPortal || canRectFit(boundingOffset, container);\n      var fitsInViewport = canRectFit(boundingOffset, viewport);\n      if (fitsInContainer && fitsInViewport) {\n        return {\n          internalPosition: _internalPosition,\n          boundingOffset: boundingOffset\n        };\n      }\n      var boundingRectangles = [boundingOffset, viewport];\n      if (!renderWithPortal) {\n        boundingRectangles.push(container);\n      }\n      var availableArea = intersectRectangles(boundingRectangles);\n      if (availableArea && availableArea > largestArea) {\n        bestPositionOutsideViewport = {\n          internalPosition: _internalPosition,\n          boundingOffset: boundingOffset\n        };\n        largestArea = availableArea;\n      }\n    }\n    // Use best possible placement.\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  var internalPosition = (bestPositionOutsideViewport === null || bestPositionOutsideViewport === void 0 ? void 0 : bestPositionOutsideViewport.internalPosition) || 'right-top';\n  // Get default rect for that placement.\n  var defaultOffset = RECTANGLE_CALCULATIONS[internalPosition]({\n    body: body,\n    trigger: trigger,\n    arrow: arrow\n  });\n  // Get largest possible rect that fits into viewport or container.\n  var optimisedOffset = fitIntoContainer(defaultOffset, renderWithPortal ? viewport : getLargestRect(container, viewport));\n  // If largest possible rect is smaller than original - set body scroll.\n  var scrollable = optimisedOffset.height < defaultOffset.height;\n  return {\n    internalPosition: internalPosition,\n    boundingOffset: optimisedOffset,\n    scrollable: scrollable\n  };\n}","map":{"version":3,"mappings":"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","names":["ARROW_OFFSET","PRIORITY_MAPPING","top","bottom","left","right","RECTANGLE_CALCULATIONS","body","trigger","arrow","height","width","canRectFit","inner","outer","fitIntoContainer","getLargestRect","rect1","rect2","area1","area2","intersectRectangles","rectangles","boundingOffset","currentRect","Math","max","min","calculatePosition","preferred","container","viewport","renderWithPortal","bestPositionOutsideViewport","largestArea","internalPosition","fitsInContainer","fitsInViewport","boundingRectangles","push","availableArea","defaultOffset","optimisedOffset","scrollable"],"sources":["/Users/tangyizhi/Desktop/Assignment2/frontend/node_modules/@cloudscape-design/components/popover/utils/lib/default/popover/utils/positions.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { PopoverProps, InternalPosition, BoundingOffset, BoundingBox } from '../interfaces';\n\n// A structure describing how the popover should be positioned\nexport interface CalculatePosition {\n  scrollable?: boolean;\n  internalPosition: InternalPosition;\n  boundingOffset: BoundingOffset;\n}\n\ninterface ElementGroup {\n  body: BoundingBox;\n  trigger: BoundingOffset;\n  arrow: BoundingBox;\n}\n\nconst ARROW_OFFSET = 12;\n\nexport const PRIORITY_MAPPING: Record<PopoverProps.Position, InternalPosition[]> = {\n  top: [\n    'top-center',\n    'top-right',\n    'top-left',\n    'bottom-center',\n    'bottom-right',\n    'bottom-left',\n    'right-top',\n    'right-bottom',\n    'left-top',\n    'left-bottom',\n  ],\n  bottom: [\n    'bottom-center',\n    'bottom-right',\n    'bottom-left',\n    'top-center',\n    'top-right',\n    'top-left',\n    'right-top',\n    'right-bottom',\n    'left-top',\n    'left-bottom',\n  ],\n  left: [\n    'left-top',\n    'left-bottom',\n    'right-top',\n    'right-bottom',\n    'bottom-center',\n    'top-center',\n    'bottom-left',\n    'top-left',\n    'bottom-right',\n    'top-right',\n  ],\n  right: [\n    'right-top',\n    'right-bottom',\n    'left-top',\n    'left-bottom',\n    'bottom-center',\n    'top-center',\n    'bottom-right',\n    'top-right',\n    'bottom-left',\n    'top-left',\n  ],\n};\n\nconst RECTANGLE_CALCULATIONS: Record<InternalPosition, (r: ElementGroup) => BoundingOffset> = {\n  'top-center': ({ body, trigger, arrow }) => {\n    return {\n      top: trigger.top - body.height - arrow.height,\n      left: trigger.left + trigger.width / 2 - body.width / 2,\n      width: body.width,\n      height: body.height,\n    };\n  },\n  'top-right': ({ body, trigger, arrow }) => {\n    return {\n      top: trigger.top - body.height - arrow.height,\n      left: trigger.left,\n      width: body.width,\n      height: body.height,\n    };\n  },\n  'top-left': ({ body, trigger, arrow }) => {\n    return {\n      top: trigger.top - body.height - arrow.height,\n      left: trigger.left + trigger.width - body.width,\n      width: body.width,\n      height: body.height,\n    };\n  },\n  'bottom-center': ({ body, trigger, arrow }) => {\n    return {\n      top: trigger.top + trigger.height + arrow.height,\n      left: trigger.left + trigger.width / 2 - body.width / 2,\n      width: body.width,\n      height: body.height,\n    };\n  },\n  'bottom-right': ({ body, trigger, arrow }) => {\n    return {\n      top: trigger.top + trigger.height + arrow.height,\n      left: trigger.left,\n      width: body.width,\n      height: body.height,\n    };\n  },\n  'bottom-left': ({ body, trigger, arrow }) => {\n    return {\n      top: trigger.top + trigger.height + arrow.height,\n      left: trigger.left + trigger.width - body.width,\n      width: body.width,\n      height: body.height,\n    };\n  },\n  'right-top': ({ body, trigger, arrow }) => {\n    return {\n      top: trigger.top + trigger.height / 2 - ARROW_OFFSET - arrow.height,\n      left: trigger.left + trigger.width + arrow.height,\n      width: body.width,\n      height: body.height,\n    };\n  },\n  'right-bottom': ({ body, trigger, arrow }) => {\n    return {\n      top: trigger.top + trigger.height / 2 - body.height + ARROW_OFFSET + arrow.height,\n      left: trigger.left + trigger.width + arrow.height,\n      width: body.width,\n      height: body.height,\n    };\n  },\n  'left-top': ({ body, trigger, arrow }) => {\n    return {\n      top: trigger.top + trigger.height / 2 - ARROW_OFFSET - arrow.height,\n      left: trigger.left - body.width - arrow.height,\n      width: body.width,\n      height: body.height,\n    };\n  },\n  'left-bottom': ({ body, trigger, arrow }) => {\n    return {\n      top: trigger.top + trigger.height / 2 - body.height + ARROW_OFFSET + arrow.height,\n      left: trigger.left - body.width - arrow.height,\n      width: body.width,\n      height: body.height,\n    };\n  },\n};\n\n/**\n * Returns whether one rectangle fits in another.\n */\nfunction canRectFit(inner: BoundingOffset, outer: BoundingOffset): boolean {\n  return (\n    inner.left >= outer.left &&\n    inner.top >= outer.top &&\n    inner.left + inner.width <= outer.left + outer.width &&\n    inner.top + inner.height <= outer.top + outer.height\n  );\n}\n\nfunction fitIntoContainer(inner: BoundingOffset, outer: BoundingOffset): BoundingOffset {\n  let { left, width, top, height } = inner;\n\n  // Adjust left boundary.\n  if (left < outer.left) {\n    width = left + width - outer.left;\n    left = outer.left;\n  }\n  // Adjust right boundary.\n  else if (left + width > outer.left + outer.width) {\n    width = outer.left + outer.width - left;\n  }\n  // Adjust top boundary.\n  if (top < outer.top) {\n    height = top + height - outer.top;\n    top = outer.top;\n  }\n  // Adjust bottom boundary.\n  else if (top + height > outer.top + outer.height) {\n    height = outer.top + outer.height - top;\n  }\n\n  return { left, width, top, height };\n}\n\nfunction getLargestRect(rect1: BoundingOffset, rect2: BoundingOffset): BoundingOffset {\n  const area1 = rect1.height * rect1.width;\n  const area2 = rect2.height * rect2.width;\n  return area1 >= area2 ? rect1 : rect2;\n}\n\n/**\n * Returns the area of the intersection of passed in rectangles or a null, if there is no intersection\n */\nexport function intersectRectangles(rectangles: BoundingOffset[]): number | null {\n  let boundingOffset: BoundingOffset | null = null;\n  for (const currentRect of rectangles) {\n    if (!boundingOffset) {\n      boundingOffset = currentRect;\n      continue;\n    }\n    const left = Math.max(boundingOffset.left, currentRect.left);\n    const top = Math.max(boundingOffset.top, currentRect.top);\n    const right = Math.min(boundingOffset.left + boundingOffset.width, currentRect.left + currentRect.width);\n    const bottom = Math.min(boundingOffset.top + boundingOffset.height, currentRect.top + currentRect.height);\n    if (right < left || bottom < top) {\n      return null;\n    }\n    boundingOffset = {\n      left,\n      top,\n      width: right - left,\n      height: bottom - top,\n    };\n  }\n  return boundingOffset && boundingOffset.height * boundingOffset.width;\n}\n\n/**\n * A functions that returns the correct popover position based on screen dimensions.\n */\nexport function calculatePosition(\n  preferred: PopoverProps.Position,\n  trigger: BoundingOffset,\n  arrow: BoundingBox,\n  body: BoundingBox,\n  container: BoundingOffset,\n  viewport: BoundingOffset,\n  // the popover is only bound by the viewport if it is rendered in a portal\n  renderWithPortal?: boolean\n): CalculatePosition {\n  let bestPositionOutsideViewport: CalculatePosition | null = null;\n  let largestArea = 0;\n\n  // Attempt to position the popover based on the priority list for this position,\n  // trying to fit it inside the container and inside the viewport.\n  for (const internalPosition of PRIORITY_MAPPING[preferred]) {\n    const boundingOffset = RECTANGLE_CALCULATIONS[internalPosition]({ body, trigger, arrow });\n    const fitsInContainer = renderWithPortal || canRectFit(boundingOffset, container);\n    const fitsInViewport = canRectFit(boundingOffset, viewport);\n    if (fitsInContainer && fitsInViewport) {\n      return { internalPosition, boundingOffset };\n    }\n    const boundingRectangles = [boundingOffset, viewport];\n    if (!renderWithPortal) {\n      boundingRectangles.push(container);\n    }\n    const availableArea = intersectRectangles(boundingRectangles);\n    if (availableArea && availableArea > largestArea) {\n      bestPositionOutsideViewport = { internalPosition, boundingOffset };\n      largestArea = availableArea;\n    }\n  }\n\n  // Use best possible placement.\n  const internalPosition = bestPositionOutsideViewport?.internalPosition || 'right-top';\n  // Get default rect for that placement.\n  const defaultOffset = RECTANGLE_CALCULATIONS[internalPosition]({ body, trigger, arrow });\n  // Get largest possible rect that fits into viewport or container.\n  const optimisedOffset = fitIntoContainer(\n    defaultOffset,\n    renderWithPortal ? viewport : getLargestRect(container, viewport)\n  );\n  // If largest possible rect is smaller than original - set body scroll.\n  const scrollable = optimisedOffset.height < defaultOffset.height;\n\n  return { internalPosition, boundingOffset: optimisedOffset, scrollable };\n}\n"]},"metadata":{},"sourceType":"module"}