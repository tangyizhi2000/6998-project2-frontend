{"ast":null,"code":"const BREAKPOINT_MAPPING = [['xl', 1840], ['l', 1320], ['m', 1120], ['s', 912], ['xs', 688], ['xxs', 465], ['default', -1]];\nexport const mobileBreakpoint = BREAKPOINT_MAPPING.filter(b => b[0] === 'xs')[0][1];\nconst BREAKPOINTS_DESCENDING = BREAKPOINT_MAPPING.map(_ref => {\n  let [bp] = _ref;\n  return bp;\n});\n/**\n * Take a breakpoint mapping and return the breakpoint value that most closely matches the actual breakpoint.\n */\nexport function matchBreakpointMapping(subset, actual) {\n  const qualifyingBreakpoints = BREAKPOINT_MAPPING.slice(BREAKPOINTS_DESCENDING.indexOf(actual));\n  for (const [breakpoint] of qualifyingBreakpoints) {\n    const breakpointValue = subset[breakpoint];\n    if (breakpointValue !== undefined) {\n      return breakpointValue;\n    }\n  }\n  return null;\n}\n/**\n * Get the named breakpoint for a provided width, optionally filtering to a subset of breakpoints.\n */\nexport function getMatchingBreakpoint(width, breakpointFilter) {\n  for (const [breakpoint, breakpointWidth] of BREAKPOINT_MAPPING) {\n    if (width > breakpointWidth && (!breakpointFilter || breakpointFilter.indexOf(breakpoint) !== -1)) {\n      return breakpoint;\n    }\n  }\n  return 'default';\n}\nexport function getBreakpointValue(breakpoint) {\n  return BREAKPOINT_MAPPING.find(bp => bp[0] === breakpoint)[1];\n}","map":{"version":3,"mappings":"AAIA,MAAMA,kBAAkB,GAA2B,CACjD,CAAC,IAAI,EAAE,IAAI,CAAC,EACZ,CAAC,GAAG,EAAE,IAAI,CAAC,EACX,CAAC,GAAG,EAAE,IAAI,CAAC,EACX,CAAC,GAAG,EAAE,GAAG,CAAC,EACV,CAAC,IAAI,EAAE,GAAG,CAAC,EACX,CAAC,KAAK,EAAE,GAAG,CAAC,EACZ,CAAC,SAAS,EAAE,CAAC,CAAC,CAAC,CAChB;AAED,OAAO,MAAMC,gBAAgB,GAAGD,kBAAkB,CAACE,MAAM,CAACC,CAAC,IAAIA,CAAC,CAAC,CAAC,CAAC,KAAK,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAEnF,MAAMC,sBAAsB,GAAGJ,kBAAkB,CAACK,GAAG,CAAC;EAAA,IAAC,CAACC,EAAE,CAAC;EAAA,OAAKA,EAAE;AAAA,EAAC;AAEnE;;;AAGA,OAAM,SAAUC,sBAAsB,CAAIC,MAAsC,EAAEC,MAAkB;EAClG,MAAMC,qBAAqB,GAAGV,kBAAkB,CAACW,KAAK,CAACP,sBAAsB,CAACQ,OAAO,CAACH,MAAM,CAAC,CAAC;EAC9F,KAAK,MAAM,CAACI,UAAU,CAAC,IAAIH,qBAAqB,EAAE;IAChD,MAAMI,eAAe,GAAGN,MAAM,CAACK,UAAU,CAAC;IAC1C,IAAIC,eAAe,KAAKC,SAAS,EAAE;MACjC,OAAOD,eAAe;;;EAG1B,OAAO,IAAI;AACb;AAEA;;;AAGA,OAAM,SAAUE,qBAAqB,CAACC,KAAa,EAAEC,gBAAwC;EAC3F,KAAK,MAAM,CAACL,UAAU,EAAEM,eAAe,CAAC,IAAInB,kBAAkB,EAAE;IAC9D,IAAIiB,KAAK,GAAGE,eAAe,KAAK,CAACD,gBAAgB,IAAIA,gBAAgB,CAACN,OAAO,CAACC,UAAU,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE;MACjG,OAAOA,UAAU;;;EAGrB,OAAO,SAAS;AAClB;AAEA,OAAM,SAAUO,kBAAkB,CAACP,UAAsB;EACvD,OAAOb,kBAAkB,CAACqB,IAAI,CAACf,EAAE,IAAIA,EAAE,CAAC,CAAC,CAAC,KAAKO,UAAU,CAAE,CAAC,CAAC,CAAC;AAChE","names":["BREAKPOINT_MAPPING","mobileBreakpoint","filter","b","BREAKPOINTS_DESCENDING","map","bp","matchBreakpointMapping","subset","actual","qualifyingBreakpoints","slice","indexOf","breakpoint","breakpointValue","undefined","getMatchingBreakpoint","width","breakpointFilter","breakpointWidth","getBreakpointValue","find"],"sources":["/Users/tangyizhi/Desktop/Assignment2/frontend/node_modules/@cloudscape-design/components/internal/lib/default/internal/breakpoints.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nexport type Breakpoint = 'default' | 'xxs' | 'xs' | 's' | 'm' | 'l' | 'xl';\n\nconst BREAKPOINT_MAPPING: [Breakpoint, number][] = [\n  ['xl', 1840],\n  ['l', 1320],\n  ['m', 1120],\n  ['s', 912],\n  ['xs', 688],\n  ['xxs', 465],\n  ['default', -1],\n];\n\nexport const mobileBreakpoint = BREAKPOINT_MAPPING.filter(b => b[0] === 'xs')[0][1];\n\nconst BREAKPOINTS_DESCENDING = BREAKPOINT_MAPPING.map(([bp]) => bp);\n\n/**\n * Take a breakpoint mapping and return the breakpoint value that most closely matches the actual breakpoint.\n */\nexport function matchBreakpointMapping<T>(subset: Partial<Record<Breakpoint, T>>, actual: Breakpoint): T | null {\n  const qualifyingBreakpoints = BREAKPOINT_MAPPING.slice(BREAKPOINTS_DESCENDING.indexOf(actual));\n  for (const [breakpoint] of qualifyingBreakpoints) {\n    const breakpointValue = subset[breakpoint];\n    if (breakpointValue !== undefined) {\n      return breakpointValue;\n    }\n  }\n  return null;\n}\n\n/**\n * Get the named breakpoint for a provided width, optionally filtering to a subset of breakpoints.\n */\nexport function getMatchingBreakpoint(width: number, breakpointFilter?: readonly Breakpoint[]): Breakpoint {\n  for (const [breakpoint, breakpointWidth] of BREAKPOINT_MAPPING) {\n    if (width > breakpointWidth && (!breakpointFilter || breakpointFilter.indexOf(breakpoint) !== -1)) {\n      return breakpoint;\n    }\n  }\n  return 'default';\n}\n\nexport function getBreakpointValue(breakpoint: Breakpoint): number {\n  return BREAKPOINT_MAPPING.find(bp => bp[0] === breakpoint)![1];\n}\n"]},"metadata":{},"sourceType":"module"}