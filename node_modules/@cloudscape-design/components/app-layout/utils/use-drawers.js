// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
import { useEffect, useRef, useState } from 'react';
import { useStableCallback } from '@cloudscape-design/component-toolkit/internal';
import { useControllable } from '../../internal/hooks/use-controllable';
import { fireNonCancelableEvent } from '../../internal/events';
import { awsuiPluginsInternal } from '../../internal/plugins/api';
import { sortByPriority } from '../../internal/plugins/helpers/utils';
import { convertRuntimeDrawers } from '../runtime-api';
import { togglesConfig } from '../toggles';
export const TOOLS_DRAWER_ID = 'awsui-internal-tools';
function getToolsDrawerItem(props) {
    if (props.toolsHide) {
        return null;
    }
    const { iconName, getLabels } = togglesConfig.tools;
    const { mainLabel, closeLabel, openLabel } = getLabels(props.ariaLabels);
    return {
        id: TOOLS_DRAWER_ID,
        content: props.tools,
        resizable: false,
        ariaLabels: {
            triggerButton: openLabel,
            closeButton: closeLabel,
            content: mainLabel,
        },
        trigger: {
            iconName: iconName,
        },
    };
}
function useRuntimeDrawers(disableRuntimeDrawers, activeDrawerId, onActiveDrawerChange) {
    const [runtimeDrawers, setRuntimeDrawers] = useState({ before: [], after: [] });
    const onActiveDrawerChangeStable = useStableCallback(onActiveDrawerChange);
    const drawerWasOpenRef = useRef(false);
    drawerWasOpenRef.current = drawerWasOpenRef.current || !!activeDrawerId;
    useEffect(() => {
        if (disableRuntimeDrawers) {
            return;
        }
        const unsubscribe = awsuiPluginsInternal.appLayout.onDrawersRegistered(drawers => {
            setRuntimeDrawers(convertRuntimeDrawers(drawers));
            if (!drawerWasOpenRef.current) {
                const defaultActiveDrawer = sortByPriority(drawers).find(drawer => drawer.defaultActive);
                if (defaultActiveDrawer) {
                    onActiveDrawerChangeStable(defaultActiveDrawer.id);
                }
            }
        });
        return () => {
            unsubscribe();
            setRuntimeDrawers({ before: [], after: [] });
        };
    }, [disableRuntimeDrawers, onActiveDrawerChangeStable]);
    return runtimeDrawers;
}
function applyToolsDrawer(toolsProps, runtimeDrawers) {
    const drawers = [...runtimeDrawers.before, ...runtimeDrawers.after];
    if (drawers.length === 0) {
        return null;
    }
    const toolsItem = getToolsDrawerItem(toolsProps);
    if (toolsItem) {
        drawers.unshift(toolsItem);
    }
    return drawers;
}
export function useDrawers({ drawers: ownDrawers, __disableRuntimeDrawers: disableRuntimeDrawers, }, toolsProps) {
    var _a, _b;
    const [activeDrawerId, setActiveDrawerId] = useControllable(ownDrawers === null || ownDrawers === void 0 ? void 0 : ownDrawers.activeDrawerId, ownDrawers === null || ownDrawers === void 0 ? void 0 : ownDrawers.onChange, undefined, {
        componentName: 'AppLayout',
        controlledProp: 'activeDrawerId',
        changeHandler: 'onChange',
    });
    const [drawerSizes, setDrawerSizes] = useState({});
    function onActiveDrawerResize({ id, size }) {
        setDrawerSizes(oldSizes => (Object.assign(Object.assign({}, oldSizes), { [id]: size })));
        fireNonCancelableEvent(activeDrawer === null || activeDrawer === void 0 ? void 0 : activeDrawer.onResize, { id, size });
        fireNonCancelableEvent(ownDrawers === null || ownDrawers === void 0 ? void 0 : ownDrawers.onResize, { id, size });
    }
    function onActiveDrawerChange(newDrawerId) {
        setActiveDrawerId(newDrawerId);
        if (hasOwnDrawers) {
            fireNonCancelableEvent(ownDrawers === null || ownDrawers === void 0 ? void 0 : ownDrawers.onChange, newDrawerId);
        }
        else if (!toolsProps.toolsHide) {
            toolsProps.onToolsToggle(newDrawerId === TOOLS_DRAWER_ID);
        }
    }
    const hasOwnDrawers = !!(ownDrawers === null || ownDrawers === void 0 ? void 0 : ownDrawers.items);
    const runtimeDrawers = useRuntimeDrawers(disableRuntimeDrawers, activeDrawerId, onActiveDrawerChange);
    const combinedDrawers = hasOwnDrawers
        ? [...runtimeDrawers.before, ...ownDrawers.items, ...runtimeDrawers.after]
        : applyToolsDrawer(toolsProps, runtimeDrawers);
    // support toolsOpen in runtime-drawers-only mode
    let activeDrawerIdResolved = toolsProps.toolsOpen && !hasOwnDrawers ? TOOLS_DRAWER_ID : activeDrawerId;
    const activeDrawer = combinedDrawers === null || combinedDrawers === void 0 ? void 0 : combinedDrawers.find(drawer => drawer.id === activeDrawerIdResolved);
    // ensure that id is only defined when the drawer exists
    activeDrawerIdResolved = activeDrawer === null || activeDrawer === void 0 ? void 0 : activeDrawer.id;
    return {
        ariaLabel: ownDrawers === null || ownDrawers === void 0 ? void 0 : ownDrawers.ariaLabel,
        overflowAriaLabel: ownDrawers === null || ownDrawers === void 0 ? void 0 : ownDrawers.overflowAriaLabel,
        overflowWithBadgeAriaLabel: ownDrawers === null || ownDrawers === void 0 ? void 0 : ownDrawers.overflowWithBadgeAriaLabel,
        drawers: combinedDrawers,
        activeDrawer,
        activeDrawerId: activeDrawerIdResolved,
        activeDrawerSize: activeDrawerIdResolved
            ? (_b = (_a = drawerSizes[activeDrawerIdResolved]) !== null && _a !== void 0 ? _a : activeDrawer === null || activeDrawer === void 0 ? void 0 : activeDrawer.defaultSize) !== null && _b !== void 0 ? _b : toolsProps.toolsWidth
            : toolsProps.toolsWidth,
        onActiveDrawerChange,
        onActiveDrawerResize,
    };
}
//# sourceMappingURL=use-drawers.js.map